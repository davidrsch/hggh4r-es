[
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "Git y GitHub con R",
    "section": "",
    "text": "Empecemos con Git\nEste libro le proporciona instrucciones sobre cómo:\nEl lector objetivo es alguien que usa R para análisis de datos o que trabaja en paquetes de R, aunque parte del contenido puede ser útil para quienes trabajan en áreas adyacentes.\nLas primeras dos partes, Instalación y Conectar Git, GitHub, RStudio, proporciona un inicio rápido para verificar su configuración.\nEn Primeras victorias en GitHub, acumulamos algunos éxitos iniciales con los flujos de trabajo básicos que son necesarios para llevar su trabajo a GitHub. También mostramos la sinergia especial entre R/R Markdown/RStudio y GitHub, lo que proporciona una poderosa demostración de por qué toda esta configuración vale la pena.\nEl uso de Git/GitHub en ciencia de datos tiene una vibra ligeramente diferente a la del desarrollo de software puro, debido a diferencias en el contexto y el objetivo del usuario. Happy Git tiene como objetivo complementar los recursos generales de Git existentes destacando los patrones de uso más gratificantes para la ciencia de datos. Esta perspectiva sobre el panorama de Git se presenta en Conceptos básicos de Git y Flujos de trabajo diarios.",
    "crumbs": [
      "Empecemos con Git"
    ]
  },
  {
    "objectID": "index.html#licencia",
    "href": "index.html#licencia",
    "title": "Git y GitHub con R",
    "section": "Licencia",
    "text": "Licencia\n\nHappy Git and GitHub for the useR de Jennifer Bryan esta licenciado bajo Creative Commons Attribution-NonCommercial 4.0 International License.",
    "crumbs": [
      "Empecemos con Git"
    ]
  },
  {
    "objectID": "index.html#sobre-la-traducción",
    "href": "index.html#sobre-la-traducción",
    "title": "Git y GitHub con R",
    "section": "Sobre la traducción",
    "text": "Sobre la traducción\nEsta traducción de “Git & GitHub con R” es un proyecto personal de David Díaz Rodríguez con el objetivo de facilitar el estudio del control de versiones en proyectos de Ciencia de Datos, tanto al propio traductor como a todas aquellas personas de habla hispana que deseen aprender sobre este tema.\nSeñalar que esta es una traducción textual del libro por lo que cuando se hacen referencias en primera persona se trata de los autores y no el traductor.\nSi detecta algún error relacionado con el contenido de la traducción, siéntase libre de abrir un issue o un pull request en este repositorio.",
    "crumbs": [
      "Empecemos con Git"
    ]
  },
  {
    "objectID": "overview.html",
    "href": "overview.html",
    "title": "1  ¿Por qué Git? ¿Por qué GitHub?",
    "section": "",
    "text": "1.1 ¿Por qué Git?\n¿Por qué un analista de datos utilizaría el control de versiones alojado?\nEsta introducción se ha convertido en un artículo independiente que posiblemente sea una mejor introducción en este momento. Hasta que lo vuelva a fusionar, considere leer el artículo: “Disculpe, ¿tiene un momento para hablar sobre el control de versiones?” https://dx.doi.org/10.7287%2Fpeerj.preprints.3159v2.\nGit es un sistema de control de versión. Su propósito original era ayudar a grupos de desarrolladores a trabajar en colaboración en grandes proyectos de software. Git gestiona la evolución de un conjunto de archivos, llamado repositorio, de una manera sensata y altamente estructurada. Si no tiene idea de lo que estoy hablando, considérelo como las funciones de “Seguimiento de cambios” de Microsoft Word con esteroides.\nGit ha sido reutilizado por la comunidad científica de datos. Además de usarlo para el código fuente, lo usamos para administrar la variada colección de archivos que componen los proyectos típicos de análisis de datos, que a menudo consisten en datos, cifras, informes y, sí, código fuente.\nUn analista de datos en solitario que trabaje en una sola computadora se beneficiará de la adopción del control de versiones. Pero no lo suficiente como para justificar el dolor de la instalación y la agitación del flujo de trabajo. Hay formas mucho más sencillas de obtener copias de seguridad versionadas de sus archivos, si eso es lo único que le preocupa.\nEn mi opinión, para los nuevos usuarios, las ventajas de Git sólo superan las desventajas cuando se tienen en cuenta los gastos generales de comunicación y colaboración con otras personas. ¿Quién de nosotros no necesita hacer eso? Su vida es mucho más fácil si esto está integrado en su flujo de trabajo, en lugar de ser un proceso separado que teme o descuida.",
    "crumbs": [
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>¿Por qué Git? ¿Por qué GitHub?</span>"
    ]
  },
  {
    "objectID": "overview.html#por-qué-github",
    "href": "overview.html#por-qué-github",
    "title": "1  ¿Por qué Git? ¿Por qué GitHub?",
    "section": "1.2 ¿Por qué GitHub?",
    "text": "1.2 ¿Por qué GitHub?\nAquí es donde los servicios de hosting como GitHub, Bitbucket, y GitLab intervienen. Proporcionan un hogar para sus proyectos basados en Git en Internet. Si no tienes idea de lo que estoy hablando, considéralo DropBox, pero es mucho, mucho mejor. El host remoto actúa como canal de distribución o centro de compensación para su proyecto administrado por Git. Permite que otras personas vean tus cosas, se sincronicen contigo y tal vez incluso realicen cambios. Estos proveedores de alojamiento mejoran los servidores Unix Git tradicionales con interfaces basadas en web bien diseñadas.\nIncluso para proyectos privados en solitario, es una buena idea trasladar su trabajo a una ubicación remota para su tranquilidad. ¿Por qué? Porque es bastante fácil arruinar tu repositorio Git local, especialmente cuando eres nuevo en esto. La buena noticia es que a menudo sólo se daña la infraestructura de Git. ¡Tus archivos están bien! Lo que hace que tu Git se vuelva aún más frustrante. Existen soluciones oficiales de Git para estos problemas, pero pueden requerir experiencia y paciencia a las que no puedes acceder a las 3 a.m. Si recientemente subiste tu trabajo a GitHub, es fácil obtener una copia nueva, arreglar las cosas con los cambios que solo existe localmente y continúa con tu vida.\nEn este libro se expone la integración con GitHub, no con Bitbucket o GitLab, por el bien de especificidad. Sin embargo, todos los principios generales e incluso algunas mecánicas se trasladarán a estas plataformas de alojamiento alternativas.\nNo se deje atrapar demasiado por lo público versus lo privado en este momento. Hay muchas formas de obtener repositorios privados de los principales proveedores a bajo costo o sin costo alguno. ¡Simplemente comience y descubra si Git/GitHub funcionará para usted y cómo! Si supera este acuerdo, puede invertir alguna combinación de conocimiento técnico y dinero en el problema. Puede pagar por un nivel superior de servicio o alojar usted mismo una de estas plataformas.",
    "crumbs": [
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>¿Por qué Git? ¿Por qué GitHub?</span>"
    ]
  },
  {
    "objectID": "overview.html#va-a-doler",
    "href": "overview.html#va-a-doler",
    "title": "1  ¿Por qué Git? ¿Por qué GitHub?",
    "section": "1.3 ¿Va a doler?",
    "text": "1.3 ¿Va a doler?\nSí.\nDebe instalar Git, hacer que Git local se comunique con GitHub y asegurarse de que RStudio pueda comunicarse con Git local (y, por lo tanto, con GitHub). Este es un dolor que ocurre una sola vez o una vez por computadora.\nPara proyectos nuevos o existentes, usted:\n\nDedícale un directorio (también conocido como “carpeta”).\nConviértalo en un proyecto RStudio.\nConviértalo en un repositorio Git.\nContinúe con sus asuntos habituales. Pero en lugar de solo guardar archivos individuales, periódicamente realiza una confirmación(commit), que toma una instantánea de varios archivos de todo el proyecto.\n\n¿Alguna vez ha versionado un archivo agregando sus iniciales o la fecha? Eso es efectivamente un commit, aunque solo para un único archivo: es una versión que es importante para usted y que quizás desee inspeccionar o volver a consultar más adelante.\n\nEnvíe (push) comits a GitHub periódicamente.\n\nEsto es como compartir un documento con colegas en DropBox o enviarlo como archivo adjunto de correo electrónico. Indica que estás listo para hacer que tu trabajo sea visible para otros e invitar a comentar o editar.\n\n\nEste es un cambio en su flujo de trabajo diario normal. Al principio se siente extraño, pero rápidamente se convierte en algo natural. FWIW, STAT 545 los estudiantes deben enviar todos los trabajos del curso a través de GitHub. Este es un tema importante en las horas de clase y de oficina durante las primeras dos semanas. Luego prácticamente nunca volvemos a hablar de ello.\nMás malas noticias. El dolor de STAT 545 dura poco porque los estudiantes trabajan principalmente en sus propios repositorios. ¿Utilizas GitHub para trabajar con otras personas o para coordinar tu propio trabajo desde varias computadoras? Si es así, después de que te recuperes de la configuración inicial, Git te aplastará nuevamente con conflictos de fusión. Y este no es un dolor que ocurre una sola vez, sino que puede ser un dolor sordo que dure mucho tiempo. El mejor remedio es la prevención, pero también comprender cómo salir de situaciones difíciles y abordarlas en sus propios términos.\nEl resto de este sitio está dedicado a guiarlo a través de la configuración necesaria y a crear sus primeros proyectos Git. Concluimos con indicaciones que lo guiarán a través de algunos de los usos más avanzados que hacen que todo este dolor inicial valga la pena.",
    "crumbs": [
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>¿Por qué Git? ¿Por qué GitHub?</span>"
    ]
  },
  {
    "objectID": "overview.html#cuál-es-la-recompensa",
    "href": "overview.html#cuál-es-la-recompensa",
    "title": "1  ¿Por qué Git? ¿Por qué GitHub?",
    "section": "1.4 ¿Cuál es la recompensa?",
    "text": "1.4 ¿Cuál es la recompensa?\nExposición: si alguien necesita ver tu trabajo o si quieres que pruebe tu código, puede obtenerlo fácilmente desde GitHub. Si usan Git, pueden clonar o bifurcar su repositorio. Si no usan Git, aún pueden explorar su proyecto en GitHub como un sitio web normal e incluso obtener todo descargando un archivo zip.\n¡Sea más entusiasta! Si le importa mucho el proyecto de otra persona, como un paquete R que usa mucho, puede realizar un seguimiento de su desarrollo en GitHub. Puede ver el repositorio para recibir notificaciones sobre actividades importantes. Puedes bifurcarlo para conservar tu propia copia. Puede modificar su bifurcación para agregar características o corregir errores y enviarlos de regreso al propietario como una propuesta de cambio.\nColaboración: si necesita colaborar en el análisis de datos o el desarrollo de código, todos deberían usar Git. Utilice GitHub como su centro de compensación: las personas trabajan de forma independiente y luego envían el trabajo a GitHub para su conciliación y transmisión al resto del equipo. La ventaja de Git/GitHub se destaca al comparar estas dos formas de colaborar en un documento:\n\nEditar, guardar, adjuntar. En este flujo de trabajo, todos tienen una (¡o más!) copias del documento y circulan como archivo adjunto por correo electrónico. ¿Cuál es “maestro”? ¿Es siquiera posible decirlo? ¿Cómo se relacionan las diferentes versiones entre sí? ¿Cómo deben conciliarse las versiones? Si quieres ver la mejor versión actual, ¿cómo la consigues? Todo esto normalmente se soluciona mediante un contrato social y un proceso bastante manual.\nGoogle Doc. En este flujo de trabajo, solo hay una copia del documento y se encuentra en la nube. Cualquiera puede acceder a la versión más reciente bajo demanda. Cualquiera puede editar, comentar o proponer un cambio y esto estará inmediatamente disponible para todos los demás. Cualquiera puede ver quién ha estado editando el documento y, si ocurre un desastre, puede volver a una versión anterior. Se ha eliminado una gran cantidad de ambigüedades y molestos trabajos de reconciliación.\n\nGestionar un proyecto a través de Git/GitHub se parece mucho más al escenario de Google Doc y disfruta de muchas de las mismas ventajas. Definitivamente es más complicado que colaborar en un documento de Google, pero esto te pone en la mentalidad correcta.",
    "crumbs": [
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>¿Por qué Git? ¿Por qué GitHub?</span>"
    ]
  },
  {
    "objectID": "overview.html#quién-puede-hacer-qué",
    "href": "overview.html#quién-puede-hacer-qué",
    "title": "1  ¿Por qué Git? ¿Por qué GitHub?",
    "section": "1.5 ¿Quién puede hacer qué?",
    "text": "1.5 ¿Quién puede hacer qué?\nUn repositorio público es legible por todo el mundo. El propietario puede otorgar niveles más altos de permiso a otros, como la capacidad de push commits.\nUn repositorio privado es invisible para el mundo. El propietario puede otorgar acceso de lectura, escritura (push) o administrador a otras personas.\nTambién existe una noción formal de organización, que puede resultar útil para gestionar permisos de repositorio para equipos completos de personas.",
    "crumbs": [
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>¿Por qué Git? ¿Por qué GitHub?</span>"
    ]
  },
  {
    "objectID": "overview.html#características-especiales-de-github",
    "href": "overview.html#características-especiales-de-github",
    "title": "1  ¿Por qué Git? ¿Por qué GitHub?",
    "section": "1.6 Características especiales de GitHub",
    "text": "1.6 Características especiales de GitHub\nesto quizás sea demasiado detallado… ¿punto final? ¿o pertenece a otra parte?\nAdemás de una interfaz de usuario bien diseñada, GitHub ofrece dos características especialmente importantes:\n\nProblemas(Issues). ¿Recuerda que estamos secuestrando herramientas de desarrollo de software? Bueno, este es el rastreador de errores. Es una lista de cosas… errores, solicitudes de funciones, tareas pendientes, lo que sea.\n\nLos problemas están estrechamente integrados con el correo electrónico y, por lo tanto, le permiten copiar/incrustar conversaciones importantes en el repositorio asociado.\nLos problemas se pueden asignar a personas (por ejemplo, para hacer) y etiquetarlos (“error” o “informe de progreso”).\nLos problemas están estrechamente integrados con las confirmaciones y, por lo tanto, le permiten registrar que los cambios en esta confirmación resuelven el problema que se discutió en esa edición.\nComo nuevo usuario de GitHub, una de las cosas más productivas que puede hacer es utilizar los problemas de GitHub para proporcionar un informe de error claro o una solicitud de función para un paquete que utiliza.\n\nSolicitudes de cambio (Pull request). Git permite que un proyecto tenga múltiples ramas de desarrollo independientes, con la idea de que algunas eventualmente deberían fusionarse nuevamente en la rama de desarrollo principal. Estos son términos técnicos de Git, pero es de esperar que también tengan sentido por sí solos. Una solicitud de cambio es una propuesta formal que dice: “Aquí hay algunos cambios que me gustaría realizar”. Podría estar vinculado a un problema específico: “Relacionado con el n.º 14”. o “Soluciona n.º 56”. GitHub facilita y preserva la discusión de la propuesta, de manera integral y línea por línea.",
    "crumbs": [
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>¿Por qué Git? ¿Por qué GitHub?</span>"
    ]
  },
  {
    "objectID": "overview.html#qué-tiene-de-especial-usar-r-con-git-y-github",
    "href": "overview.html#qué-tiene-de-especial-usar-r-con-git-y-github",
    "title": "1  ¿Por qué Git? ¿Por qué GitHub?",
    "section": "1.7 ¿Qué tiene de especial usar R con Git y GitHub?",
    "text": "1.7 ¿Qué tiene de especial usar R con Git y GitHub?\n\nLa comunidad activa de desarrollo de paquetes R en GitHub. Lea acerca de las búsquedas y los recursos de GitHub específicos de R aquí.\nLos flujos de trabajo específicos hacen que sea gratificante compartir código fuente, informes renderizados y proyectos completos. Leer más sobre R Markdown, R scripts, y R-heavy projects.\nFunciones relacionadas con Git y GitHub de RStudio IDE. Este aspecto se cubre a lo largo del libro.",
    "crumbs": [
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>¿Por qué Git? ¿Por qué GitHub?</span>"
    ]
  },
  {
    "objectID": "overview.html#audiencia-y-requisitos-previos",
    "href": "overview.html#audiencia-y-requisitos-previos",
    "title": "1  ¿Por qué Git? ¿Por qué GitHub?",
    "section": "1.8 Audiencia y requisitos previos",
    "text": "1.8 Audiencia y requisitos previos\nEl público objetivo de este sitio es alguien que analiza datos, probablemente con R, aunque parte del contenido puede ser útil para analistas que utilizan otros lenguajes. El desarrollo de paquetes R con Git(Hub) está absolutamente dentro del alcance, pero no es un enfoque o requisito explícito.\nEl sitio está dirigido a usuarios de R de nivel intermedio a avanzado, que se sienten cómodos escribiendo scripts de R y gestionando proyectos de R. Debe tener un buen conocimiento de los archivos y directorios y, en general, tener conocimientos sobre dónde se encuentran las cosas en su computadora.\nAunque mostraremos alternativas para la mayoría de las operaciones de Git, inevitablemente pasaremos algún tiempo en el shell y asumimos cierta experiencia previa. Por ejemplo, debe saber cómo abrir un shell, navegar a un directorio determinado y enumerar los archivos allí. Debería sentirse cómodo usando comandos de shell para ver/mover/renombrar archivos y trabajar con su historial de comandos.",
    "crumbs": [
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>¿Por qué Git? ¿Por qué GitHub?</span>"
    ]
  },
  {
    "objectID": "overview.html#lo-que-esto-no-es",
    "href": "overview.html#lo-que-esto-no-es",
    "title": "1  ¿Por qué Git? ¿Por qué GitHub?",
    "section": "1.9 Lo que esto NO es",
    "text": "1.9 Lo que esto NO es\nNuestro objetivo es enseñar a los principiantes sobre Git basándose estrictamente en la “necesidad de saberlo”. Git fue creado para gestionar el desarrollo del kernel de Linux, que probablemente sea muy diferente de lo que hace usted. La mayoría de la gente necesita un pequeño subconjunto de la funcionalidad de Git y ese será nuestro enfoque. Si desea una exposición completa de Git como un gráfico acíclico dirigido o un tratado sobre la estrategia de ramificación Git-Flow, no lo encontrará en este libro.",
    "crumbs": [
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>¿Por qué Git? ¿Por qué GitHub?</span>"
    ]
  },
  {
    "objectID": "contributors.html",
    "href": "contributors.html",
    "title": "2  Colaboradores",
    "section": "",
    "text": "Jenny Bryan (jennybryan.org), Ingeniera de Software en Posit en el equipo tidyverse/r-lib. Autor principal y coordinador de contenidos.\nEl desarrollo y entrega de este material también se ha beneficiado enormemente de las contribuciones de:\n\nDean Attali (deanattali.com), consultor Shiny y alumno ayudante de STAT 545.\nBernhard Konrad, Ingeniero de Software y alumno ayudante de STAT 545.\nShaun Jackman (sjackman.ca), estudiante de Doctorado en Bioinformática de la UBC, mantenedor principal de Linuxbrew, y alumno ayudante de STAT 545.\nJim Hester (jimhester.com), Ingeniero de Software en [Posit]((https://posit.co/) en el equipo tidyverse/r-lib.\nUn número creciente de contribuyentes de GitHub",
    "crumbs": [
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>Colaboradores</span>"
    ]
  },
  {
    "objectID": "workshops.html",
    "href": "workshops.html",
    "title": "3  Talleres de trabajo",
    "section": "",
    "text": "3.1 Configuración previa al taller\nEstos materiales se pueden utilizar para el estudio independiente, pero también se han utilizado como apoyo:\nLectura opcional sobre la motivación general: ¿Por qué Git?\nEs vital que intente configurar su sistema con anticipación. ¡No puedes presentarte al taller sin preparación y seguir al día!\nPrueba esto. En el mejor de los casos, es de aproximadamente 1 a 2 horas. Si choca contra una pared, le ayudaremos:\nSolución de problemas:\nEstas son instrucciones probadas en batalla, por lo que la mayoría tendrá éxito. ¡Creemos en ti! Si tiene problemas, busque ayuda y siga adelante. Dónde obtener ayuda:",
    "crumbs": [
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>Talleres de trabajo</span>"
    ]
  },
  {
    "objectID": "workshops.html#configuración-previa-al-taller",
    "href": "workshops.html#configuración-previa-al-taller",
    "title": "3  Talleres de trabajo",
    "section": "",
    "text": "Registre una cuenta de GitHub gratuita.\nInstalar o actualizar R y RStudio.\nInstalar Git.\nPreséntate a Git.\nConfigurar un token de acceso personal o configure claves SSH.\nPruebe si Git local puede comunicarse con GitHub.\nPruebe que RStudio puede encontrar Git local y, por lo tanto, puede hablar con GitHub.\n\nPara su información: aquí es donde normalmente comienzan nuestras actividades prácticas. Recorremos juntos una actividad similar, con narrativa, y construimos a partir de ahí.\n\nConsidere si desea instalar un cliente Git opcional, ahora o en el futuro.\n\n\n\nA veces RStudio necesita un poco de ayuda para encontrar Git.\nSolución de problemas generales: RStudio, Git, GitHub Hell.\n\n\n\nSi está inscrito en un próximo taller, encuéntrelo a continuación para obtener detalles sobre el soporte previo al taller.\nPodríamos poder responder a un problema de GitHub aquí.\nSi hay un ángulo claro de R/RStudio, publíquelo en https://forum.posit.co/.\nConsejo general: busque en Google y en https://stackoverflow.com, consulte también https://github.community.",
    "crumbs": [
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>Talleres de trabajo</span>"
    ]
  },
  {
    "objectID": "workshops.html#positconf-2023",
    "href": "workshops.html#positconf-2023",
    "title": "3  Talleres de trabajo",
    "section": "3.2 posit::conf 2023",
    "text": "3.2 posit::conf 2023\nTaller de 1 día: Lo que olvidaron enseñarte sobre R\nTendrá cobertura de medio día de Git/GitHub el 17 de septiembre, posit.co/conference Día del taller, Chicago\nLos participantes registrados en el taller deben utilizar este hilo en forum.posit.co para analizar los problemas de preparación del sistema.",
    "crumbs": [
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>Talleres de trabajo</span>"
    ]
  },
  {
    "objectID": "workshops.html#talleres-anteriores",
    "href": "workshops.html#talleres-anteriores",
    "title": "3  Talleres de trabajo",
    "section": "3.3 Talleres anteriores",
    "text": "3.3 Talleres anteriores\n\nrstudio::conf 2022\nTaller de 2 días: Lo que olvidaron enseñarte sobre R\n\n~25% del contenido era Git/GitHub\n25 y 26 de julio de 2022, Washington, D.C.\nRaukR: Escuela de Verano de R Avanzado para Bioinformática\n\n13 de junio de 2022, en línea\n\nrstudio::conf 2020\n\nTaller de 2 días: Lo que olvidaron enseñarte sobre R\n\n~25% del contenido era Git/GitHub + R/Rmd/RStudio\n\n27 y 28 de enero de 2020, San Francisco, California\n\nUBC Programa de Maestría en Ciencia de Datos\n\nConferencia invitada sobre los flujos de trabajo diarios de Git/GitHub\n9 de enero de 2020\n\nRaukR: Escuela de verano de R avanzado para bioinformática\n\n10-20 de junio de 2019, Visby, Suecia\n\nrstudio::conf 2019\n\nTaller de 2 días: Lo que olvidaron enseñarte sobre R\n\n~25% del contenido era Git/GitHub + R/Rmd/RStudio\n\n15 y 16 de enero de 2019, Austin, TX\n\nSeattle Octubre 2018\n\nTaller de 2 días: Lo que olvidaron enseñarte sobre R\n\n3 de 8 unidades en Git/GitHub + R/Rmd/RStudio\n\n4 y 5 de octubre de 2018, The Westin Seattle\n\nrstudio::conf 2018\n\nTaller de 2 días: Lo que olvidaron enseñarte sobre R\n\n~25% del contenido era Git/GitHub + R/Rmd/RStudio\n\n31 de enero y 1 de febrero de 2018, San Diego, CA\n\nCSAMA 2017: Análisis de datos estadísticos para la biología del genoma\n\nhttp://www.huber.embl.de/csama2017/\n\n11-16 de junio de 2017, Bressanone-Brixen, Italia\n\n\nCiudad del Cabo 2017\n\nhttp://capetown2017.satrdays.org\n\n16 al 18 de febrero de 2017, Ciudad del Cabo, Sudáfrica\n\nrstudio::conf 2017\n\nhttps://posit.co/conference/\n\n13 - 14 de enero de 2017, Orlando, FL\n\nSábado 14 de enero de 10:15 a 12:30\n\nCSAMA 2016: Análisis de datos estadísticos para la biología del genoma\n\nhttp://www.huber.embl.de/csama2016/\n\n10 - 15 de julio de 2016, Bressanone-Brixen, Italia\n\n\nuseR! 2016 Stanford\n\nhttp://user2016.r-project.org\n\nLunes, 27 de junio de 2016\n\nUsing Git and GitHub with R, RStudio, and R Markdown",
    "crumbs": [
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>Talleres de trabajo</span>"
    ]
  },
  {
    "objectID": "install-intro.html",
    "href": "install-intro.html",
    "title": "La mitad de la batalla",
    "section": "",
    "text": "Éxito y sistemas operativos.\nHonestamente, instalar, configurar y ejecutar todo el software necesario en conjunto es la mitad de la batalla cuando se adopta Git por primera vez. Prepárate para un poco de dolor. La ventaja es que puedes darte una palmadita en la espalda una vez que superes esto. Y superarás esto.\nEncontrará muchos más recursos sobre cómo usar Git que para la instalación y configuración. ¿Por qué? Los expertos …\nEn su defensa, es difícil escribir instrucciones de instalación. Las fallas pueden ser específicas de un sistema operativo individual o incluso de una computadora individual. Si tienes algún problema nuevo y, especialmente, la solución correspondiente, ¡nos encantaría saber de ti!\nNuestras instrucciones de instalación han sido forjadas en los fuegos de STAT 545, STAT 540, y talleres variados, durante varios años. Regularmente escuchamos de almas agradecidas en internet que también han tenido éxito.\nAquí hay datos sobre los sistemas operativos que encontramos en STAT 545 y otros talleres: en general, la mayor parte se divide en partes iguales entre Mac y Windows (varios sabores), con una pizca de Linux. Excepto en el contexto de BioConductor (CSAMA), que está dominado por Mac o Linux.\n* Windows 10 es el cajón de sastre de Windows, cuando no tengo información más específica.",
    "crumbs": [
      "Instalación",
      "La mitad de la batalla"
    ]
  },
  {
    "objectID": "install-intro.html#éxito-y-sistemas-operativos.",
    "href": "install-intro.html#éxito-y-sistemas-operativos.",
    "title": "La mitad de la batalla",
    "section": "",
    "text": "2014\n2015\n2016\nuseR! 2016\nCSAMA 2016\nCSAMA 2017\nr::c 2018\nseattle 2018\n\n\n\n\nMac\n16 (41%)\n38 (52%)\n37 (45%)\n28 (44%)\n25 (58%)\n23 (56%)\n51 (57%)\n16 (49%)\n\n\nWindows 10*\n0 (0%)\n8 (11%)\n30 (36%)\n27 (43%)\n6 (14%)\n8 (20%)\n19 (21%)\n12 (36%)\n\n\nWindows 8\n12 (31%)\n9 (12%)\n4 (5%)\n\n\n1 ( 2%)\n2 (2%)\n\n\n\nWindows 7\n9 (23%)\n13 (18%)\n10 (12%)\n\n\n1 ( 2%)\n13 (14%)\n4 (12%)\n\n\nLinux\n2 (5%)\n5 (7%)\n2 (2%)\n8 (13%)\n12 (28%)\n9 (20%)\n5 (6%)\n1 (3%)",
    "crumbs": [
      "Instalación",
      "La mitad de la batalla"
    ]
  },
  {
    "objectID": "install-github-acct.html",
    "href": "install-github-acct.html",
    "title": "4  Crear una cuenta de GitHub",
    "section": "",
    "text": "4.1 Consejos de nombre de usuario\nCrear una cuenta con GitHub. ¡Es gratis!\nPodrás actualizar a un nivel de servicio pago, aplicar descuentos, unirte a organizaciones, etc. en el futuro, así que no te preocupes por nada de eso ahora. Excepto tu nombre de usuario. Tal vez quieras pensarlo un poco.\nAlgunos consejos que lamentablemente tienden a contradecirse:\nPuedes cambiar tu nombre de usuario más tarde, pero es mejor hacerlo bien la primera vez.",
    "crumbs": [
      "Instalación",
      "<span class='chapter-number'>4</span>  <span class='chapter-title'>Crear una cuenta de GitHub</span>"
    ]
  },
  {
    "objectID": "install-github-acct.html#consejos-de-nombre-de-usuario",
    "href": "install-github-acct.html#consejos-de-nombre-de-usuario",
    "title": "4  Crear una cuenta de GitHub",
    "section": "",
    "text": "¡Incorpora tu nombre real! A la gente le gusta saber con quién están tratando. También hace que su nombre de usuario sea más fácil de adivinar o recordar.\nReutiliza tu nombre de usuario de otros contextos, por ejemplo, Twitter o Slack. Pero, por supuesto, alguien sin actividad en GitHub probablemente estará ocupado con eso.\nElija un nombre de usuario que le resulte cómodo revelarle a su futuro jefe.\nMás corto es mejor que más largo.\nSer lo más único posible en la menor cantidad de caracteres posible. En algunas configuraciones, GitHub completa automáticamente o sugiere nombres de usuario.\nHazlo atemporal. No resalte su universidad, empleador o lugar de residencia actual, p.ejemplo JennySeLaCuadra.\nEvite palabras cargadas de significado especial en programación. En mis primeros esfuerzos ineptos para crear scripts en torno a la API de GitHub, le asigné muchos problemas a el tipo con el nombre de usuario NA porque mi vector de nombres de usuarios de GitHub contenía valores faltantes. Una variante de Little Bobby Tables.\nEvite el uso de mayúsculas y minúsculas para separar palabras. Recomendamos encarecidamente todo en minúsculas. GitHub trata los nombres de usuario sin distinguir entre mayúsculas y minúsculas, pero usar todas las minúsculas es más amable con las personas que realizan trabajos de expresión regular posteriores con nombres de usuarios, en varios idiomas. Una mejor estrategia para la separación de palabras es utilizar un guión -.\n\n\n\nhttps://help.github.com/articles/changing-your-github-username/\nhttps://help.github.com/articles/what-happens-when-i-change-my-username/",
    "crumbs": [
      "Instalación",
      "<span class='chapter-number'>4</span>  <span class='chapter-title'>Crear una cuenta de GitHub</span>"
    ]
  },
  {
    "objectID": "install-github-acct.html#repositorios-privados-gratuitos",
    "href": "install-github-acct.html#repositorios-privados-gratuitos",
    "title": "4  Crear una cuenta de GitHub",
    "section": "4.2 Repositorios privados gratuitos",
    "text": "4.2 Repositorios privados gratuitos\nGitHub ofrece repositorios privados ilimitados y gratuitos para todos los usuarios. Estos repositorios privados gratuitos admiten hasta tres colaboradores externos, lo que los convierte en un lugar perfecto para sus proyectos personales, para solicitudes de empleo y para probar cosas antes de convertir su proyecto en código abierto.\nContinúe y registre su cuenta gratuita AHORA y luego busque cualquier oferta especial que se aplique a usted:\n\nEstudiantes, profesores y personal educativo/investigador: GitHub Education.\n\nGitHub “Organizations” puede ser extremadamente útil para cursos o grupos de investigación/laboratorio, donde se necesita cierta coordinación entre un conjunto de repositorios y usuarios.\n\nOrganizaciones oficiales sin fines de lucro y organizaciones benéficas: GitHub for Good",
    "crumbs": [
      "Instalación",
      "<span class='chapter-number'>4</span>  <span class='chapter-title'>Crear una cuenta de GitHub</span>"
    ]
  },
  {
    "objectID": "install-github-acct.html#pagar-por-repositorios-privados",
    "href": "install-github-acct.html#pagar-por-repositorios-privados",
    "title": "4  Crear una cuenta de GitHub",
    "section": "4.3 Pagar por repositorios privados",
    "text": "4.3 Pagar por repositorios privados\nCualquiera puede pagar para tener repositorios privados con soporte para colaboradores ilimitados. Un plan personal con repositorios privados que admite colaboradores ilimitados cuesta $ 7 por mes al momento de escribir este artículo e incluye varias [funciones avanzadas] (https://help.github.com/articles/github-s-products/#github-pro ). Vea los planes y precios actuales aquí:\n\nhttps://github.com/pricing\n\nContinúe y registre su cuenta gratuita AHORA. Podrás decidir más adelante si deseas actualizar a un plan pago.",
    "crumbs": [
      "Instalación",
      "<span class='chapter-number'>4</span>  <span class='chapter-title'>Crear una cuenta de GitHub</span>"
    ]
  },
  {
    "objectID": "install-r-rstudio.html",
    "href": "install-r-rstudio.html",
    "title": "5  Instalar o actualizar R y RStudio",
    "section": "",
    "text": "5.1 Cómo pensar en actualizar R y RStudio\nManténgase actualizado, gente. No querrás adoptar cosas nuevas desde el primer día. Pero en algún momento, ejecutar versiones antiguas de software añade dificultades innecesarias.\nEn los talleres en vivo, hay un límite en cuanto a cuánto podemos ayudar con versiones antiguas de R o RStudio. Además, francamente, nuestra motivación tiene un límite. Por definición, estos problemas van a desaparecer y preferimos centrarnos en los casos extremos con las versiones actuales, que afectan a mucha gente.\n¿Su versión R es “antigua”? R tuvo un cambio de versión importante en abril de 2020, con el lanzamiento de 4.0.0. Es una buena idea estar en la versión principal actual, es decir, algo en este momento, especialmente si desea aprovechar al máximo un taller.\nA cada versión principal le siguen varios años de versiones más pequeñas (versiones menores y de parches). Puede estar más relajado acerca de la actualización de versiones menores, pero aun así desea mantenerse razonablemente actualizado. A medida que se desarrolla la serie 4.algo, te aconsejo que nunca te quedes atrás más de una versión menor.\nEjemplo concreto: digamos que la versión publicada de R es 4.7.1, que es totalmente ficticia y va mucho más allá de la versión actual de R en el momento de escribir este artículo. Probablemente esté bien si todavía estás en 4.6.lo que sea, que es una versión menor detrás y se llama “r-oldrel”. Estar una versión menor por detrás no suele causar problemas. Una vez que tenga 2 versiones menores detrás (4.5.lo que sea o anterior en este ejemplo), comenzará a sufrir. En particular, ya no puede instalar paquetes complementarios binarios prediseñados desde CRAN.\n¿Su RStudio es “viejo”? A menos que tenga una razón específica para preferir la versión publicada, pruebe la Vista previa. La versión preliminar suele ser la misma que la versión general. Pero en la preparación para una nueva versión general, la versión preliminar se utiliza para las versiones candidatas. La versión preliminar incluye funciones nuevas (próximas), pero en general también es muy estable y muy utilizable. Puede esperar actualizar RStudio con mucha más frecuencia que el propio R. Por ejemplo, actualizo RStudio aproximadamente cada mes, mientras que actualizo R 1 o 2 veces al año.",
    "crumbs": [
      "Instalación",
      "<span class='chapter-number'>5</span>  <span class='chapter-title'>Instalar o actualizar R y RStudio</span>"
    ]
  },
  {
    "objectID": "install-r-rstudio.html#cómo-pensar-en-actualizar-r-y-rstudio",
    "href": "install-r-rstudio.html#cómo-pensar-en-actualizar-r-y-rstudio",
    "title": "5  Instalar o actualizar R y RStudio",
    "section": "",
    "text": "Página principal de descarga de RStudio IDE: https://posit.co/download/rstudio-desktop/#download\n\nPágina de descarga de vista previa de RStudio IDE: https://www.rstudio.com/products/rstudio/download/preview/",
    "crumbs": [
      "Instalación",
      "<span class='chapter-number'>5</span>  <span class='chapter-title'>Instalar o actualizar R y RStudio</span>"
    ]
  },
  {
    "objectID": "install-git.html",
    "href": "install-git.html",
    "title": "6  Instalar Git",
    "section": "",
    "text": "6.1 ¿Ya tiene Git instalado?\nNecesitas Git, para poder usarlo en la línea de comando y para que RStudio pueda llamarlo.\nSi existe alguna posibilidad de que ya esté instalado, verifíquelo, regocíjese y omita este paso. (Pero considere actualizar una instalación existente).\nDe lo contrario, encuentre las instrucciones de instalación a continuación para su sistema operativo.\nVaya al shell (Apéndice A). Ingrese which git para solicitar la ruta a su ejecutable de Git:\nwhich git\n## /usr/bin/git\ny git --version para ver su versión:\ngit --version\n## git version 2.50.1\nSi tienes éxito, ¡genial! Ya tienes Git. ¡No es necesario instalarlo! Siga adelante.\nSi, en cambio, ves algo más parecido a git: command not found, sigue leyendo.\nLos usuarios de macOS pueden recibir una oferta inmediata para instalar herramientas de desarrollo de línea de comandos. ¡Sí, deberías aceptar! Haga clic en “Instalar” y lea más a continuación.",
    "crumbs": [
      "Instalación",
      "<span class='chapter-number'>6</span>  <span class='chapter-title'>Instalar Git</span>"
    ]
  },
  {
    "objectID": "install-git.html#sec-install-git-windows",
    "href": "install-git.html#sec-install-git-windows",
    "title": "6  Instalar Git",
    "section": "\n6.2 Windows",
    "text": "6.2 Windows\nOpción 1 (muy recomendable): Instalar Git para Windows, también conocido como msysgit o “Git Bash”, para obtener Git además de otras herramientas útiles, como el shell Bash. Sí, todos esos nombres son totalmente confusos, pero es posible que los encuentres en otros lugares y quiero que estés bien informado.\nNos gusta esto porque Git para Windows deja el ejecutable de Git en una ubicación convencional, lo que le ayudará a usted y a otros programas, por ejemplo. RStudio, encontrarlo y usarlo. Esto también admite una transición a un uso más experto, porque el shell “Git Bash” será útil cuando se aventure fuera de R/RStudio.\n\n\nNOTA: Cuando se le pregunte acerca de “Ajustar su entorno PATH”, asegúrese de seleccionar “Git desde la línea de comandos y también desde software de terceros”. De lo contrario, creemos que es bueno aceptar los valores predeterminados.\nTenga en cuenta que RStudio para Windows prefiere que Git se instale debajo de C:/Program Files y este parece ser el valor predeterminado. Esto implica, por ejemplo, que el ejecutable de Git en mi sistema Windows se encuentra en C:/Program Files/Git/bin/git.exe. A menos que tenga motivos específicos para lo contrario, siga esta convención.\n\nEsto también te deja con un cliente Git, aunque no muy bueno. Así que consulte los clientes de Git que recomendamos (Capítulo 8).\nPara su información, esto parece ser equivalente a lo que descargaría desde aquí: https://git-scm.com/download/.\nOpción 2 (recomendado): Instalar Git para Windows a través del administrador de paquetes Chocolatey. Si esto significa algo para ti, Chocolatey es como apt-get o Homebrew, pero para Windows en lugar de Debian/Ubuntu Linux o macOS. Hasta donde puedo decir, usar Chocolatey para instalar Git para Windows da el mismo resultado que instalarlo usted mismo (opción 1).\nObviamente, esto requiere que ya tengas Chocolatey instalado o que estés listo para instalarlo. No es difícil y las instrucciones están aquí. Esto puede valer la pena si parece probable que instale más software de código abierto en el futuro.\nDespués de instalar Chocolatey, en un shell (Apéndice A), haga:\nchoco install git.install\nEsto instala el paquete Chocolatey Git (Install) X.Y.Z más actual. Al momento de escribir este artículo, es “Git (Install) 2.33.1”, pero ese número de versión aumentará con el tiempo.\n\n6.2.1 Actualización de Git para Windows\nSi ya tienes Git para Windows, pero no es la última versión, es una buena idea actualizarla. Puedes actualizar así desde la línea de comando:\ngit update-git-for-windows",
    "crumbs": [
      "Instalación",
      "<span class='chapter-number'>6</span>  <span class='chapter-title'>Instalar Git</span>"
    ]
  },
  {
    "objectID": "install-git.html#macos",
    "href": "install-git.html#macos",
    "title": "6  Instalar Git",
    "section": "\n6.3 macOS",
    "text": "6.3 macOS\nOpción 1 (muy recomendable): Instale las herramientas de línea de comandos de Xcode (no todas las de Xcode), que incluyen Git.\nVaya al shell e ingrese uno de estos comandos para obtener una oferta para instalar herramientas de línea de comandos para desarrolladores:\ngit --version\ngit config\n¡Acepto la oferta! Haga clic en “Instalar”.\nAquí tienes otra forma de solicitar esta instalación, más directamente:\nxcode-select --install\nResulta que encontramos apropiado este activador basado en Git.\nTenga en cuenta también que, después de actualizar macOS, es posible que deba volver a hacer lo anterior y/o volver a aceptar el acuerdo de licencia de Xcode. Hemos visto que esto hace que el panel RStudio Git desaparezca en un sistema donde estaba funcionando anteriormente. Utilice comandos como los anteriores para hacerle cosquillas a Xcode para que le solicite lo que necesita y luego reinicie RStudio.\nOpción 2 (recomendado): Instale Git desde aquí: http://git-scm.com/downloads.\n\nPodría decirse que esto le prepara lo mejor para el futuro. Sin duda, obtendrá la última versión de Git de todos los enfoques descritos aquí.\nEl inicio de GitHub para el instalador de macOS está aquí: https://github.com/timcharper/git_osx_installer.\n\nEn ese enlace, puedes encontrar más información si algo sale mal o si estás trabajando en una versión anterior de macOS.\n\n\n\nOpción 3 (recomendada): si prevé dedicarse mucho a la informática científica, instalará y actualizará una gran cantidad de software. Deberías consultar Homebrew, “el administrador de paquetes que falta para OS X”. Entre muchas otras cosas, puede instalar Git por ti. Una vez que haya instalado Homebrew, haga esto en el shell:\nbrew install git",
    "crumbs": [
      "Instalación",
      "<span class='chapter-number'>6</span>  <span class='chapter-title'>Instalar Git</span>"
    ]
  },
  {
    "objectID": "install-git.html#linux",
    "href": "install-git.html#linux",
    "title": "6  Instalar Git",
    "section": "\n6.4 Linux",
    "text": "6.4 Linux\nInstale Git a través del administrador de paquetes de su distribución.\nUbuntu o Debian Linux:\nsudo apt-get install git\nFedora o RedHat Linux:\nsudo yum install git\nUna lista completa de varios administradores de paquetes de Linux y Unix:\nhttps://git-scm.com/download/linux",
    "crumbs": [
      "Instalación",
      "<span class='chapter-number'>6</span>  <span class='chapter-title'>Instalar Git</span>"
    ]
  },
  {
    "objectID": "install-introduce-self-git.html",
    "href": "install-introduce-self-git.html",
    "title": "7  Preséntate a Git",
    "section": "",
    "text": "7.1 Más sobre git config\nEn el shell (Apéndice A):\nsustituyendo su nombre y el correo electrónico asociado con su cuenta de GitHub.\nEl paquete usethis ofrece un enfoque alternativo. Puede configurar su nombre de usuario de Git y su correo electrónico desde R:\nUna manera fácil de acceder a un shell desde RStudio es Tools &gt; Terminal or Tools &gt; Shell. Más sobre el shell en el Apéndice A.\nProblemas especiales de Windows: si tiene problemas con Windows, considere que existen diferentes tipos de shell y es posible que esté en el equivocado. Desea estar en un shell “Git Bash”, a diferencia de Power Shell o el símbolo del sistema heredado cmd.exe. Lea más en el Apéndice. Esta también podría ser una razón para realizar esta configuración a través del paquete usethis en R.\n¿Qué nombre de usuario deberías darle a Git? No es necesario que sea su nombre de usuario de GitHub, aunque puede serlo. Otra buena opción es su nombre y apellido reales. Si realiza commits desde diferentes máquinas, a veces las personas introducen esa información en el nombre de usuario. Sus commits estarán etiquetadas con este nombre de usuario, así que hágalo informativo para los colaboradores potenciales y para usted en el futuro.\n¿Qué correo electrónico deberías darle a Git? Este debe ser el correo electrónico asociado con su cuenta de GitHub.\nLos primeros dos comandos utilizados en el shell que comienzan con git config --global no devuelve nada en la terminal. Puedes comprobar que Git entendió lo que escribiste mirando el resultado del tercero de git config --global --list.",
    "crumbs": [
      "Instalación",
      "<span class='chapter-number'>7</span>  <span class='chapter-title'>Preséntate a Git</span>"
    ]
  },
  {
    "objectID": "install-introduce-self-git.html#más-sobre-git-config",
    "href": "install-introduce-self-git.html#más-sobre-git-config",
    "title": "7  Preséntate a Git",
    "section": "",
    "text": "7.1.1 Configurar el editor Git\nOtra opción de Git que mucha gente acaba configurando es el editor. En algún momento, no podrás darle a Git lo que quiere en términos de un mensaje de commit y te enviará a un editor. Esto puede ser angustioso si no es su editor preferido y ni siquiera sabe cómo guardar y salir. Puedes hacer cumplir tu voluntad con algo como esto:\ngit config --global core.editor \"emacs\"\nSustituya aquí su editor preferido por \"emacs\". La lección de Git de Software Carpentry tiene una lista completa del comando exacto git config necesario para muchas combinaciones de sistema operativo y editor.\n\n7.1.2 Configurar el nombre predeterminado para una rama inicial\nEs posible que también desee configurar el nombre predeterminado para la rama inicial en un nuevo repositorio. Históricamente, esto ha sido master, ya que estaba integrado en el propio Git. Es cada vez más común usar main en su lugar, pero debes aceptarlo.\nEn 2020, se introdujo la configuración init.defaultBranch para que el usuario pueda configurarla. Poco después, los principales hosts de Git como GitHub y GitLab hicieron de main el nombre de rama inicial predeterminado para los repositorios creados en sus plataformas y también brindaron un soporte considerable para cambiar el nombre de las ramas predeterminadas existentes.\nPuede configurar su nombre de rama inicial predeterminado en main así, en el shell:\ngit config --global init.defaultBranch main\no desde R (el valor predeterminado para name es \"main\"):\n\nusethis::git_default_branch_configure()",
    "crumbs": [
      "Instalación",
      "<span class='chapter-number'>7</span>  <span class='chapter-title'>Preséntate a Git</span>"
    ]
  },
  {
    "objectID": "install-git-client.html",
    "href": "install-git-client.html",
    "title": "8  Instalar un cliente Git",
    "section": "",
    "text": "8.1 ¿Qué es un cliente Git? ¿Por qué querrías uno?\nEsto es opcional pero muy recomendable.\nAprender a utilizar el control de versiones puede resultar complicado al principio. El uso de una GUI, a diferencia de la línea de comandos, me resultó extremadamente útil cuando comencé. A este tipo de aplicación auxiliar la llamo cliente Git. Es realmente un cliente Git(Hub) porque también te ayuda a interactuar con GitHub u otros controles remotos.\nNo se requiere un cliente Git para los talleres en vivo y no se enseñará explícitamente, aunque es posible que nos vea usando uno de estos clientes.\n“Git” es en realidad solo una colección de comandos individuales que se ejecutan en el shell (Apéndice A). Esta interfaz no es atractiva para todos. Es posible que algunos prefieran realizar operaciones de Git a través de un cliente con una interfaz gráfica.\nGit y su cliente Git no son lo mismo, al igual que R y RStudio no son lo mismo. Un cliente Git y un entorno de desarrollo integrado, como RStudio, no son necesarios para usar Git o R, respectivamente. Pero hacen que la experiencia sea más placentera porque reducen la cantidad de “tonterías en la línea de comandos”1 y brindan una representación visual más rica del estado actual.\nRStudio ofrece un cliente Git muy básico a través de su panel Git. Lo uso a menudo para operaciones simples, pero probablemente también quieras otro más potente.\nAdvertencia justa: para algunas tareas, debes usar la línea de comando. Pero cuanto más poderoso sea su cliente Git, menos frecuente será que esto suceda. La descripción visual proporcionada por su cliente Git también puede ser invaluable para comprender el estado actual de las cosas, incluso al preparar llamadas a la línea de comandos de Git.\nFantásticas noticias: debido a que todos los clientes simplemente están formando y ejecutando comandos de Git en su nombre, no es necesario que elija uno. Literalmente puedes hacer una operación desde la línea de comando, hacer otra desde RStudio y otra desde GitKraken, una tras otra, y simplemente funciona. Muy raramente, ambos clientes escanearán el repositorio al mismo tiempo y recibirás un mensaje de error sobre .git/index.lock. Intente la operación nuevamente al menos una vez antes de seguir solucionando el problema.",
    "crumbs": [
      "Instalación",
      "<span class='chapter-number'>8</span>  <span class='chapter-title'>Instalar un cliente Git</span>"
    ]
  },
  {
    "objectID": "install-git-client.html#una-imagen-vale-mas-que-mil-palabras",
    "href": "install-git-client.html#una-imagen-vale-mas-que-mil-palabras",
    "title": "8  Instalar un cliente Git",
    "section": "8.2 Una imagen vale mas que mil palabras",
    "text": "8.2 Una imagen vale mas que mil palabras\nAquí hay una captura de pantalla de GitKraken (ver más abajo) abierta en el repositorio del paquete R pkgdown. Obtiene una buena descripción gráfica del historial de commits recientes, ramas y diferencias, así como una GUI que facilita las operaciones de Git más comunes.\n\n\n\n\n\nEn contraste, aquí hay una sesión de shell en la que utilicé la línea de comando Git para acceder a parte de la misma información.\njenny@jennys-MacBook-Pro pkgdown % git log --oneline -n 10\ncd888bed (HEAD -&gt; master, upstream/master, upstream/HEAD, r-lib/master, r-lib/HEAD) Remove accidentally committed snapshot\nca01d386 Add a skip link (#1833)\n1f07a145 Include section class in generated subsection divs\n26e1dcf2 Restore code colouring\n77503979 Working on docs (#1828)\n3c805e1a Make anchor tweaking stricter\na6ae3ca4 use_tidy_description()\nd43260fb Tweak authors order\n41c855df Tweak details styling\n7d3c484c Anchor & news tweaks (#1830)\n¿Cual prefieres?",
    "crumbs": [
      "Instalación",
      "<span class='chapter-number'>8</span>  <span class='chapter-title'>Instalar un cliente Git</span>"
    ]
  },
  {
    "objectID": "install-git-client.html#nadie-está-entregando-insignias-de-mérito-de-git-nerd",
    "href": "install-git-client.html#nadie-está-entregando-insignias-de-mérito-de-git-nerd",
    "title": "8  Instalar un cliente Git",
    "section": "8.3 Nadie está entregando insignias de mérito de Git Nerd",
    "text": "8.3 Nadie está entregando insignias de mérito de Git Nerd\nTrabaja con Git de la forma que te haga más eficaz. Siéntase libre de revisar su enfoque con el tiempo o de utilizar diferentes enfoques para diferentes tareas o en diferentes entornos. Nadie puede saber si usa la línea de comando o una GUI cuando miran su historial de Git o su repositorio de GitHub.\nA veces me encuentro con personas que sienten que es “mejor” usar la línea de comandos de Git, pero por razones muy mal definidas. Estas personas pueden sentir que deberían trabajar en el shell, incluso si eso les lleva a evitar Git, cometer errores frecuentes o limitarse a un pequeño conjunto de ~3 comandos de Git. Esto es contraproducente.\nTuve dos comienzos en falso con Git, en los que no logré dominar lo suficiente ni lo suficientemente rápido como para incorporar realmente el control de versiones en mi trabajo diario. Encontré un cliente visual de Git invaluable. Me hizo querer usar Git varias veces al día, durante un período de tiempo prolongado. Esto me ayudó a construir el modelo mental necesario para operaciones de Git más avanzadas, como cambiar la base, seleccionar y restablecer.\nSi tu vida con Git ocurre en tu propia computadora, no hay razón para negarte una GUI si eso es lo que te gusta. Si prefiere trabajar en el shell o si inicia sesión con frecuencia en un servidor remoto, entonces tiene sentido priorizar el desarrollo de habilidades de Git en la línea de comandos. Haz lo que funcione para ti, pero no hagas nada por el bien de la pureza o el heroísmo.",
    "crumbs": [
      "Instalación",
      "<span class='chapter-number'>8</span>  <span class='chapter-title'>Instalar un cliente Git</span>"
    ]
  },
  {
    "objectID": "install-git-client.html#clientes-git-recomendados",
    "href": "install-git-client.html#clientes-git-recomendados",
    "title": "8  Instalar un cliente Git",
    "section": "8.4 Clientes Git recomendados",
    "text": "8.4 Clientes Git recomendados\n\nGitKraken es un potente y gratuito cliente Git(Hub) que es mi favorito actualmente. Es especialmente interesante porque funciona en Windows, macOS y Linux. Esta es una gran noticia, especialmente para los sufridos usuarios de Linux que antes tenían muy pocas opciones. Utilicé la versión gratuita durante años, que funciona muy bien, pero ahora pago felizmente por la versión pro.\nSourceTree es otro cliente gratuito que solía recomendar encarecidamente. Fue mi primer cliente Git querido, pero finalmente tuve que abandonarlo debido a errores/deficiencias de larga data que parecían que nunca se solucionarían (error de macOS con respecto a identificadores de archivos filtrados, sin posibilidad de controlar el tamaño de fuente). GitKraken se siente mucho más desarrollado activamente y para mí ha suplantado por completo a SourceTree.\nGitHub ofrece un cliente Git(Hub) gratuito, GitHub Desktop, para Windows y macOS. Aunque anteriormente desalentamos su uso, desde entonces el cliente de GitHub ha recibido una renovación completa que elimina varias de nuestras preocupaciones, por lo que somos cautelosamente optimistas. GitHub Desktop está dirigido a principiantes que desean las funciones más útiles de Git al frente y al centro. La otra cara es que es posible que no admita algunos de los flujos de trabajo más avanzados expuestos por los clientes anteriores y, en consecuencia, es posible que no desarrolle su modelo mental de Git tan a fondo.\nExplorar aún más clientes Git(Hub).",
    "crumbs": [
      "Instalación",
      "<span class='chapter-number'>8</span>  <span class='chapter-title'>Instalar un cliente Git</span>"
    ]
  },
  {
    "objectID": "install-git-client.html#footnotes",
    "href": "install-git-client.html#footnotes",
    "title": "8  Instalar un cliente Git",
    "section": "",
    "text": "Esta evocadora frase apareció originalmente en una publicación de blog de Philip Guo, que posteriormente fue eliminada de Internet.↩︎",
    "crumbs": [
      "Instalación",
      "<span class='chapter-number'>8</span>  <span class='chapter-title'>Instalar un cliente Git</span>"
    ]
  },
  {
    "objectID": "connect-intro.html",
    "href": "connect-intro.html",
    "title": "¿Puedes escucharme ahora?",
    "section": "",
    "text": "Los siguientes capítulos repasan algunas operaciones básicas para confirmar que ha instalado el software necesario y que se están realizando las conexiones necesarias, entre las herramientas de su computadora y entre su computadora y GitHub.\nEsto se superpone mucho con algunos flujos de trabajo básicos que revisaremos más adelante, pero la segunda vez (o en un taller en vivo), dedicaremos más tiempo a explicar qué está sucediendo y por qué.\nDesafortunadamente, tenemos que adelantar una tarea bastante complicada, que es decidir si comunicarnos con GitHub a través de HTTPS o SSH y configurar algunas credenciales en consecuencia. En Token de acceso personal para HTTPS analizamos cómo elegir entre HTTPS y SSH y luego explicamos cómo obtener un token de acceso personal, que se usa con HTTPS. O, alternativamente, te ayudaremos a Configurar claves para SSH.\nUna vez que tenemos nuestras credenciales ordenadas, en Conectar a GitHub, usamos Git en el shell para asegurarnos de que pueda clonar un repositorio desde GitHub y establecer comunicaciones bidireccionales, es decir, importar y enviar.\nEn Conectar RStudio a Git y GitHub confirmamos que RStudio puede trabajar con su instalación de Git para realizar operaciones locales y comunicarse con GitHub.\nEsperemos que no lo necesites, pero esta parte concluye con dos capítulos de solución de problemas: Detectar Git desde RStudio y RStudio, Git, GitHub Hell.",
    "crumbs": [
      "Conectar Git, GitHub, RStudio",
      "¿Puedes escucharme ahora?"
    ]
  },
  {
    "objectID": "connect-https-pat.html",
    "href": "connect-https-pat.html",
    "title": "9  Token de acceso personal para HTTPS",
    "section": "",
    "text": "9.1 TL;DR\nCuando interactuamos con un servidor Git remoto, como GitHub, debemos incluir credenciales en la solicitud. Esto demuestra que somos un usuario específico de GitHub, al que se le permite hacer cualquier cosa que le pidamos.\nGit puede comunicarse con un servidor remoto utilizando uno de dos protocolos, HTTPS o SSH, y los diferentes protocolos utilizan diferentes credenciales.\nAquí describimos la configuración de credenciales para el protocolo HTTPS, que es lo que recomendamos si no tiene ningún motivo importante para elegir SSH. Con HTTPS, usaremos un token de acceso personal (PAT). Dirígete al capítulo Capítulo 10 si realmente quieres configurar claves SSH.\nTenga en cuenta que la contraseña que utiliza para iniciar sesión en el sitio web de GitHub NO es una credencial aceptable cuando se habla con GitHub como servidor Git. Esto fue posible en el pasado (y puede que aún sea cierto para otros servidores Git), pero esos días quedaron atrás en GitHub. Puede obtener más información en la publicación de su blog Requisitos de autenticación de tokens para operaciones de Git.\nEste es el error que verá si intenta hacer eso ahora:\nLa recomendación de utilizar un token de acceso personal (PAT) es exactamente lo que cubrimos en este capítulo.\nEsta es una descripción mínima de cómo obtener y almacenar un PAT. Esto podría ser todo lo que necesita cuando se esté configurando por primera vez. Siempre puedes volver más tarde y leer otras partes de este capítulo.\nVaya a https://github.com/settings/tokens y haga clic en “Generar token”.\nO, desde R, ejecute:\nusethis::create_github_token()\nMire los ámbitos; Recomiendo encarecidamente seleccionar “repo”, “user” y “workflow”. Los alcances recomendados serán preseleccionados si utilizó create_github_token().\nHaga click en “Generar token”.\nCCopie el PAT generado a su portapapeles. O deje la ventana del navegador abierta y disponible por un momento, para que pueda volver a copiar el PAT.\nProporcione esta PAT la próxima vez que una operación de Git solicite su contraseña1.\nIncluso podrías adelantarte a esto y almacenar el PAT explícitamente ahora mismo. En R, llame gitcreds::gitcreds_set() para recibir un mensaje donde puedes pegar tu PAT:\n&gt; gitcreds::gitcreds_set()\nPegue el PAT en respuesta al diálogo en la consola:\nDebería poder trabajar con GitHub ahora. Si todavía estás realizando la configuración inicial, ahora es un buen momento para pasar a Conectarse a GitHub.\nContinúe leyendo para obtener más información sobre:",
    "crumbs": [
      "Conectar Git, GitHub, RStudio",
      "<span class='chapter-number'>9</span>  <span class='chapter-title'>Token de acceso personal para HTTPS</span>"
    ]
  },
  {
    "objectID": "connect-https-pat.html#tldr",
    "href": "connect-https-pat.html#tldr",
    "title": "9  Token de acceso personal para HTTPS",
    "section": "",
    "text": "? Enter password or token: ghp_xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx\n-&gt; Adding new credentials...\n-&gt; Removing credentials from cache...\n-&gt; Done.\n\n\n\nCómo decidir entre los protocolos HTTPS y SSH\nAlcances, nombres y caducidad de PAT\nGuarde su PATT\nSolución de problemas",
    "crumbs": [
      "Conectar Git, GitHub, RStudio",
      "<span class='chapter-number'>9</span>  <span class='chapter-title'>Token de acceso personal para HTTPS</span>"
    ]
  },
  {
    "objectID": "connect-https-pat.html#sec-https-vs-ssh",
    "href": "connect-https-pat.html#sec-https-vs-ssh",
    "title": "9  Token de acceso personal para HTTPS",
    "section": "\n9.2 HTTPS contra SSH",
    "text": "9.2 HTTPS contra SSH\nEncuentro que HTTPS es más fácil de hacer funcionar rápidamente y lo recomiendo encarecidamente cuando comienzas a trabajar con Git/GitHub. HTTPS es lo que recomienda GitHub, presumiblemente exactamente por las mismas razones. El argumento de la “facilidad de uso” a favor de HTTPS es especialmente cierto para los usuarios de Windows. Comencé con HTTPS, preferí SSH por un tiempo y volví a HTTPS. Lo principal que debe saber es que esta no es una decisión de todo o nada y es una decisión relativamente fácil de revisar más adelante.\nOtra ventaja de HTTPS es que el PAT que configuraremos también se puede usar con la API REST de GitHub. Puede que eso no signifique nada para usted (todavía), pero hay muchos paquetes R que llaman a la API de GitHub en su nombre (devtools+usethis, remotes, pak, gh, etc.). Configurar su PAT mata dos pájaros de un tiro: esta credencial única se puede usar para autenticarse en GitHub como un servidor Git normal y para su API REST. Si se autentica a través de SSH para el trabajo “normal” de Git, aún tendrá que configurar un PAT para el trabajo que utiliza la API REST.\n\n\n\n\nUn PAT configurada correctamente significa que todo esto “simplemente funcionará”:\n\nOperaciones HTTPS remotas a través de la línea de comandos de Git y, por tanto, a través de RStudio\nOperaciones HTTPS remotas a través del paquete gert R y, por lo tanto, usethis\nOperaciones de API de GitHub a través del paquete gh R y, por lo tanto, usethis\n\n\n9.2.1 La URL determina el protocolo\nAunque sugiero que adoptes HTTPS como estilo de vida, es bueno saber que en realidad tienes un control muy granular sobre el protocolo. Está determinado por la URL utilizada para acceder a un repositorio remoto. No dudes en saltarte esta sección si eres nuevo en Git (mencionamos algunos conceptos y comandos que no tendrán mucho sentido hasta que hayas usado un poco Git).\nLas URL remotas HTTPS se ven así https://github.com/&lt;OWNER&gt;/&lt;REPO&gt;.git.\nLas URL remotas SSH se ven así git@github.com:&lt;OWNER&gt;/&lt;REPO&gt;.git.\n\n\n\n\n\n\n\n\n\n\nCuando ejecutas un comando como git push origin my-cool-feature-branch, Git busca la URL que has almacenado para el control remoto origin y usa el protocolo implícito en el formato de la URL. El protocolo es una decisión en el momento del juego.\nEsto implica que:\n\nEstá bien usar HTTPS para un control remoto en un repositorio y SSH para otro.\n\nEstá bien usar HTTPS en un repositorio y SSH en otro.\n\nEstá bien interactuar con un repositorio de GitHub mediante HTTPS desde una computadora y mediante SSH desde otra.\n\nEstá bien adoptar HTTPS para trabajos nuevos, incluso si algunos de sus repositorios preexistentes usan SSH.\n\nSólo debes tener en cuenta que el uso mixto de HTTPS y SSH significa que tendrás que configurar ambos tipos de credenciales.\nCambiar un control remoto específico de HTTPS a SSH (y viceversa) es una operación sencilla con git remote set-url REMOTE_NAME DESIRED_URL:\n~/rrr/happy-git-with-r % git remote -v\norigin  https://github.com/jennybc/happy-git-with-r.git (fetch)\norigin  https://github.com/jennybc/happy-git-with-r.git (push)\n\n~/rrr/happy-git-with-r % git remote set-url origin git@github.com:jennybc/happy-git-with-r.git\n\n~/rrr/happy-git-with-r % git remote -v\norigin  git@github.com:jennybc/happy-git-with-r.git (fetch)\norigin  git@github.com:jennybc/happy-git-with-r.git (push)\n\n~/rrr/happy-git-with-r % git remote set-url origin https://github.com/jennybc/happy-git-with-r.git\nPodemos hacer lo mismo desde R usando las funciones de usethis:\n\nusethis::git_remotes()\n#&gt; $origin\n#&gt; [1] \"https://github.com/jennybc/happy-git-with-r.git\"\n\nusethis::use_git_remote(\n  \"origin\",\n  \"git@github.com:jennybc/happy-git-with-r.git\",\n  overwrite = TRUE\n)\n\nusethis::git_remotes()\n#&gt; $origin\n#&gt; [1] \"git@github.com:jennybc/happy-git-with-r.git\"\n\nusethis::use_git_remote(\n  \"origin\",\n  \"https://github.com/jennybc/happy-git-with-r.git\",\n  overwrite = TRUE\n)",
    "crumbs": [
      "Conectar Git, GitHub, RStudio",
      "<span class='chapter-number'>9</span>  <span class='chapter-title'>Token de acceso personal para HTTPS</span>"
    ]
  },
  {
    "objectID": "connect-https-pat.html#sec-get-a-pat",
    "href": "connect-https-pat.html#sec-get-a-pat",
    "title": "9  Token de acceso personal para HTTPS",
    "section": "\n9.3 Generar un token de acceso personal (PAT)",
    "text": "9.3 Generar un token de acceso personal (PAT)\nEn github.com, suponiendo que haya iniciado sesión, puede administrar sus tokens de acceso personales desde https://github.com/settings/tokens, también accesible a través de Configuración &gt; Configuración de desarrollador &gt; Tokens de acceso personal. Puedes hacer clic en “Generar nuevo token” aquí o, quizás incluso mejor, puedes ejecutar en R el siguiente código usethis::create_github_token():\n\nusethis::create_github_token()\n\nEl usethis enfoque lo lleva a un formulario precargado donde hemos preseleccionado algunos alcances recomendados, que puede revisar y ajustar antes de hacer clic en “Generar token”. Al momento de escribir este artículo, los alcances recomendados por este uso son “repo”, “user”, “gist” y “workflow”.\n\n\n\n\nEs una muy buena idea describir el propósito del token en el campo Note, porque algún día podría tener varios PAT. Recomendamos nombrar cada token según su caso de uso, como la computadora o el proyecto para el que lo está usando, por ejemplo. “personal-macbook-air” o “vm-for-project-xyz”. En el futuro, te encontrarás mirando esta lista de tokens, porque inevitablemente necesitarás volver a generar o eliminar uno de ellos. Haz que sea fácil descubrir con qué token has venido a jugar.\nGitHub fomenta el uso de tokens perecederos, con un período de Caducidad predeterminado de 30 días. A menos que tenga una razón específica para luchar contra esto, le recomiendo aceptar este valor predeterminado. Supongo que la gente de seguridad de GitHub tiene buenas razones para su recomendación. Pero, por supuesto, puede ajustar el comportamiento de Vencimiento como mejor le parezca, incluido “Sin vencimiento”.\nUna vez que esté satisfecho con la Note, Expiration y Scope del token, haga clic en “Generar token”.\nNo podrá volver a ver este token, así que no cierre ni salga de esta ventana del navegador hasta que almacene el PAT localmente. Copie el PAT al portapapeles, anticipando lo que haremos a continuación: activar un mensaje que nos permita almacenar el PAT en el almacén de credenciales de Git.\n¡Trate este PAT como una contraseña! ¡Nunca conectes tu PAT a tu código! Una PAT siempre debe recuperarse implícitamente, por ejemplo, del almacén de credenciales de Git. Estamos a punto de ayudarle a almacenar el PAT en un lugar seguro, donde los paquetes de línea de comandos Git, RStudio y R puedan descubrirlo.\nSi usa una aplicación de administración de contraseñas, como 1Password (¡muy recomendable!), es posible que desee agregar también esta PAT (y su Nota) a la entrada de GitHub, donde ya está almacenando su nombre de usuario y contraseña. Almacenar su PAT en el almacén de credenciales de Git es una conveniencia semipersistente, algo así como un caché del navegador o “recordarme” en un sitio web2 y es posible que necesite volver a ingresar su PAT en el futuro. Podrías decidir aceptar la impermanencia de tu PAT y, si de alguna manera se pierde, simplemente regenerarás el PAT y lo restaurarás. Si acepta el período de vencimiento predeterminado de 30 días, este es un flujo de trabajo que utilizará con frecuencia de todos modos. Pero si crea tokens duraderos o quiere jugar con las funciones para configurar o borrar sus credenciales de Git, puede resultar útil tener su propio registro de su PAT en un lugar seguro, como 1Password.",
    "crumbs": [
      "Conectar Git, GitHub, RStudio",
      "<span class='chapter-number'>9</span>  <span class='chapter-title'>Token de acceso personal para HTTPS</span>"
    ]
  },
  {
    "objectID": "connect-https-pat.html#sec-store-pat",
    "href": "connect-https-pat.html#sec-store-pat",
    "title": "9  Token de acceso personal para HTTPS",
    "section": "\n9.4 Guarde su PAT",
    "text": "9.4 Guarde su PAT\nEn este punto, asumo que generó una PAT y la tiene disponible, en una o ambas de estas maneras:\n\nEn un sistema seguro y a largo plazo para almacenar secretos, como 1Password\nDurante los próximos minutos, en una ventana del navegador o en el portapapeles\n\nHay un par de formas de ingresar su PAT en la tienda de credenciales de Git:\n\nLlame a una función de R para almacenar (o actualizar) explícitamente sus credenciales.\nHaga algo en la línea de comando de Git o RStudio que desencadene un desafío de credenciales.\n\n\n9.4.1 Llame a una función R para almacenar sus credenciales\nHay dos paquetes de R para acceder al almacén de credenciales de Git:\n\ngitcreds\ncredentials\n\nEs probable que estos paquetes eventualmente se combinen en uno solo e, incluso ahora, son en gran medida interoperables. No es necesario que sigas las instrucciones de ambos paquetes: ¡elige uno!\n\n9.4.1.1 Paquete gitcreds\nSi no tiene gitcreds instalado, instálelo a través de install.packages(\"gitcreds\"). Si ha instalado usethis, ya tendrá gitcreds, porque usethis usa gh y gh usa gitcreds.\nLlame a gitcreds::gitcreds_set(). Si aún no tiene una PAT almacenada, se le pedirá que la ingrese. ¡Pegar!\n\n&gt; gitcreds::gitcreds_set()\n\n? Enter password or token: ghp_xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx\n-&gt; Adding new credentials...\n-&gt; Removing credentials from cache...\n-&gt; Done.\n\nSi ya tiene una credencial almacenada, gitcreds::gitcreds_set() la revela e incluso le permitirá inspeccionarla. Esto le ayuda a decidir si desea conservar la credencial existente o reemplazarla. En caso de duda, opte por una credencial nueva y de buena reputación en lugar de una antigua de origen dudoso.\n\n&gt; gitcreds::gitcreds_set()\n\n-&gt; Your current credentials for 'https://github.com':\n\n  protocol: https\n  host    : github.com\n  username: PersonalAccessToken\n  password: &lt;-- hidden --&gt;\n\n-&gt; What would you like to do? \n\n1: Keep these credentials\n2: Replace these credentials\n3: See the password / token\n\nSelection: 2\n\n-&gt; Removing current credentials...\n\n? Enter new password or token: ghp_xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx\n-&gt; Adding new credentials...\n-&gt; Removing credentials from cache...\n-&gt; Done.\n\nPuede comprobar que ha almacenado una credencial con gitcreds_get():\n\ngitcreds_get()\n#&gt; &lt;gitcreds&gt;\n#&gt;   protocol: https\n#&gt;   host    : github.com\n#&gt;   username: PersonalAccessToken\n#&gt;   password: &lt;-- hidden --&gt;\n\nOtras funciones que pueden ayudarle a sentirse seguro acerca de su configuración PAT incluyen:\n\nusethis::gh_token_help()\n\nusethis::git_sitrep()\n\ngh::gh_whoami()\n\n\n9.4.1.2 Paquete credentials\nSi no tiene las credenciales instaladas, instálelas a través de install.packages(\"credentials\"). Si ha instalado usethis, ya tendrá credenciales, porque usethis usa gert y gert usa credenciales.\nLlame a set_github_pat(). Si aún no tiene una PAT almacenada, se le pedirá que la ingrese. ¡Pegar!\n\ncredentials::set_github_pat()\n\nSi tiene éxito, sus llamadas iniciales (y posteriores) se verán así:\n\ncredentials::set_github_pat()\n#&gt; If prompted for GitHub credentials, enter your PAT in the password field\n#&gt; Using GITHUB_PAT from Jennifer (Jenny) Bryan (credential helper: osxkeychain)\n\nOtras funciones que pueden ayudarle a sentirse seguro acerca de su configuración PAT incluyen:\n\nusethis::gh_token_help()\n\nusethis::git_sitrep()\n\ngh::gh_whoami()\n\n\n9.4.2 Almacene credenciales mediante el uso orgánico de Git\nAntes de que existieran gitcreds y credenciales (ver arriba), teníamos que orquestar un desafío de credenciales configurando (y luego derribando) un repositorio de juguetes. Esto todavía ocurre naturalmente en el ejercicio guiado en Conectarse a GitHub. Pero recomiendo encarecidamente administrar su PAT de manera más directa y explícita con gitcreds::gitcreds_set() y funciones relacionadas en gitcreds.",
    "crumbs": [
      "Conectar Git, GitHub, RStudio",
      "<span class='chapter-number'>9</span>  <span class='chapter-title'>Token de acceso personal para HTTPS</span>"
    ]
  },
  {
    "objectID": "connect-https-pat.html#sec-pat-troubleshooting",
    "href": "connect-https-pat.html#sec-pat-troubleshooting",
    "title": "9  Token de acceso personal para HTTPS",
    "section": "\n9.5 Problemas y soluciones de HTTPS PAT",
    "text": "9.5 Problemas y soluciones de HTTPS PAT\nEsta sección es para personas que necesitan saber aún más sobre la administración de PAT porque se encuentran en una situación no estándar o sobre la resolución de problemas.\n\n9.5.1 Se almacena el PAT válido, pero luego se le dice que el PAT no es válido\nSupongamos que genera un PAT nuevo y lo almacena correctamente como se describe anteriormente. Quizás incluso lo uses con éxito. ¡Pero luego te dicen que tu PAT no es válido! ¿Cómo puede ser esto?\nAquí hay algunas explicaciones probables:\n\nSu PAT realmente no es válido. De forma predeterminada, los PAT ahora tienen una fecha de vencimiento. Un día realmente te despertarás y descubrirás que el PAT se ha estropeado durante la noche y necesitas volver a generarlo y almacenarlo.\nTienes un PAT no válido almacenado en otro lugar, que has olvidado, probablemente en .Renviron. Esta PAT antiguo e inválido impide que los paquetes R incluso descubran su PAT nuevo y válido.\n\n\n9.5.1.1 PAT ha expirado\nVas a regenerar y restaurar tu PAT según un cronograma dictado por su período de vencimiento. Por defecto, una vez al mes.\nCuando el PAT caduque, regrese a https://github.com/settings/tokens y haga clic en su Nota. (Etiquetas muy bien tus tokens por caso de uso, ¿verdad? ¿Verdad?) En este punto, opcionalmente puedes ajustar los alcances y luego hacer clic en “Regenerar token”. Opcionalmente, puedes modificar su Caducidad y luego hacer clic en “Regenerar token” (nuevamente). Como antes, copie el PAT al portapapeles, llame a gitcreds::gitcreds_set() y péguelo.\nCon suerte, cada vez está más claro por qué la Nota de cada token es tan importante. El token real puede cambiar, por ejemplo, una vez al mes, pero su caso de uso (y alcances) son mucho más persistentes y estables.\n\n9.5.1.2 GITHUB_PAT antiguo en .Renviron\n\nEstas funciones de usethis diagnosticarán este problema:\n\nusethis::gh_token_help()\n\nusethis::git_sitrep()\n\nEn el pasado, era común almacenar un PAT como la variable de entorno GITHUB_PAT en .Renviron. Pero ahora, gracias a gitcreds y credenciales, podemos almacenar y recuperar un PAT, desde R, de la misma manera que lo hace la línea de comandos Git.\nSi tiene alguna duda sobre sus prácticas anteriores, abra .Renviron, busque una línea que configure la variable de entorno GITHUB_PAT y elimínela. usethis::edit_r_environ() puede ser útil para abrir .Renviron para editarlo. No olvide reiniciar R para que este cambio surta efecto.\n\n9.5.2 PAT no persiste en macOS o Windows\nLos asistentes de credenciales utilizados por Git aprovechan los almacenes de credenciales oficiales proporcionados por el sistema operativo, siempre que sea posible, como macOS Keychain y Windows Credential Manager.\nSi está intentando seguir los consejos aquí y su PAT nunca persiste, considere que es posible que necesite actualizar Git para obtener sus asistentes de credenciales más modernos. Esta es absolutamente un área de Git que ha mejorado rápidamente en los últimos años y el paquete gitcreds y credentials funcionan mejor con las versiones recientes de Git. No he necesitado activar explícitamente un asistente de credenciales en macOS o Windows con ninguna versión reciente de Git.\nAquí hay un comando para revelar el asistente de credenciales actual y lo que veo estos días.\nmacOS\n$ git config --show-origin --get credential.helper\nfile:/Users/jenny/.gitconfig    osxkeychain\nWindows\n$ git config --show-origin --get credential.helper\nfile:C:/Program Files/Git/mingw64/etc/gitconfig manager\nSi desea saber más sobre cómo gitcreds y credenciales administran su PAT, obtenga información sobre git credential &lt;fill|approve|reject&gt;. Para los entusiastas, esa documentación les brinda detalles sobre cómo se almacenan y recuperan las credenciales:\n\nGit tiene una interfaz interna para almacenar y recuperar credenciales de ayudantes específicos del sistema, además de solicitar al usuario nombres de usuario y contraseñas. El comando git-credential expone esta interfaz a scripts que pueden querer recuperar, almacenar o solicitar credenciales de la misma manera que Git.\n\nEn Windows, sus credenciales de Git probablemente se almacenen a través del Administrador de credenciales.\nEn macOS, sus credenciales de Git probablemente estén almacenadas en el Keychain.\nSi realmente desea husmear directamente para explorar o limpiar sus credenciales de GitHub, inicie Credential Manager (Windows) o Keychain Access (macOS) y busque “github.com”.\n\n9.5.3 PAT no persiste en Linux\nLos asistentes de credenciales utilizados por Git aprovechan los almacenes de credenciales oficiales proporcionados por el sistema operativo en macOS y Windows, pero lamentablemente no existe un equivalente exacto en Linux.\nLo más fácil es configurar Git para “almacenar en caché” sus credenciales (frente a “almacenar”), que tiene un tiempo más limitado. Luego establezca el tiempo de espera de la caché en un período de tiempo suficientemente largo. Aquí fijamos el tiempo de espera en diez millones de segundos o alrededor de 16 semanas, suficiente para un semestre.\ngit config --global credential.helper 'cache --timeout=10000000'\nEs posible que esto aún no haga que su PAT esté disponible para los paquetes R. En este caso, es posible que necesite utilizar el método más antiguo y menos seguro de almacenar su PAT en .Renviron. usethis::edit_r_environ() abre ese archivo para editarlo.\n\nusethis::edit_r_environ()\n\nAgrega una línea como esta, pero sustituye tu PAT:\n\nGITHUB_PAT=ghp_xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx\n\n¡Asegúrese de que este archivo termine en una nueva línea! La falta de una nueva línea puede provocar una falla silenciosa al cargar los archivos de inicio, lo que puede ser complicado de depurar. Tenga cuidado de que este archivo no se envíe accidentalmente a la nube, p. Google Drive o GitHub.\nReinicie R para que los cambios en .Renviron surtan efecto.",
    "crumbs": [
      "Conectar Git, GitHub, RStudio",
      "<span class='chapter-number'>9</span>  <span class='chapter-title'>Token de acceso personal para HTTPS</span>"
    ]
  },
  {
    "objectID": "connect-https-pat.html#footnotes",
    "href": "connect-https-pat.html#footnotes",
    "title": "9  Token de acceso personal para HTTPS",
    "section": "",
    "text": "Sí, es confuso que se le solicite una contraseña, pero debe ingresar su PAT. GitHub ya no permite contraseñas en este contexto, pero la mayoría de las herramientas básicas de Git aún enmarcan la tarea de autenticación con este lenguaje.↩︎\n¡Ja ja! Todos sabemos lo bien que funciona “recuérdame”.↩︎",
    "crumbs": [
      "Conectar Git, GitHub, RStudio",
      "<span class='chapter-number'>9</span>  <span class='chapter-title'>Token de acceso personal para HTTPS</span>"
    ]
  },
  {
    "objectID": "connect-ssh-keys.html",
    "href": "connect-ssh-keys.html",
    "title": "10  Configurar claves para SSH",
    "section": "",
    "text": "10.1 Claves SSH\nCuando interactuamos con un servidor Git remoto, como GitHub, debemos incluir credenciales en la solicitud. Esto demuestra que somos un usuario específico de GitHub, al que se le permite hacer cualquier cosa que le pidamos.\nGit puede comunicarse con un servidor remoto utilizando uno de dos protocolos, HTTPS o SSH, y los diferentes protocolos utilizan diferentes credenciales.\nAquí describimos la configuración de credenciales para el protocolo SSH. Si no está seguro de utilizar HTTPS o SSH, lea HTTPS versus SSH. De ahora en adelante, asumimos que ha elegido intencionalmente configurar claves SSH.\nLas claves SSH proporcionan una forma más segura de iniciar sesión en un servidor que usar únicamente una contraseña. Si bien una contraseña puede eventualmente descifrarse con un ataque de fuerza bruta, las claves SSH son casi imposibles de descifrar solo con fuerza bruta. La generación de un par de claves le proporciona dos largas cadenas de caracteres: una clave pública y una privada. Puede colocar la clave pública en cualquier servidor (¡como GitHub!) y luego desbloquearla conectándose con un cliente que ya tenga la clave privada (¡su computadora!). Cuando los dos coinciden, el sistema se desbloquea sin necesidad de contraseña. Puede aumentar aún más la seguridad protegiendo la clave privada con una frase de contraseña.\nAdaptado de las instrucciones proporcionadas por GitHub y Digital Ocean.",
    "crumbs": [
      "Conectar Git, GitHub, RStudio",
      "<span class='chapter-number'>10</span>  <span class='chapter-title'>Configurar claves para SSH</span>"
    ]
  },
  {
    "objectID": "connect-ssh-keys.html#ssh-esquema-y-consejo",
    "href": "connect-ssh-keys.html#ssh-esquema-y-consejo",
    "title": "10  Configurar claves para SSH",
    "section": "\n10.2 SSH esquema y consejo",
    "text": "10.2 SSH esquema y consejo\nDescripción general de alto nivel de lo que debe suceder:\n\nCree un par de claves SSH pública-privada. Literalmente, 2 archivos especiales, en un lugar especial. Opcionalmente, cifre la clave privada con una frase de contraseña (práctica recomendada).\nAgregue la clave privada a su agente ssh. Si lo protegiste con una frase de contraseña, es posible que tengas una configuración adicional.\nAgrega tu clave pública a tu perfil de GitHub.\n\nConsejo:\n\nSi es nuevo en la programación y el shell, probablemente le resulte más fácil HTTPS al principio (Capítulo 9). Siempre puedes cambiar a SSH más tarde. Puede utilizar un método desde la computadora A y el otro desde la computadora B.\nDebes cambiar tus claves SSH periódicamente. Algo así como una vez al año.\nEs una buena práctica proteger su clave privada con una frase de contraseña. Esto puede dificultar la configuración y el uso, por lo que si no estás preparado para ello (todavía), no uses una frase de contraseña o considera seriamente usar HTTPS en su lugar.\nNo hagas ejercicios extraños para tener un solo par de claves, reutilizadas en varias computadoras. Probablemente deberías tener una clave por computadora (yo hago esto). Algunas personas incluso tienen una clave por computadora, por servicio (yo no hago esto).\nEs normal asociar varias claves públicas con tu cuenta de GitHub. Por ejemplo, una clave pública para cada computadora a la que se conecte.",
    "crumbs": [
      "Conectar Git, GitHub, RStudio",
      "<span class='chapter-number'>10</span>  <span class='chapter-title'>Configurar claves para SSH</span>"
    ]
  },
  {
    "objectID": "connect-ssh-keys.html#ya-tienes-claves",
    "href": "connect-ssh-keys.html#ya-tienes-claves",
    "title": "10  Configurar claves para SSH",
    "section": "\n10.3 ¿Ya tienes claves?",
    "text": "10.3 ¿Ya tienes claves?\nPuede comprobar esto desde RStudio o desde el shell.\nConsejo global: si tiene claves existentes, pero no tiene idea de dónde provienen o por qué las creó, debería considerar seriamente la posibilidad de crear un nuevo par de claves SSH. Depende de usted decidir si eliminar las antiguas y cómo hacerlo. Pero no permita que eso le impida crear nuevas claves y seguir adelante.\n\n10.3.1 Desde RStudio\nVaya a Tools &gt; Global Options…&gt; Git/SVN. Si ve algo como ~/.ssh/id_rsa en el cuadro Clave SSH RSA, definitivamente tiene claves existentes.\nAdvertencia: RStudio solo busca un par de claves llamado id_rsa e id_rsa.pub. Esto tiene sentido, porque históricamente ha sido lo más común.\nSin embargo, hoy en día tanto GitHub como GitLab alientan a los usuarios a generar claves SSH con el algoritmo Ed25519, lo que da como resultado un par de claves llamado id_ed25519 e id_ed25519.pub. En el momento de escribir este artículo, RStudio no mostrará dicho par de claves, lo que puede resultar confuso. Por lo tanto, probablemente sea una buena idea comprobar también las claves existentes en el shell.\n\n10.3.2 Desde el shell\nVaya al shell (Apéndice A).\nListe las claves existentes:\nls -al ~/.ssh/\nSi le dicen que ~/.ssh/ no existe, ¡no tiene claves SSH!\nSi ve un par de archivos como id_rsa.pub e id_rsa o id_ed25519 y id_ed25519.pub, ya tiene un par de claves. El patrón típico es id_FOO.pub (la clave pública) e id_FOO (la clave privada), donde FOO refleja el tipo de clave. Si está satisfecho con seguir con sus claves existentes, salte a las secciones sobre cómo agregar una clave al ssh-agent y GitHub.",
    "crumbs": [
      "Conectar Git, GitHub, RStudio",
      "<span class='chapter-number'>10</span>  <span class='chapter-title'>Configurar claves para SSH</span>"
    ]
  },
  {
    "objectID": "connect-ssh-keys.html#crear-un-par-de-claves-ssh",
    "href": "connect-ssh-keys.html#crear-un-par-de-claves-ssh",
    "title": "10  Configurar claves para SSH",
    "section": "\n10.4 Crear un par de claves SSH",
    "text": "10.4 Crear un par de claves SSH\n\n10.4.1 Opción 1: configurar desde RStudio\nVaya a Tools &gt; Global Options…&gt; Git/SVN &gt; Create SSH Key….\nRStudio le solicita una frase de contraseña. Es opcional, pero también una buena práctica. Configurar su sistema para un funcionamiento fluido con una clave protegida con contraseña introduce más partes móviles. Si es completamente nuevo en esto, omita la frase de contraseña (¡o use HTTPS!) e impleméntela la próxima vez, cuando se sienta más cómodo con la configuración del sistema. Al principio no usaba una frase de contraseña, pero ahora la uso y la registro en un administrador de contraseñas.\nHaga clic en “Crear” y RStudio generará un par de claves SSH, almacenadas en los archivos ~/.ssh/id_rsa y ~/.ssh/id_rsa.pub.\nTenga en cuenta que actualmente RStudio solo genera claves RSA, mientras que la recomendación estándar de GitHub y GitLab es utilizar claves Ed25519. Si desea seguir ese consejo, genere sus claves en el shell por ahora.\n\n10.4.2 Opción 2: configurar desde el shell\nCree el par de claves así, pero sustitúyalo por un comentario que signifique algo para usted, especialmente si tendrá varias claves SSH en su vida. Considere el correo electrónico asociado con su cuenta de GitHub o el nombre de su computadora o alguna combinación, p.e. your_email@example.com or macbook-pro or jane-2020-macbook-pro.\nssh-keygen -t ed25519 -C \"DESCRIPTIVE-COMMENT\"\nSi parece que su sistema es demasiado antiguo para admitir el algoritmo Ed25519, haga lo siguiente:\nssh-keygen -t rsa -b 4096 -C \"DESCRIPTIVE-COMMENT\"\nAcepte la propuesta de guardar la clave en la ubicación predeterminada. Simplemente presione Enter aquí:\nEnter file in which to save the key (/Users/jenny/.ssh/id_ed25519):\nTiene la opción de proteger la clave con una frase de contraseña. Es opcional, pero también una buena práctica. Configurar su sistema para un funcionamiento fluido con una clave protegida con contraseña introduce más partes móviles. Si es completamente nuevo en esto, omita la frase de contraseña e impleméntela la próxima vez, cuando se sienta más cómodo con la configuración del sistema. Al principio no usaba una frase de contraseña, pero ahora la uso y la registro en un administrador de contraseñas.\nEnter passphrase (empty for no passphrase):\nEnter same passphrase again: \nEl proceso debería completarse ahora y debería haberse visto así:\n~ % ssh-keygen -t ed25519 -C \"jenny-2020-mbp\"        \nGenerating public/private ed25519 key pair.\nEnter file in which to save the key (/Users/jenny/.ssh/id_ed25519): \nEnter passphrase (empty for no passphrase): \nEnter same passphrase again: \nYour identification has been saved in /Users/jenny/.ssh/id_ed25519.\nYour public key has been saved in /Users/jenny/.ssh/id_ed25519.pub.\nThe key fingerprint is:\nSHA256:XUEaY/elhcQJz3M9jx/SdC0zh10lCA7uNpqgkm5G/R0 jenny-2020-mbp\nThe key's randomart image is:\n+--[ED25519 256]--+\n|        . =o==oo*|\n|       . + =.=+B+|\n|        . o . @oB|\n|       . . .  oO+|\n|  . .   S .  ..o.|\n| o o . E .    ...|\n|+ . . + .       .|\n|.+   . .         |\n|o.               |\n+----[SHA256]-----+\n\n10.4.3 Agregar clave al agente ssh\nInforme a su agente ssh sobre la clave y, especialmente, configúrelo para administrar la frase de contraseña, si decide establecer una.\nLas cosas se vuelven un poco específicas del sistema operativo por aquí. En caso de duda, consulte las instrucciones de GitHub para SSH, que se mantiene actualizado para Mac, Windows y Linux. También explica situaciones más inusuales que las que puedo.\n\n10.4.3.1 Mac OS\nAsegúrese de que ssh-agent esté habilitado. Así es como se ve el éxito (el pid variará):\n~ % eval \"$(ssh-agent -s)\"\nAgent pid 15360\nA veces esto falla así:\n~ % eval \"$(ssh-agent -s)\"\nmkdtemp: private socket dir: No such file or directory\nUn error similar podría informarse como “Permiso denegado”. Deberías intentarlo de nuevo, pero como superusuario. ¡No olvide utilizar exit para volver a su cuenta de usuario normal cuando haya terminado!\n~ % sudo su\nPassword:\nsh-3.2# eval \"$(ssh-agent -s)\"\nAgent pid 15385\nsh-3.2# exit\nexit\nAgregue su clave al agente ssh. Si establece una frase de contraseña, se le cuestionará aquí. Darle. La opción -K almacena su frase de contraseña en el Keychain.\n~ % ssh-add -K ~/.ssh/id_ed25519\nEnter passphrase for /Users/jenny/.ssh/id_ed25519: \nIdentity added: /Users/jenny/.ssh/id_ed25519 (jenny-2020-mbp)\nSi tienes macOS Sierra 10.12.2 y superior, debes hacer una cosa más. Cree un archivo ~/.ssh/config con este contenido:\nHost *\n  AddKeysToAgent yes\n  UseKeychain yes\n  IdentityFile ~/.ssh/id_ed25519\nPuedes omitir la línea sobre UseKeychain si no usaste una frase de contraseña. Pero si lo hizo, esto debería almacenar su contraseña persistentemente en el llavero. De lo contrario, tendrás que ingresarlo cada vez que inicies sesión. Hilo útil de StackOverflow: ¿Cómo puedo agregar permanentemente mi clave privada SSH a Keychain para que esté disponible automáticamente para ssh?.\n\n10.4.3.2 Windows\nEn un shell de Git Bash, asegúrese de que ssh-agent se esté ejecutando:\n$ eval $(ssh-agent -s)\nAgent pid 59566\nAgregue su clave, sustituyendo el nombre correcto por su clave.\n$ ssh-add ~/.ssh/id_ed25519\n\n10.4.3.3 Linux\nEn un shell, asegúrese de que ssh-agent se esté ejecutando:\n$ eval \"$(ssh-agent -s)\"\nAgent pid 59566\nAgregue su clave, sustituyendo el nombre correcto por su clave.\nssh-add ~/.ssh/id_ed25519",
    "crumbs": [
      "Conectar Git, GitHub, RStudio",
      "<span class='chapter-number'>10</span>  <span class='chapter-title'>Configurar claves para SSH</span>"
    ]
  },
  {
    "objectID": "connect-ssh-keys.html#proporcionar-clave-pública-a-github",
    "href": "connect-ssh-keys.html#proporcionar-clave-pública-a-github",
    "title": "10  Configurar claves para SSH",
    "section": "\n10.5 Proporcionar clave pública a GitHub",
    "text": "10.5 Proporcionar clave pública a GitHub\nAhora almacenamos una copia de su clave pública en GitHub.\n\n10.5.1 RStudio al portapapeles\nVaya a Tools &gt; Global Options…&gt; Git/SVN. Si su par de claves tiene el nombre id_rsa.pub e id_rsa, RStudio lo verá y le ofrecerá “Ver clave pública”. Haga eso y acepte la oferta de copiar a su portapapeles.\nSi su par de claves tiene un nombre diferente, como id_ed25519.pub e id_ed25519, tendrá que copiar la clave pública de otra manera.\n\n10.5.2 Shell al portapapeles\nCopie la clave pública en su portapapeles. Por ejemplo, abra ~/.ssh/id_ed25519.pub en un editor y copie el contenido en su portapapeles. O realice una de las siguientes acciones en la línea de comando:\n\nMac OS: pbcopy &lt; ~/.ssh/id_ed25519.pub\n\nWindows: clip &lt; ~/.ssh/id_ed25519.pub\n\nLinux: xclip -sel clip &lt; ~/.ssh/id_ed25519.pub\n\n\nLinux: si es necesario, instale xclip mediante apt-get o yum. Por ejemplo, sudo apt-get install xclip.\n\n10.5.3 En GitHub\nAhora registramos la clave pública con GitHub. Haga clic en su foto de perfil en la esquina superior derecha y vaya a Configuración &gt; Claves SSH y GPG. Haga clic en “Nueva clave SSH”. Pegue su clave pública en el cuadro “Clave”. Asígnele un título informativo, probablemente repitiendo el comentario descriptivo que utilizó anteriormente durante la creación de la clave. Haga clic en “Agregar clave SSH”.\n¡En teoría, hemos terminado! Puedes usar ssh -T git@github.com para probar su conexión a GitHub. Si no está seguro de qué hacer con el resultado, consulte el enlace para obtener más detalles. Por supuesto, la mejor prueba es analizar los ejemplos de uso realistas que aparecen en otras partes de esta guía.",
    "crumbs": [
      "Conectar Git, GitHub, RStudio",
      "<span class='chapter-number'>10</span>  <span class='chapter-title'>Configurar claves para SSH</span>"
    ]
  },
  {
    "objectID": "connect-ssh-keys.html#sec-ssh-troubleshooting",
    "href": "connect-ssh-keys.html#sec-ssh-troubleshooting",
    "title": "10  Configurar claves para SSH",
    "section": "\n10.6 Solución de problemas",
    "text": "10.6 Solución de problemas\n\n10.6.1 URL HTTPS cuando pretendías usar SSH\nSi cree que tiene SSH configurado correctamente y aún así se le solicitan credenciales, considere esto: para el repositorio en cuestión, ¿es posible que haya configurado GitHub, probablemente llamado origin, como un control remoto HTTPS, en lugar de SSH?\nCómo ver las URL remotas asociadas con el repositorio actual en el shell:\ngit remote -v\nUn control remoto SSH se verá así:\ngit@github.com:USERNAME/REPOSITORY.git\nmientras que un control remoto HTTPS se verá así:\nhttps://github.com/USERNAME/REPOSITORY.git\nPuedes solucionar este problema con git remoto set-url, que se demuestra en La URL determina el protocolo.\n\n10.6.2 git2r, o alguna otra herramienta, no puede encontrar claves SSH en Windows\n¿Has visto este mensaje de error?\nError in .local(object, ...) : \n  Error in 'git2r_push': error authenticating: failed connecting agent\nLo hemos visto cuando trabajamos con Git/GitHub desde R a través del paquete git2r.\nLa causa principal es la confusión sobre la ubicación de .ssh/ en Windows. La idea que tiene R de su directorio de inicio en Windows a menudo difiere de la ubicación predeterminada de los archivos de configuración para Git y ssh, como .ssh/. En sistemas *nix, generalmente coinciden y no hay problema.\nDos directorios importantes en Windows son el HOME del usuario y el USERPROFILE. R generalmente asocia ~ con HOME, pero Git y ssh a menudo consultan USERPROFILE para sus archivos de configuración. En mi máquina virtual con Windows 10, veo:\n\nnormalizePath(\"~\")\n#&gt; [1] \"C:\\\\Users\\\\JennyVM\\\\Documents\"\n\nas.list(Sys.getenv(\n  c(\"HOME\", \"USERPROFILE\")\n))\n#&gt; $HOME\n#&gt; [1] \"C:/Users/JennyVM/Documents\"\n#&gt; \n#&gt; $USERPROFILE\n#&gt; [1] \"C:\\\\Users\\\\JennyVM\"\n\nlist.files(\n  Sys.getenv(\"USERPROFILE\"),\n  pattern = \"ssh|git\",\n  include.dirs = TRUE,\n  all.files = TRUE\n)\n#&gt; [1] \".gitconfig\" \".ssh\"\n\nDos soluciones:\n\n\nDígale a git2r explícitamente dónde encontrar su clave pública y privada y pase el objeto cred resultante a sus llamadas de git2r.\n\ncred &lt;- git2r::cred_ssh_key(\n  publickey = \"~/../.ssh/id_rsa.pub\",\n  privatekey = \"~/../.ssh/id_rsa\"\n)\n\n\n\nCrear un enlace simbólico para que .ssh/ en el directorio de inicio de R apunte a su directorio real .ssh/. Ejemplo aportado por Ian Lyttle en Windows 7 usando el símbolo del sistema:\nMKLINK /D \"C:\\Users\\username\\Documents\\.ssh\" \"C:\\Users\\username\\.ssh\"\n\n\nFinalmente, si git2r parece incapaz de obtener su contraseña SSH de ssh-agent, instale el paquete getPass:\n\ninstall.packages(\"getPass\")\n\ny git2r debería abrir una ventana emergente donde puede ingresar su frase de contraseña. Gracias a Ian Lyttle por este consejo.\nEste enlace proporciona una excelente explicación de la incertidumbre sobre dónde se encuentran .ssh/ y .gitconfig del usuario en Windows: git en Windows - ubicación de los archivos de configuración. En pocas palabras: coloque su configuración y claves donde su herramienta principal espera que estén y cree enlaces simbólicos para ayudar a otras herramientas a encontrar estas cosas.\n\n10.6.3 Otro\nOtras cosas para verificar dos veces:\n\n¿Agregaste SSH a tu agente ssh?\n¿Configuraste Mac OS Sierra o High Sierra para almacenar persistentemente tu frase de contraseña en el llavero?\n¿Agregaste la clave pública a GitHub?",
    "crumbs": [
      "Conectar Git, GitHub, RStudio",
      "<span class='chapter-number'>10</span>  <span class='chapter-title'>Configurar claves para SSH</span>"
    ]
  },
  {
    "objectID": "connect-git-github.html",
    "href": "connect-git-github.html",
    "title": "11  Conéctate a GitHub",
    "section": "",
    "text": "11.1 Hacer un repositorio en GitHub\nObjetivo: asegurarse de que puede extraer y enviar GitHub desde su computadora.\nNo explico en detalle todos los comandos de Shell (Apéndice A) y Git. Este es un ejercicio de diagnóstico/configuración de caja negra. En capítulos posteriores y en talleres en vivo, revisamos estas operaciones con mucha más narrativa y discusión de flujos de trabajo alternativos.\nSupongo que ha decidido si utilizar HTTPS (consulte Capítulo 9) o SSH (consulte Capítulo 10) y ha preparado su credencial.\nVaya a https://github.com y asegúrese de haber iniciado sesión.\nCerca de “Repositorios”, haga clic en el gran botón verde “Nuevo”. O, si está en su propia página de perfil, haga clic en “Repositorios” y luego haga clic en el gran botón verde “Nuevo”.\nCómo completar esto:\nHaga clic en el gran botón verde que dice “Crear repositorio”.\nAhora haga clic en el gran botón verde que dice “&lt;&gt; Code”.\nCopie una URL clonada a su portapapeles. Si sigue nuestro consejo predeterminado, copie la URL HTTPS. Pero si opta por SSH, asegúrese de copiar la URL de SSH.",
    "crumbs": [
      "Conectar Git, GitHub, RStudio",
      "<span class='chapter-number'>11</span>  <span class='chapter-title'>Conéctate a GitHub</span>"
    ]
  },
  {
    "objectID": "connect-git-github.html#hacer-un-repositorio-en-github",
    "href": "connect-git-github.html#hacer-un-repositorio-en-github",
    "title": "11  Conéctate a GitHub",
    "section": "",
    "text": "Plantilla de repositorio: sin plantilla.\nNombre del repositorio: &lt;&lt;&gt;&gt;\n\nDescripción: &lt;&lt;&gt;&gt;\n\nPúblico.\n&lt;&lt;&gt;&gt;",
    "crumbs": [
      "Conectar Git, GitHub, RStudio",
      "<span class='chapter-number'>11</span>  <span class='chapter-title'>Conéctate a GitHub</span>"
    ]
  },
  {
    "objectID": "connect-git-github.html#sec-git-clone-command-line",
    "href": "connect-git-github.html#sec-git-clone-command-line",
    "title": "11  Conéctate a GitHub",
    "section": "\n11.2 Clona el repositorio en tu computadora local",
    "text": "11.2 Clona el repositorio en tu computadora local\nTenemos algunas formas de hacer esto. Aquí usamos la línea de comando Git. En (Capítulo 15), mostramos otros métodos que quizás prefieras en la vida diaria: usar usethis o RStudio IDE.\nIr al shell (Apéndice A).\nHazte cargo de… ¡o al menos notalo! – en qué directorio estás. pwd muestra el directorio de trabajo. cd es el comando para cambiar de directorio. Personalmente, haría este tipo de cosas en ~/tmp.\nClona myrepo de GitHub a tu computadora. Utilice la URL que acabamos de copiar de GitHub. Esta URL debe tener su nombre de usuario de GitHub y el nombre de su repositorio de práctica. Si su shell (Apéndice A) coopera, debería poder pegar todo el bit https://.... que copiamos arriba. Pero algunos shells no reconocen (inmediatamente) el portapapeles. En ese triste caso, debes escribirlo. Precisamente.\ngit clone https://github.com/YOUR-USERNAME/YOUR-REPOSITORY.git\nEsto debería verse así:\n~/tmp % git clone https://github.com/jennybc/myrepo.git\nCloning into 'myrepo'...\nremote: Enumerating objects: 3, done.\nremote: Counting objects: 100% (3/3), done.\nremote: Total 3 (delta 0), reused 0 (delta 0), pack-reused 0\nReceiving objects: 100% (3/3), done.\nHaga de este nuevo repositorio su directorio de trabajo, enumere sus archivos, muestre el archivo README y obtenga información sobre su conexión a GitHub:\ncd myrepo\nls\nhead README.md\ngit remote show origin\nEsto debería verse así:\n~/tmp % cd myrepo\n\n~/tmp/myrepo % ls\nREADME.md\n\n~/tmp/myrepo % head README.md \n# myrepo\nchecking stuff for Happy Git\n\n~/tmp/myrepo % git remote show origin\n* remote origin\n  Fetch URL: https://github.com/jennybc/myrepo.git\n  Push  URL: https://github.com/jennybc/myrepo.git\n  HEAD branch: main\n  Remote branch:\n    main tracked\n  Local branch configured for 'git pull':\n    main merges with remote main\n  Local ref configured for 'git push':\n    main pushes to main (up to date)",
    "crumbs": [
      "Conectar Git, GitHub, RStudio",
      "<span class='chapter-number'>11</span>  <span class='chapter-title'>Conéctate a GitHub</span>"
    ]
  },
  {
    "objectID": "connect-git-github.html#haga-un-cambio-local-confirme-y-envie",
    "href": "connect-git-github.html#haga-un-cambio-local-confirme-y-envie",
    "title": "11  Conéctate a GitHub",
    "section": "\n11.3 Haga un cambio local, confirme y envie",
    "text": "11.3 Haga un cambio local, confirme y envie\nAgregue una línea a README y verifique que Git note el cambio:\necho \"A line I wrote on my local computer  \" &gt;&gt; README.md\ngit status\nEsto debería verse así:\n~/tmp/myrepo % echo \"A line I wrote on my local computer\" &gt;&gt; README.md\n\n~/tmp/myrepo % git status\nOn branch main\nYour branch is up to date with 'origin/main'.\n\nChanges not staged for commit:\n  (use \"git add &lt;file&gt;...\" to update what will be committed)\n  (use \"git restore &lt;file&gt;...\" to discard changes in working directory)\n        modified:   README.md\n\nno changes added to commit (use \"git add\" and/or \"git commit -a\")\nPrepare (“add”), confirme este cambio y envíelo a su repositorio remoto en GitHub.\nSi es un nuevo usuario de GitHub y utiliza HTTPS, es posible que se le solicite su nombre de usuario y contraseña. Aunque GitHub ya no permite la autenticación de nombre de usuario/contraseña, muchas herramientas generales de Git todavía enmarcan la tarea de autenticación con este vocabulario. Por supuesto, proporcione su nombre de usuario de GitHub cuando se le solicite. Sin embargo, la parte más importante es proporcionar su PAT como contraseña. No introduzcas tu contraseña web. Ingrese su PAT. Si ya almacenó su PAT con gitcreds::gitcreds_set(), debería descubrirse automáticamente y no verá un desafío de credenciales.\ngit add README.md\ngit commit -m \"Una confirmación de mi computadora local\"\ngit push\nEsto debería verse así:\n~/tmp/myrepo % git add README.md\n\n~/tmp/myrepo % git commit -m \"Una confirmación de mi computadora local\"\n[main e92528c] Una confirmación de mi computadora local\n 1 file changed, 1 insertion(+)\n \n~/tmp/myrepo % git push\nEnumerating objects: 5, done.\nCounting objects: 100% (5/5), done.\nDelta compression using up to 12 threads\nCompressing objects: 100% (2/2), done.\nWriting objects: 100% (3/3), 327 bytes | 327.00 KiB/s, done.\nTotal 3 (delta 0), reused 0 (delta 0), pack-reused 0\nTo https://github.com/jennybc/myrepo.git\n   31dcaef..e92528c  main -&gt; main\n¿Ves un error como este?\n~/tmp/myrepo % git push                                                     \nremote: Support for password authentication was removed on August 13, 2021. Please use a personal access token instead.\nremote: Please see https://github.blog/2020-12-15-token-authentication-requirements-for-git-operations/ for more information.\nfatal: Authentication failed for 'https://github.com/jennybc/myrepo.git/'\nEsto significa que ha proporcionado su contraseña web de GitHub, en lugar de su token de acceso personal (PAT). Vuelva a (Capítulo 9) para obtener un PAT. Intente git push nuevamente y con suerte recibirá otro mensaje que le permitirá corregir cosas y proporcionar su PAT.\nSi alguna vez siente que necesita sobrescribir una credencial incorrecta con una nueva, la forma más sencilla de hacerlo es llamar gitcreds::gitcreds_set() desde R.\n\n11.3.1 Ventanas y finales de línea.\nEn Windows, es posible que vea un mensaje que diga LF will be replaced by CRLF. Esto es normal y no requiere ninguna acción de su parte. Windows maneja los finales de línea de manera diferente a otros sistemas operativos, pero la configuración predeterminada de Git para Windows es apropiada para la mayoría de las personas y situaciones.\nAquí hay un comando para revelar la configuración de final de línea actual y algunos resultados típicos en Windows:\n$ git config --show-origin --get core.autocrlf\nfile:\"C:\\\\ProgramData/Git/config\"      true\nSi su valor se muestra como false, puede establecerlo en true con este comando:\n$ git config --global core.autocrlf true\ntrue es la configuración predeterminada actual para core.autocrlf para Git para Windows, nuestro método recomendado para instalar Git en Windows. La necesidad de configurar esto explícitamente en su configuración de usuario global sugiere que debería considerar reinstalar o actualizar Git para Windows.",
    "crumbs": [
      "Conectar Git, GitHub, RStudio",
      "<span class='chapter-number'>11</span>  <span class='chapter-title'>Conéctate a GitHub</span>"
    ]
  },
  {
    "objectID": "connect-git-github.html#confirmar-el-cambio-local-propagado-al-control-remoto-de-github",
    "href": "connect-git-github.html#confirmar-el-cambio-local-propagado-al-control-remoto-de-github",
    "title": "11  Conéctate a GitHub",
    "section": "\n11.4 Confirmar el cambio local propagado al control remoto de GitHub",
    "text": "11.4 Confirmar el cambio local propagado al control remoto de GitHub\nVuelve al navegador. Supongo que todavía estamos viendo su nuevo repositorio de GitHub.\nActualizar.\nDeberías ver la nueva “Una línea que escribí en mi computadora local” en el archivo README.\nSi hace clic en “commits”, debería ver uno con el mensaje “Una confirmación desde mi computadora local”.\nSi ha llegado hasta aquí, usted y su repositorio de prueba están listos para pasar a usar Git y GitHub con RStudio.(Capítulo 12).",
    "crumbs": [
      "Conectar Git, GitHub, RStudio",
      "<span class='chapter-number'>11</span>  <span class='chapter-title'>Conéctate a GitHub</span>"
    ]
  },
  {
    "objectID": "connect-git-github.html#limpiar",
    "href": "connect-git-github.html#limpiar",
    "title": "11  Conéctate a GitHub",
    "section": "\n11.5 Limpiar",
    "text": "11.5 Limpiar\nSi está listo para concluir esta prueba de su instalación de Git y configuración de GitHub, podemos limpiar el repositorio de prueba ahora.\nLocal Cuando estés listo para limpiar, puedes eliminar el repositorio local como quieras. Es solo un directorio normal en su computadora.\nAquí se explica cómo hacerlo en el shell, si el directorio de trabajo actual es myrepo:\ncd ..\nrm -rf myrepo/\nGitHub En el navegador, vaya a la página de inicio de su repositorio en GitHub. Haga clic en “Configuración”.\nDesplázate hacia abajo, haz clic en “eliminar repositorio” y haz lo que te pide.",
    "crumbs": [
      "Conectar Git, GitHub, RStudio",
      "<span class='chapter-number'>11</span>  <span class='chapter-title'>Conéctate a GitHub</span>"
    ]
  },
  {
    "objectID": "connect-rstudio-git-github.html",
    "href": "connect-rstudio-git-github.html",
    "title": "12  Conectar RStudio a Git y GitHub",
    "section": "",
    "text": "12.1 Requisitos previos\nAquí verificamos que RStudio puede emitir comandos Git en su nombre. Suponiendo que haya conseguido que Git local se comunique con GitHub, esto significa que también podrá importar y enviar a GitHub desde RStudio.\nEn capítulos posteriores y en talleres en vivo, revisamos estas operaciones con mucha más explicación.\nSi tiene éxito aquí, su configuración estará HECHA.\nSuponemos lo siguiente:\nTambién necesitarás un repositorio de prueba en GitHub. Si no tiene un repositorio de prueba adecuado en GitHub, siga las instrucciones de la siguiente sección.\nSi acaba de completar el capítulo anterior, Conectarse a GitHub, ¡ese repositorio será perfecto! Sin embargo, le recomiendo que elimine el repositorio local, para que pueda experimentar cómo usamos RStudio para clonarlo y obtener una copia local. En realidad, este es un flujo de trabajo al que nos referimos en otros lugares (ver Capítulo 37) como “quemarlo todo”. Es una estrategia profundamente pragmática para afrontar la situación si su repositorio Git local está estropeado, pero la versión en GitHub es bastante actual.\nElimina la carpeta correspondiente al repositorio local como quieras. Es solo un directorio normal en su computadora. Aquí se explica cómo hacerlo en el shell, si el directorio de trabajo actual es myrepo:",
    "crumbs": [
      "Conectar Git, GitHub, RStudio",
      "<span class='chapter-number'>12</span>  <span class='chapter-title'>Conectar RStudio a Git y GitHub</span>"
    ]
  },
  {
    "objectID": "connect-rstudio-git-github.html#requisitos-previos",
    "href": "connect-rstudio-git-github.html#requisitos-previos",
    "title": "12  Conectar RStudio a Git y GitHub",
    "section": "",
    "text": "Has registrado una cuenta gratuita de GitHub (Capítulo 4).\nHas instalado/actualizado R y RStudio (Capítulo 5).\nHas instalado Git (Capítulo 6).\nTe has presentado a Git (Capítulo 7).\nHas confirmado que puedes enviar/importar desde GitHub desde la línea de comando (Capítulo 11).\n\n\n\n\ncd ..\nrm -rf myrepo/",
    "crumbs": [
      "Conectar Git, GitHub, RStudio",
      "<span class='chapter-number'>12</span>  <span class='chapter-title'>Conectar RStudio a Git y GitHub</span>"
    ]
  },
  {
    "objectID": "connect-rstudio-git-github.html#hacer-un-repositorio-en-github",
    "href": "connect-rstudio-git-github.html#hacer-un-repositorio-en-github",
    "title": "12  Conectar RStudio a Git y GitHub",
    "section": "\n12.2 Hacer un repositorio en GitHub",
    "text": "12.2 Hacer un repositorio en GitHub\nVaya a https://github.com y asegúrese de haber iniciado sesión.\nCerca de “Repositorios”, haga clic en el gran botón verde “Nuevo”. O, si está en su propia página de perfil, haga clic en “Repositorios” y luego haga clic en el gran botón verde “Nuevo”.\nCómo completar esto:\n\nPlantilla de repositorio: sin plantilla.\nNombre del repositorio: &lt;&lt;&gt;&gt;\n\nDescripción: &lt;&lt;&gt;&gt;\n\nPúblico.\n&lt;&lt;&gt;&gt;\n\n\nHaga clic en el gran botón verde que dice “Crear repositorio”.\nAhora haga clic en el gran botón verde que dice “&lt;&gt; Code”.\nCopie una URL clonada a su portapapeles. Si sigue nuestro consejo predeterminado, copie la URL HTTPS. Pero si opta por SSH, asegúrese de copiar la URL de SSH.",
    "crumbs": [
      "Conectar Git, GitHub, RStudio",
      "<span class='chapter-number'>12</span>  <span class='chapter-title'>Conectar RStudio a Git y GitHub</span>"
    ]
  },
  {
    "objectID": "connect-rstudio-git-github.html#clona-el-repositorio-de-prueba-de-github-en-tu-computadora-a-través-de-rstudio",
    "href": "connect-rstudio-git-github.html#clona-el-repositorio-de-prueba-de-github-en-tu-computadora-a-través-de-rstudio",
    "title": "12  Conectar RStudio a Git y GitHub",
    "section": "\n12.3 Clona el repositorio de prueba de GitHub en tu computadora a través de RStudio",
    "text": "12.3 Clona el repositorio de prueba de GitHub en tu computadora a través de RStudio\nEn RStudio, inicie un nuevo proyecto:\n\n\nFile &gt; New Project &gt; Version Control &gt; Git. En “URL del repositorio”, pegue la URL de su nuevo repositorio de GitHub. será algo como esto https://github.com/jennybc/myrepo.git.\n\n¿NO ve una opción para obtener el proyecto desde el control de versiones? Reinicie RStudio y vuelva a intentarlo. ¿Aún no has tenido suerte? Vaya a Capítulo 13 para obtener consejos sobre cómo ayudar a RStudio a encontrar Git.\n\n\nAcepte el nombre del directorio del proyecto predeterminado, p. myrepo, que coincide con el nombre del repositorio de GitHub.\n¡Hazte cargo de… o al menos notalo! - donde el proyecto se guardará localmente. Un error común de los novatos es no tener idea de dónde está guardando los archivos o cuál es su directorio de trabajo. Prestar atención. Sea intencional. Personalmente, haría esto en ~/tmp.\nTe sugiero que marques “Abrir en una nueva sesión”, ya que eso es lo que normalmente harás en la vida real.\nHaga clic en “Crear proyecto”.\n\nDebería encontrarse en un nuevo proyecto RStudio local que representa su repositorio de prueba en GitHub. Esto debería descargar el archivo README.md de GitHub. Busque en el panel del explorador de archivos de RStudio el archivo README.md.",
    "crumbs": [
      "Conectar Git, GitHub, RStudio",
      "<span class='chapter-number'>12</span>  <span class='chapter-title'>Conectar RStudio a Git y GitHub</span>"
    ]
  },
  {
    "objectID": "connect-rstudio-git-github.html#realizar-cambios-locales-guardar-confirmar",
    "href": "connect-rstudio-git-github.html#realizar-cambios-locales-guardar-confirmar",
    "title": "12  Conectar RStudio a Git y GitHub",
    "section": "\n12.4 Realizar cambios locales, guardar, confirmar",
    "text": "12.4 Realizar cambios locales, guardar, confirmar\nDesde RStudio, modifique el archivo README.md, por ejemplo, agregando la línea “Esta es una línea de RStudio”. Guarde sus cambios.\nConfirme estos cambios en su repositorio local. ¿Cómo?\nDe RStudio:\n\nHaga clic en la pestaña “Git” en el panel superior derecho.\nMarque la casilla “Staged” para README.md.\nSi aún no estás en la ventana emergente de Git, haz clic en “Commit”.\nEscriba un mensaje en “Commit message”, como por ejemplo “Commit from RStudio”.\nHaga click en “Commit”.",
    "crumbs": [
      "Conectar Git, GitHub, RStudio",
      "<span class='chapter-number'>12</span>  <span class='chapter-title'>Conectar RStudio a Git y GitHub</span>"
    ]
  },
  {
    "objectID": "connect-rstudio-git-github.html#envíe-sus-cambios-locales-en-línea-a-github",
    "href": "connect-rstudio-git-github.html#envíe-sus-cambios-locales-en-línea-a-github",
    "title": "12  Conectar RStudio a Git y GitHub",
    "section": "\n12.5 Envíe sus cambios locales en línea a GitHub",
    "text": "12.5 Envíe sus cambios locales en línea a GitHub\nHaga clic en el botón verde “Push” para enviar sus cambios locales a GitHub.\nNo debería experimentar un desafío de credenciales, ya que uno de los requisitos previos fue ingresar exitosamente a GitHub desde la línea de comando (Capítulo 11). El panel Git de RStudio simplemente expone un subconjunto específico de la línea de comando Git y, por lo tanto, una vez que sus credenciales funcionen en el shell, deberían funcionar en RStudio. Si experimenta un desafío de credenciales, eso sugiere que debería echar un vistazo a las sugerencias de solución de problemas para el protocolo elegido, ya sea HTTPS o SSH.",
    "crumbs": [
      "Conectar Git, GitHub, RStudio",
      "<span class='chapter-number'>12</span>  <span class='chapter-title'>Conectar RStudio a Git y GitHub</span>"
    ]
  },
  {
    "objectID": "connect-rstudio-git-github.html#confirmar-el-cambio-local-propagado-al-control-remoto-de-github",
    "href": "connect-rstudio-git-github.html#confirmar-el-cambio-local-propagado-al-control-remoto-de-github",
    "title": "12  Conectar RStudio a Git y GitHub",
    "section": "\n12.6 Confirmar el cambio local propagado al control remoto de GitHub",
    "text": "12.6 Confirmar el cambio local propagado al control remoto de GitHub\nVuelve al navegador. Supongo que todavía estamos viendo su nuevo repositorio de GitHub.\nActualizar.\nDeberías ver el nuevo “Esta es una línea de RStudio” en el archivo README.\nSi hace clic en “confirmar”, debería ver uno con el mensaje “Confirmar desde RStudio”.\nSi ha llegado hasta aquí, habrá TERMINADO la configuración. ¡Felicidades!",
    "crumbs": [
      "Conectar Git, GitHub, RStudio",
      "<span class='chapter-number'>12</span>  <span class='chapter-title'>Conectar RStudio a Git y GitHub</span>"
    ]
  },
  {
    "objectID": "connect-rstudio-git-github.html#limpiar",
    "href": "connect-rstudio-git-github.html#limpiar",
    "title": "12  Conectar RStudio a Git y GitHub",
    "section": "\n12.7 Limpiar",
    "text": "12.7 Limpiar\nSalga de la instancia de RStudio que está abierta en su proyecto de prueba/repositorio Git.\nElimina el repositorio local como quieras. Es solo un directorio normal en su computadora.\nAquí se explica cómo hacerlo en el shell, si el directorio de trabajo actual es myrepo:\ncd ..\nrm -rf myrepo/\nEn el navegador, vaya a la página de inicio de su repositorio en GitHub. Haga clic en “Configuración”.\nDesplázate hacia abajo, haz clic en “eliminar repositorio” y haz lo que te pide.",
    "crumbs": [
      "Conectar Git, GitHub, RStudio",
      "<span class='chapter-number'>12</span>  <span class='chapter-title'>Conectar RStudio a Git y GitHub</span>"
    ]
  },
  {
    "objectID": "connect-can-rstudio-use-git.html",
    "href": "connect-can-rstudio-use-git.html",
    "title": "13  Detectar Git desde RStudio",
    "section": "",
    "text": "13.1 ¿Tiene usted un problema?\nSi desea que RStudio le ayude con su trabajo de Git y GitHub, debe poder encontrar el ejecutable de Git.\nPor lo general, esto “simplemente funciona”, por lo que esta página está dirigida a personas que tienen motivos para sospechar que tienen un problema.\nEsto es algo que se configura una vez por computadora.\nComprobemos si RStudio puede encontrar el ejecutable de Git.\nSigue leyendo si las cosas no van tan bien o quieres saber más.",
    "crumbs": [
      "Conectar Git, GitHub, RStudio",
      "<span class='chapter-number'>13</span>  <span class='chapter-title'>Detectar Git desde RStudio</span>"
    ]
  },
  {
    "objectID": "connect-can-rstudio-use-git.html#tiene-usted-un-problema",
    "href": "connect-can-rstudio-use-git.html#tiene-usted-un-problema",
    "title": "13  Detectar Git desde RStudio",
    "section": "",
    "text": "File &gt; New Project… ¿Ves una opción para crear desde Control de versiones? Si es así, bien.\nSeleccione New Directory &gt; Empty Project. ¿Ves una casilla de verificación “Create a git repository”? Si es así, bien, SELECCIÓNELO.",
    "crumbs": [
      "Conectar Git, GitHub, RStudio",
      "<span class='chapter-number'>13</span>  <span class='chapter-title'>Detectar Git desde RStudio</span>"
    ]
  },
  {
    "objectID": "connect-can-rstudio-use-git.html#encuentra-git-tú-mismo",
    "href": "connect-can-rstudio-use-git.html#encuentra-git-tú-mismo",
    "title": "13  Detectar Git desde RStudio",
    "section": "13.2 Encuentra Git tú mismo",
    "text": "13.2 Encuentra Git tú mismo\nRStudio solo puede actuar como interfaz gráfica de usuario para Git si Git se ha instalado correctamente (Capítulo 6) Y RStudio puede encontrarlo.\nUna prueba básica para una instalación exitosa de Git es simplemente ingresar git en el shell (Apéndice A). Si recibe una queja acerca de que no se encuentra Git, significa que la instalación no tuvo éxito o que no se encuentra, es decir, no está en su PATH.\nSi no está seguro de dónde se encuentra el ejecutable de Git, intente esto en un shell:\n\nwhich git (Mac, Linux, Git Bash shell en Windows)\nwhere git (Símbolo del sistema de Windows, es decir cmd.exe)",
    "crumbs": [
      "Conectar Git, GitHub, RStudio",
      "<span class='chapter-number'>13</span>  <span class='chapter-title'>Detectar Git desde RStudio</span>"
    ]
  },
  {
    "objectID": "connect-can-rstudio-use-git.html#dile-a-rstudio-dónde-encontrar-git",
    "href": "connect-can-rstudio-use-git.html#dile-a-rstudio-dónde-encontrar-git",
    "title": "13  Detectar Git desde RStudio",
    "section": "13.3 Dile a RStudio dónde encontrar Git",
    "text": "13.3 Dile a RStudio dónde encontrar Git\nSi parece que Git está instalado y se puede encontrar, inicie RStudio. Salga y reinicie RStudio si tiene alguna duda sobre si abrió RStudio antes o después de instalar Git. No me obligues a detener este auto y reiniciar RStudio en horario de oficina. HAZLO.\nDesde RStudio, vaya a Tools &gt; Global Options &gt; Git/SVN y asegúrese de que el cuadro Git executable apunte a su ejecutable Git.\nEn macOS y Linux, la ruta suele verse así:\n/usr/bin/git\nSi necesita configurar esto en macOS, a veces puede resultar difícil navegar hasta el directorio necesario una vez que haya hecho clic en “Examinar” y esté trabajando con una ventana tipo Finder. El método abreviado de teclado “comando + mayúsculas + g” invocará “Ir a la carpeta”, donde podrá escribir o pegar cualquier ruta que desee.\nEn Windows, esta ruta debería verse así:\nC:/Program Files/Git/bin/git.exe\ny aquí hay una captura de pantalla en Windows:\n\n\n\n\n\nADVERTENCIA: En Windows, NO use C:/Program Files/Git/cmd/git.exe. bin en el camino es BUENO ¡SÍ! cmd en la ruta es MALO ¡NO!\nADVERTENCIA: En Windows, NO configure esto en git-bash.exe. Algo que termina en git.exe es BUENO ¡SÍ! git-bash.exe es MALO, ¡NO!\nReinicie RStudio si realiza algún cambio aquí. No me obligue a detener este auto nuevamente y reinicie RStudio por usted en horario de oficina. HAZLO.\nVuelva a realizar los pasos en la parte superior de la página para ver si RStudio y Git se están comunicando ahora.\n\nHe visto esta ayuda: con su proyecto abierto, vaya a Tools &gt; Project Options.... Si está disponible, haga clic en “Git/SVN” y seleccione “Git” en el menú desplegable del sistema de control de versiones. Responda “sí” a la ventana emergente “Confirmar nuevo repositorio Git”. Responda “sí” a la ventana emergente “Confirmar reinicio de RStudio”.\nSi instaló Git a través de GitHub para Windows, es posible que el ejecutable de Git esté muy bien oculto. Obtenga ayuda o utilice uno de nuestros métodos recomendados para instalar Git.\nSu PATH probablemente no esté configurada correctamente y/o debería reinstalar Git y controlar/observar hacia dónde se dirige. Lea más en Capítulo 14.\nConsigue nuestra ayuda.",
    "crumbs": [
      "Conectar Git, GitHub, RStudio",
      "<span class='chapter-number'>13</span>  <span class='chapter-title'>Detectar Git desde RStudio</span>"
    ]
  },
  {
    "objectID": "connect-troubleshooting.html",
    "href": "connect-troubleshooting.html",
    "title": "14  RStudio, Git, GitHub Hell",
    "section": "",
    "text": "14.1 Creo que he instalado Git pero maldita sea si puedo encontrarlo.\nProblemas que hemos visto y posibles soluciones.\nSi experimenta algún problema nuevo y, sobre todo, encuentra la solución correspondiente, ¡nos encantaría saber de usted!\nCuando instales Git, intenta controlar o registrar dónde se está instalando. Tome nota mental o física de estas cosas.\nEs posible que puedas encontrar Git después del hecho con estos comandos en el shell (Apéndice A):\nNo es del todo una locura simplemente reinstalar Git, usando un método que lo deje en una ubicación más convencional y prestando mucha atención a dónde se está instalando. Vive y aprende.",
    "crumbs": [
      "Conectar Git, GitHub, RStudio",
      "<span class='chapter-number'>14</span>  <span class='chapter-title'>RStudio, Git, GitHub Hell</span>"
    ]
  },
  {
    "objectID": "connect-troubleshooting.html#creo-que-he-instalado-git-pero-maldita-sea-si-puedo-encontrarlo.",
    "href": "connect-troubleshooting.html#creo-que-he-instalado-git-pero-maldita-sea-si-puedo-encontrarlo.",
    "title": "14  RStudio, Git, GitHub Hell",
    "section": "",
    "text": "which git (Mac, Linux o cualquier dispositivo que ejecute un shell bash)\nwhere git (Windows, cuando no está en un shell bash)",
    "crumbs": [
      "Conectar Git, GitHub, RStudio",
      "<span class='chapter-number'>14</span>  <span class='chapter-title'>RStudio, Git, GitHub Hell</span>"
    ]
  },
  {
    "objectID": "connect-troubleshooting.html#el-panel-rstudio-git-desaparece-en-mac-os",
    "href": "connect-troubleshooting.html#el-panel-rstudio-git-desaparece-en-mac-os",
    "title": "14  RStudio, Git, GitHub Hell",
    "section": "14.2 El panel RStudio Git desaparece en Mac OS",
    "text": "14.2 El panel RStudio Git desaparece en Mac OS\nA veces, el panel RStudio Git desaparece en un sistema donde estaba funcionando anteriormente. Esto suele sucederle a las personas que instalaron Git instalando las herramientas de línea de comandos de Xcode. Suele ser una señal de que necesita volver a aceptar el acuerdo de licencia de Xcode. Esto es necesario después de una actualización de Mac OS, la reinstalación de Xcode o incluso actualizaciones silenciosas de Xcode que a veces parecen ocurrir sin el conocimiento del usuario.\nEn el shell, puedes ejecutar git status y es posible que veas un mensaje como este:\nAgreeing to the Xcode/iOS license requires admin privileges, please run “sudo xcodebuild -license” and then retry this command.\nSi recibe instrucciones tan claras, haga lo que dice, es decir, ejecute sudo xcodebuild -license, para volver a aceptar la licencia.\nEn cualquier caso, debe hacer cosquillas a las herramientas de línea de comandos de Xcode para que le soliciten lo que necesite. Aquí hay otros comandos que, según la situación, pueden activar las indicaciones necesarias:\nxcode-select --install\no\ngit config --global --list\nEntonces reinicie RStudio.",
    "crumbs": [
      "Conectar Git, GitHub, RStudio",
      "<span class='chapter-number'>14</span>  <span class='chapter-title'>RStudio, Git, GitHub Hell</span>"
    ]
  },
  {
    "objectID": "connect-troubleshooting.html#path-disfuncional",
    "href": "connect-troubleshooting.html#path-disfuncional",
    "title": "14  RStudio, Git, GitHub Hell",
    "section": "14.3 PATH disfuncional",
    "text": "14.3 PATH disfuncional\nAlgunos casos en los que RStudio no detecta automáticamente el ejecutable de Git se deben a problemas con PATH. Este es el conjunto de directorios donde su computadora buscará ejecutables, como Git (hoy) o make. Ciertos métodos de instalación de Git, especialmente en Windows y/o sistemas operativos más antiguos, tienen una mayor tendencia a colocar Git en una ubicación no convencional o a no agregar el directorio relevante a PATH.\n¿Cómo ver PATH?\nEn el shell:\necho $PATH\nFíjate bien en esto. Vea el punto anterior sobre cómo encontrar su ejecutable Git o reinstalarlo mientras está completamente despierto. ¿Está el directorio principal del ejecutable de Git en su PATH? ¿No? Arregla eso.\nEn este punto te recomiendo que hagas una búsqueda en Google para encontrar instrucciones sobre cómo modificar PATH en tu sistema operativo específico.",
    "crumbs": [
      "Conectar Git, GitHub, RStudio",
      "<span class='chapter-number'>14</span>  <span class='chapter-title'>RStudio, Git, GitHub Hell</span>"
    ]
  },
  {
    "objectID": "connect-troubleshooting.html#botones-pushpull-atenuados-en-rstudio",
    "href": "connect-troubleshooting.html#botones-pushpull-atenuados-en-rstudio",
    "title": "14  RStudio, Git, GitHub Hell",
    "section": "14.4 Botones Push/Pull atenuados en RStudio",
    "text": "14.4 Botones Push/Pull atenuados en RStudio\n¿Está seguro de que su repositorio local está asociado con un repositorio remoto, p. ¿Un repositorio de GitHub? En un shell con el directorio de trabajo configurado en el repositorio de Git local, ingrese este comando:\n~/tmp/myrepo % git remote -v                                           \norigin  git@github.com:jennybc/myrepo.git (fetch)\norigin  git@github.com:jennybc/myrepo.git (push)\nQueremos ver que la recuperación y la inserción estén configuradas en URL remotas que apunten al repositorio remoto.\nSi descubre que aún necesita configurar un control remoto, obtenga la URL HTTPS o SSH, según corresponda, para su repositorio de GitHub. Es fácil acceder a su portapapeles desde la página de GitHub del repositorio. Haz esto en el shell:\ngit remote add origin https://github.com/jennybc/myrepo.git\nDescargue todos los archivos del repositorio en línea de GitHub y solucione cualquier conflicto (sustituyendo master por main, si corresponde).\ngit pull origin main\nLlame a git remote -v nuevamente. Una vez que esté satisfecho de que su control remoto GitHub esté configurado correctamente, puede continuar con el siguiente paso.\n¿Está seguro de que la rama actual está siguiendo una rama en el control remoto? En ese mismo shell, en tu repositorio, haz esto:\n~/tmp/myrepo % git branch -vv\n* main 2899c91 [origin/main] A commit from my local computer\nLo anterior muestra una confirmación exitosa de que la rama main local está rastreando origin/main, es decir, la rama main en GitHub. Si no ve el bit [origen/principal], eso es un problema. Por cierto, git branch -r y git remote show origin son dos comandos más que son útiles para examinar su configuración remota.\nAl conectar un repositorio local a un nuevo repositorio de GitHub, muchas personas recuerdan agregar el control remoto de GitHub, pero también se olvidan de consolidar esta relación de seguimiento para las ramas relevantes.\nSi descubre que su rama main local aún no realiza un seguimiento de main en GitHub, corríjalo de la siguiente manera:\ngit push --set-upstream origin main\nEsto es equivalente a git push -u origin main pero transmite más sobre lo que estás haciendo.\nLlame a git branch -vv o git branch -r o git remote show origin nuevamente para confirmar que la rama main en GitHub es la rama de seguimiento para la rama main local.",
    "crumbs": [
      "Conectar Git, GitHub, RStudio",
      "<span class='chapter-number'>14</span>  <span class='chapter-title'>RStudio, Git, GitHub Hell</span>"
    ]
  },
  {
    "objectID": "connect-troubleshooting.html#no-tengo-idea-si-mi-repositorio-local-y-mi-repositorio-remoto-están-conectados.",
    "href": "connect-troubleshooting.html#no-tengo-idea-si-mi-repositorio-local-y-mi-repositorio-remoto-están-conectados.",
    "title": "14  RStudio, Git, GitHub Hell",
    "section": "14.5 No tengo idea si mi repositorio local y mi repositorio remoto están conectados.",
    "text": "14.5 No tengo idea si mi repositorio local y mi repositorio remoto están conectados.\nConsulte la sección anterior sobre “Botones Push/Pull atenuados en RStudio”.",
    "crumbs": [
      "Conectar Git, GitHub, RStudio",
      "<span class='chapter-number'>14</span>  <span class='chapter-title'>RStudio, Git, GitHub Hell</span>"
    ]
  },
  {
    "objectID": "connect-troubleshooting.html#push-rechazado-es-decir-falla-en-el-nivel-de-gitgithub",
    "href": "connect-troubleshooting.html#push-rechazado-es-decir-falla-en-el-nivel-de-gitgithub",
    "title": "14  RStudio, Git, GitHub Hell",
    "section": "14.6 Push rechazado, es decir, falla en el nivel de Git/GitHub",
    "text": "14.6 Push rechazado, es decir, falla en el nivel de Git/GitHub\nEs posible que tenga cambios en el repositorio remoto Y en su repositorio local. El hecho de que no recuerde haber realizado ninguna edición en el navegador no significa que no lo haya hecho. Hazme reír.\nRealiza un pull primero. Resuelve cualquier conflicto. Luego intenta realizar un push nuevamente.",
    "crumbs": [
      "Conectar Git, GitHub, RStudio",
      "<span class='chapter-number'>14</span>  <span class='chapter-title'>RStudio, Git, GitHub Hell</span>"
    ]
  },
  {
    "objectID": "connect-troubleshooting.html#rstudio-no-pone-ciertos-archivos-a-disposición-de-stagingcommitting",
    "href": "connect-troubleshooting.html#rstudio-no-pone-ciertos-archivos-a-disposición-de-stagingcommitting",
    "title": "14  RStudio, Git, GitHub Hell",
    "section": "14.7 RStudio no pone ciertos archivos a disposición de staging/committing",
    "text": "14.7 RStudio no pone ciertos archivos a disposición de staging/committing\n¿Tiene un espacio en su directorio o nombres de archivos? Un espacio en el nombre de un archivo es un espacio en tu alma Deshazte de él.\n¿Está su repositorio Git/Proyecto RStudio dentro de una carpeta que… eventualmente se acumula en Google Drive, DropBox, Microsoft OneDrive o una unidad de red? En caso afirmativo, le recomiendo que mueva el repositorio/Proyecto a un directorio antiguo y simple que se encuentre directamente en su computadora y que no esté administrado, por ejemplo, por Google Drive.\nSi no puede abordar las dos causas fundamentales identificadas anteriormente, entonces es posible que un cliente Git más potente (Capítulo 8) pueda hacer frente a estas situaciones. Pero no hago ninguna promesa. También deberías probar las operaciones de Git desde la línea de comandos.",
    "crumbs": [
      "Conectar Git, GitHub, RStudio",
      "<span class='chapter-number'>14</span>  <span class='chapter-title'>RStudio, Git, GitHub Hell</span>"
    ]
  },
  {
    "objectID": "connect-troubleshooting.html#he-oído-que-tienes-algún-repositorio-de-git-dentro-de-tu-repositorio-de-git.",
    "href": "connect-troubleshooting.html#he-oído-que-tienes-algún-repositorio-de-git-dentro-de-tu-repositorio-de-git.",
    "title": "14  RStudio, Git, GitHub Hell",
    "section": "14.8 He oído que tienes algún repositorio de Git dentro de tu repositorio de Git.",
    "text": "14.8 He oído que tienes algún repositorio de Git dentro de tu repositorio de Git.\nNo cree un repositorio Git dentro de otro repositorio Git. Simplemente no lo hagas.\nSi tiene una necesidad genuina de esto, lo cual es realmente raro, la forma correcta de hacerlo es a través de submodules.\nEn STAT 545, ciertamente no necesitamos hacer esto y cuando lo hemos visto, ha sido un error. Esto ha resultado en la pérdida completa e inesperada del repositorio interno de Git. Sin duda, hubo más cosas aquí (tos, cliente de escritorio GitHub), pero el uso no estándar de los repositorios de Git hace que sea mucho más fácil cometer errores costosos.",
    "crumbs": [
      "Conectar Git, GitHub, RStudio",
      "<span class='chapter-number'>14</span>  <span class='chapter-title'>RStudio, Git, GitHub Hell</span>"
    ]
  },
  {
    "objectID": "usage-intro.html",
    "href": "usage-intro.html",
    "title": "Comience con GitHub",
    "section": "",
    "text": "Ahora que hemos verificado su configuración de Git/GitHub/RStudio, podemos hacer una demostración de los flujos de trabajo que usará para llevar su trabajo a GitHub:\n\nNuevo proyecto, GitHub primero es la forma más fácil de conseguir un proyecto funcional.\nProyecto existente, GitHub primero es una forma profundamente pragmática de llevar trabajos preexistentes a GitHub.\nProyecto existente, GitHub último es la forma más adecuada de conectar el trabajo local existente a un control remoto en GitHub, especialmente si ya existe un historial de Git.\n\nEsta parte concluye con dos flujos de trabajo específicos de R que muestran qué tan bien R Markdown (el formato) y rmarkdown (el paquete) trabajan con GitHub:\n\nPrueba R Markdown\nRenderizar un script R",
    "crumbs": [
      "Primeras victorias en GitHub",
      "Comience con GitHub"
    ]
  },
  {
    "objectID": "usage-new-project-github-first.html",
    "href": "usage-new-project-github-first.html",
    "title": "15  Nuevo proyecto, GitHub primero",
    "section": "",
    "text": "15.1 Hacer un repositorio en GitHub\nCreamos un nuevo Proyecto, con la secuencia preferida “Primero GitHub, luego RStudio”. ¿Por qué preferimos esto? Porque este método de copiar el proyecto desde GitHub a su computadora también configura el repositorio local de Git para su importación y envío inmediato. Debajo del capó, estamos haciendo “git clone”.\nDe hecho, ya hiciste esto antes durante la configuración (Capítulo 12). Lo volvemos a hacer, con sentimiento.\nEl flujo de trabajo es bastante similar para otros administradores de repositorios como GitLab o Bitbucket. A continuación especificaremos cuándo es posible que necesite hacer algo diferente.\nVaya a https://github.com y asegúrese de haber iniciado sesión.\nCerca de “Repositorios”, haga clic en el gran botón verde “Nuevo”. O, si está en su propia página de perfil, haga clic en “Repositorios” y luego haga clic en el gran botón verde “Nuevo”.\nCómo completar esto:\nHaga clic en el gran botón verde que dice “Crear repositorio”.\nAhora haga clic en el gran botón verde que dice “&lt;&gt; Code”.\nCopie una URL clonada a su portapapeles. Si sigue nuestro consejo predeterminado, copie la URL HTTPS. Pero si opta por SSH, asegúrese de copiar la URL de SSH.",
    "crumbs": [
      "Primeras victorias en GitHub",
      "<span class='chapter-number'>15</span>  <span class='chapter-title'>Nuevo proyecto, GitHub primero</span>"
    ]
  },
  {
    "objectID": "usage-new-project-github-first.html#hacer-un-repositorio-en-github",
    "href": "usage-new-project-github-first.html#hacer-un-repositorio-en-github",
    "title": "15  Nuevo proyecto, GitHub primero",
    "section": "",
    "text": "Plantilla de repositorio: sin plantilla.\nNombre del repositorio: &lt;&lt;&gt;&gt;\n\nDescripción: &lt;&lt;&gt;&gt;\n\nPúblico.\n&lt;&lt;&gt;&gt;\n\n\n\n\n\n\n\n15.1.1 GitLab\nInicie sesión en https://gitlab.com. Haga clic en el botón “+” en la esquina superior derecha y luego en “Nuevo proyecto”.\n\nNombre del proyecto: myrepo (o lo que desees)\n\nPúblico\nSÍ Inicializar el repositorio con un README\n\nHaga clic en el gran botón verde “Crear proyecto”.\nCopie la URL de clonación HTTPS o SSH a su portapapeles mediante el botón azul “Clonar”.\n\n15.1.2 Bitbucket\nInicie sesión en https://bitbucket.org. En el panel del lado izquierdo, haga clic en el botón “+” y luego en “Repositorio” en “Crear”.\n\nNombre del repositorio: myrepo (o el que desees)\nNivel de acceso: desmarque para hacer público el repositorio.\n¿Incluir un archivo README?: seleccione “Sí, con un tutorial (para principiantes)” o “Sí, con una plantilla”.\nSistema de control de versiones: Git\n\nClick the big blue button “Create repository.”\nCopie la URL de clonación HTTPS o SSH que aparece al hacer clic en el botón azul “Clonar”. Asegúrate de eliminar el git clone... que aparece al principio.",
    "crumbs": [
      "Primeras victorias en GitHub",
      "<span class='chapter-number'>15</span>  <span class='chapter-title'>Nuevo proyecto, GitHub primero</span>"
    ]
  },
  {
    "objectID": "usage-new-project-github-first.html#sec-new-rstudio-project-via-git",
    "href": "usage-new-project-github-first.html#sec-new-rstudio-project-via-git",
    "title": "15  Nuevo proyecto, GitHub primero",
    "section": "\n15.2 Nuevo proyecto RStudio a través de git clone",
    "text": "15.2 Nuevo proyecto RStudio a través de git clone\n\n\n\n\n\n\n\n\nLes presento dos formas de hacer esto:\n\nusethis::create_from_github()\nA través del IDE de RStudio\n\n(Recuerde que mostramos cómo hacer esto con la línea de comando Git en Capítulo 11.)\nCuando clonas tu propio repositorio de GitHub, los dos métodos son equivalentes. En otros escenarios, especialmente fork-and-clone ((secfork-and-clone?)), creo que usethis::create_from_github() es superior, porque realiza una configuración adicional recomendada.\nElija uno de estos métodos a continuación.\n\n15.2.1 usethis::create_from_github()\n\nPuede ejecutar este comando en cualquier sesión de R. Si usa RStudio, hágalo en la consola R de cualquier instancia de RStudio.\n\nusethis::create_from_github(\n  \"https://github.com/YOU/YOUR_REPO.git\",\n  destdir = \"~/path/to/where/you/want/the/local/repo/\"\n)\n\nEl primer argumento es repo_spec y acepta la especificación del repositorio de GitHub en varias formas. En particular, puedes usar la URL que acabamos de copiar de GitHub.\nEl argumento destdir especifica el directorio principal donde desea que resida la nueva carpeta (y el repositorio local de Git). Si no especifica destdir, use este valor predeterminado en algún lugar muy visible, como su escritorio. Si desea mantener los repositorios de Git en una determinada carpeta de su computadora, puede personalizar este valor predeterminado configurando la opción usethis.destdir en su .Rprofile.\nAceptamos el comportamiento predeterminado de otros dos argumentos, rstudio y open, porque eso es lo que la mayoría de la gente querrá. Por ejemplo, para un usuario de RStudio, create_from_github() hace esto:\n\nCrea un nuevo directorio local en destdir, que contiene todas estas cosas:\n\nun directorio o carpeta en su computadora\nun repositorio Git, vinculado a un repositorio GitHub remoto\nun proyecto RStudio\n\n\nAbre una nueva instancia de RStudio en el nuevo Proyecto.\nEn ausencia de otras restricciones, sugiero que todos sus proyectos de R tengan exactamente esta configuración.\n\n15.2.2 RStudio IDE\nEn RStudio, inicie un nuevo proyecto:\n\n\nFile &gt; New Project &gt; Version Control &gt; Git. En la “URL del repositorio”, pegue la URL de su nuevo repositorio de GitHub. será algo como esto https://github.com/jennybc/myrepo.git.\nSea intencional acerca de dónde crea este proyecto.\nTe sugiero “Abrir en nueva sesión”.\nHaga clic en “Crear proyecto” para crear un nuevo directorio, que contendrá todas estas cosas:\n\nun directorio o “carpeta” en su computadora\nun repositorio Git, vinculado a un repositorio GitHub remoto\nun proyecto RStudio\n\n\nEn ausencia de otras limitaciones, sugiero que todos sus proyectos de R tengan exactamente esta configuración.\n\nEsto debería descargar el archivo README.md que creamos en GitHub en el paso anterior. Busque en el panel del explorador de archivos de RStudio el archivo README.md.\nDetrás de escena, RStudio ha hecho esto por usted:\ngit clone https://github.com/jennybc/myrepo.git\n\n15.2.3 Mira alrededor\nIndependientemente de si usó usethis o RStudio, ahora debería estar trabajando en el nuevo repositorio de Git. El git clone implícito debería descargar el archivo README.md que creamos en GitHub en el paso anterior. Busque en el panel del explorador de archivos de RStudio el archivo README.md.\nHay una gran ventaja en el flujo de trabajo “GitHub primero, luego RStudio”: el repositorio remoto de GitHub está configurado como el remoto origin para su repositorio local y su rama main local ahora está rastreando el main en GitHub. Este es un punto técnico pero importante sobre Git. La implicación práctica es que ahora está preparado para enviar e imporar. No es necesario perder el tiempo configurando controles remotos de Git y rastreando ramas en la línea de comando.\nEstamos a punto de confirmar que estamos preparados para realizar push and pulls.\n\n\nPull y push.\n\n\n15.2.4 Opcional: echar un vistazo debajo del capó\nActividad completamente opcional: use la línea de comando Git para ver de qué estamos hablando arriba, es decir, la configuración de la rama remota y de seguimiento.\ngit remote -v o git remote --verbose muestra los controles remotos que ha configurado. Así es como se ve alguien que usa HTTPS con GitHub y lo llama origin:\n~/tmp/myrepo % git remote -v\norigin  https://github.com/jennybc/myrepo.git (fetch)\norigin  https://github.com/jennybc/myrepo.git (push)\ngit branch -vv imprime información sobre la rama actual (-vv para “muy detallado”, supongo). En particular, podemos ver que el main local está rastreando la rama main en origin, también conocido como origin/main.\n~/tmp/myrepo % git branch -vv\n* main 2899c91 [origin/main] A commit from my local computer\nFinalmente, git remote show origin ofrece otra visión de información útil sobre ramas y remotos:\n~/tmp/myrepo % git remote show origin    \n* remote origin\n  Fetch URL: https://github.com/jennybc/myrepo.git\n  Push  URL: https://github.com/jennybc/myrepo.git\n  HEAD branch: main\n  Remote branch:\n    main tracked\n  Local branch configured for 'git pull':\n    main merges with remote main\n  Local ref configured for 'git push':\n    main pushes to main (up to date)\ngit clone, que RStudio hizo por nosotros, configura todo esto automáticamente. Es por eso que “Primero GitHub, luego RStudio” es la forma preferida de iniciar proyectos temprano en su vida de Git/GitHub.",
    "crumbs": [
      "Primeras victorias en GitHub",
      "<span class='chapter-number'>15</span>  <span class='chapter-title'>Nuevo proyecto, GitHub primero</span>"
    ]
  },
  {
    "objectID": "usage-new-project-github-first.html#realizar-cambios-locales-guardar-confirmar",
    "href": "usage-new-project-github-first.html#realizar-cambios-locales-guardar-confirmar",
    "title": "15  Nuevo proyecto, GitHub primero",
    "section": "\n15.3 Realizar cambios locales, guardar, confirmar",
    "text": "15.3 Realizar cambios locales, guardar, confirmar\nHaga esto cada vez que termine una parte valiosa del trabajo, probablemente muchas veces al día.\nDesde RStudio, modifique el archivo README.md, por ejemplo, agregando la línea “Esta es una línea de RStudio”. Guarde sus cambios.\nConfirme estos cambios en su repositorio local. ¿Cómo?\n\nHaga clic en la pestaña “Git” en el panel superior derecho\nMarque la casilla “Staged” para cualquier archivo cuya existencia o modificaciones desee confirmar.\n\nPara ver más detalles sobre los cambios en el archivo desde la última confirmación, haga clic en “Diff” para ver una ventana emergente de Git.\n\n\nSi aún no estás en la ventana emergente de Git, haz clic en “Commit”.\nEscriba un mensaje en “Commit message”, como “Commit from RStudio”.\nHaga clic en “Commit”",
    "crumbs": [
      "Primeras victorias en GitHub",
      "<span class='chapter-number'>15</span>  <span class='chapter-title'>Nuevo proyecto, GitHub primero</span>"
    ]
  },
  {
    "objectID": "usage-new-project-github-first.html#envía-tus-cambios-locales-a-github",
    "href": "usage-new-project-github-first.html#envía-tus-cambios-locales-a-github",
    "title": "15  Nuevo proyecto, GitHub primero",
    "section": "\n15.4 Envía tus cambios locales a GitHub",
    "text": "15.4 Envía tus cambios locales a GitHub\nHaga esto varias veces al día, pero posiblemente con menos frecuencia de lo que se confirme.\nTiene un nuevo trabajo en su repositorio Git local, pero los cambios aún no están en línea.\nEsto parecerá contradictorio, pero primero detengámonos y salgamos de GitHub.\n¿Por qué? ¡Establece este hábito para el futuro! Si realiza cambios en el repositorio en el navegador o desde otra máquina o (un día) un colaborador lo ha enviado, estará más feliz si realiza esos cambios antes de intentar enviar.\nHaga clic en el botón azul “Pull” en la pestaña “Git” en RStudio. Dudo que suceda algo, es decir, recibirás el mensaje “Already up-to-date”. Esto es sólo para establecer un hábito.\nHaga clic en el botón verde “Push” para enviar sus cambios locales a GitHub. RStudio informará algo como esto:\n&gt;&gt;&gt; /usr/bin/git push origin HEAD:refs/heads/main\nTo https://github.com/jennybc/myrepo.git\n   2899c91..b34cade  HEAD -&gt; main",
    "crumbs": [
      "Primeras victorias en GitHub",
      "<span class='chapter-number'>15</span>  <span class='chapter-title'>Nuevo proyecto, GitHub primero</span>"
    ]
  },
  {
    "objectID": "usage-new-project-github-first.html#confirmar-el-cambio-local-propagado-al-control-remoto-de-github",
    "href": "usage-new-project-github-first.html#confirmar-el-cambio-local-propagado-al-control-remoto-de-github",
    "title": "15  Nuevo proyecto, GitHub primero",
    "section": "\n15.5 Confirmar el cambio local propagado al control remoto de GitHub",
    "text": "15.5 Confirmar el cambio local propagado al control remoto de GitHub\nVuelve al navegador. Supongo que todavía estamos viendo su nuevo repositorio de GitHub.\nActualizar.\nDeberías ver el nuevo “Esta es una línea de RStudio” en el archivo README.\nSi hace clic en “commit”, debería ver uno con el mensaje “Commit from RStudio”.",
    "crumbs": [
      "Primeras victorias en GitHub",
      "<span class='chapter-number'>15</span>  <span class='chapter-title'>Nuevo proyecto, GitHub primero</span>"
    ]
  },
  {
    "objectID": "usage-new-project-github-first.html#haz-un-cambio-en-github",
    "href": "usage-new-project-github-first.html#haz-un-cambio-en-github",
    "title": "15  Nuevo proyecto, GitHub primero",
    "section": "\n15.6 Haz un cambio en GitHub",
    "text": "15.6 Haz un cambio en GitHub\nHaga clic en README.md en la lista de archivos en GitHub.\nEn la esquina superior derecha, haga clic en el lápiz para “Editar este archivo”.\nAgregue una línea a este archivo, como “Línea agregada desde GitHub”.\nEdite el mensaje de commit en “Confirmar cambios” o acepte el valor predeterminado.\nHaga clic en el gran botón verde “Confirmar cambios”.\n\n15.6.1 GitLab\nHaga clic en README.md en la lista de archivos en GitLab.\nEn la esquina superior derecha, haga clic en “Editar”.\nAgregue una línea a este archivo, como “Línea agregada desde GitLab”.\nEdite el mensaje de confirmación en “Confirmar cambios” o acepte el valor predeterminado.\nHaga clic en el gran botón verde “Confirmar cambios”.\n\n15.6.2 Bitbucket\nHaga clic en README.md en la lista de archivos de Bitbucket.\nEn la esquina superior derecha, haga clic en “Editar”.\nAgregue una línea a este archivo, como “Línea agregada desde Bitbucket”.\nHaga clic en el botón azul “Confirmar”. Aparecerá una ventana emergente. Edite el mensaje de confirmación o acepte el valor predeterminado.\nHaga clic en el botón azul “Confirmar”.",
    "crumbs": [
      "Primeras victorias en GitHub",
      "<span class='chapter-number'>15</span>  <span class='chapter-title'>Nuevo proyecto, GitHub primero</span>"
    ]
  },
  {
    "objectID": "usage-new-project-github-first.html#importar-de-github",
    "href": "usage-new-project-github-first.html#importar-de-github",
    "title": "15  Nuevo proyecto, GitHub primero",
    "section": "\n15.7 Importar de GitHub",
    "text": "15.7 Importar de GitHub\nDe vuelta en RStudio localmente…\nInspeccione su README.md. NO debería tener la línea “Línea agregada desde GitHub”. Debe quedar como lo dejaste. Comprueba eso.\nHaga clic en el botón azul Pull.\nMire README.md nuevamente. Ahora deberías ver la nueva línea allí.",
    "crumbs": [
      "Primeras victorias en GitHub",
      "<span class='chapter-number'>15</span>  <span class='chapter-title'>Nuevo proyecto, GitHub primero</span>"
    ]
  },
  {
    "objectID": "usage-new-project-github-first.html#el-fin",
    "href": "usage-new-project-github-first.html#el-fin",
    "title": "15  Nuevo proyecto, GitHub primero",
    "section": "\n15.8 El fin",
    "text": "15.8 El fin\nAhora simplemente “haga espuma, enjuague, repita”. Trabaje en algún lugar: localmente o en GitHub. Confirme los cambios. Envielos o importelos, dependiendo de dónde haya realizado el trabajo, pero “sincronice” local y remoto. Repetir.\nTenga en cuenta que, en general (y especialmente en el futuro, cuando colabore con otros desarrolladores), normalmente necesitará importar cambios desde el control remoto (GitHub) antes de enviar los cambios locales que ha realizado. Por esta razón, es una buena idea intentar adquirir el hábito de importar antes de intentar enviar.",
    "crumbs": [
      "Primeras victorias en GitHub",
      "<span class='chapter-number'>15</span>  <span class='chapter-title'>Nuevo proyecto, GitHub primero</span>"
    ]
  },
  {
    "objectID": "usage-existing-project-github-first.html",
    "href": "usage-existing-project-github-first.html",
    "title": "16  Proyecto existente, GitHub primero",
    "section": "",
    "text": "16.1 Haga un repositorio en GitHub\nEste es un flujo de trabajo amigable para principiantes para incorporar un proyecto R existente al universo RStudio y Git/GitHub.\nHacemos esto de una manera un poco tonta, para evitar usar Git en la línea de comando. No querrás trabajar de esta manera para siempre, ¡pero está perfectamente bien cuando comiences! Al principio, el objetivo principal es acumular algo de experiencia e impulso. No hay nada ridículo en el repositorio de GitHub que esto crea, es completamente estándar. Haga la transición a un proceso más elegante cuando esté listo.\nAsumimos que tiene su proyecto R existente aislado en un directorio de su computadora. Si eso aún no es cierto, hazlo así. Cree un directorio y reúna allí todos los datos y scripts R existentes. Realmente no importa dónde hagas esto, pero ten en cuenta dónde se encuentra actualmente el proyecto.\nVaya a https://github.com y asegúrese de haber iniciado sesión.\nCerca de “Repositorios”, haga clic en el gran botón verde “Nuevo”. O, si está en su propia página de perfil, haga clic en “Repositorios” y luego haga clic en el gran botón verde “Nuevo”.\nCómo completar esto:\nHaga clic en el gran botón verde que dice “Crear repositorio”.\nAhora haga clic en el gran botón verde que dice “&lt;&gt; Code”.\nCopie una URL clonada a su portapapeles. Si sigue nuestro consejo predeterminado, copie la URL HTTPS. Pero si opta por SSH, asegúrese de copiar la URL de SSH.",
    "crumbs": [
      "Primeras victorias en GitHub",
      "<span class='chapter-number'>16</span>  <span class='chapter-title'>Proyecto existente, GitHub primero</span>"
    ]
  },
  {
    "objectID": "usage-existing-project-github-first.html#haga-un-repositorio-en-github",
    "href": "usage-existing-project-github-first.html#haga-un-repositorio-en-github",
    "title": "16  Proyecto existente, GitHub primero",
    "section": "",
    "text": "Plantilla de repositorio: sin plantilla.\nNombre del repositorio: &lt;&lt;&gt;&gt;\n\nDescripción: &lt;&lt;&gt;&gt;\n\nPúblico.\n&lt;&lt;&gt;&gt;",
    "crumbs": [
      "Primeras victorias en GitHub",
      "<span class='chapter-number'>16</span>  <span class='chapter-title'>Proyecto existente, GitHub primero</span>"
    ]
  },
  {
    "objectID": "usage-existing-project-github-first.html#sec-git-clone-usethis-rstudio",
    "href": "usage-existing-project-github-first.html#sec-git-clone-usethis-rstudio",
    "title": "16  Proyecto existente, GitHub primero",
    "section": "\n16.2 Nuevo proyecto RStudio a través de git clone",
    "text": "16.2 Nuevo proyecto RStudio a través de git clone\n\n\n\n\n\n\n\n\nLes presento dos formas de hacer esto:\n\nusethis::create_from_github()\nA través del IDE de RStudio\n\n(Recuerde que mostramos cómo hacer esto con la línea de comando Git en Capítulo 11.)\nCuando clonas tu propio repositorio de GitHub, los dos métodos son equivalentes. En otros escenarios, especialmente fork-and-clone ((secfork-and-clone?)), creo que usethis::create_from_github() es superior, porque realiza una configuración adicional recomendada.\nElija uno de estos métodos a continuación.\n\n16.2.1 usethis::create_from_github()\n\nPuede ejecutar este comando en cualquier sesión de R. Si usa RStudio, hágalo en la consola R de cualquier instancia de RStudio.\n\nusethis::create_from_github(\n  \"https://github.com/YOU/YOUR_REPO.git\",\n  destdir = \"~/path/to/where/you/want/the/local/repo/\"\n)\n\nEl primer argumento es repo_spec y acepta la especificación del repositorio de GitHub en varias formas. En particular, puedes usar la URL que acabamos de copiar de GitHub.\nEl argumento destdir especifica el directorio principal donde desea que resida la nueva carpeta (y el repositorio local de Git). Si no especifica destdir, use este valor predeterminado en algún lugar muy visible, como su escritorio. Si desea mantener los repositorios de Git en una determinada carpeta de su computadora, puede personalizar este valor predeterminado configurando la opción usethis.destdir en su .Rprofile.\nAceptamos el comportamiento predeterminado de otros dos argumentos, rstudio y open, porque eso es lo que la mayoría de la gente querrá. Por ejemplo, para un usuario de RStudio, create_from_github() hace esto:\n\nCrea un nuevo directorio local en destdir, que contiene todas estas cosas:\n\nun directorio o carpeta en su computadora\nun repositorio Git, vinculado a un repositorio GitHub remoto\nun proyecto RStudio\n\n\nAbre una nueva instancia de RStudio en el nuevo Proyecto.\nEn ausencia de otras restricciones, sugiero que todos sus proyectos de R tengan exactamente esta configuración.\n\n16.2.2 RStudio IDE\nEn RStudio, inicie un nuevo proyecto:\n\n\nFile &gt; New Project &gt; Version Control &gt; Git. En la “URL del repositorio”, pegue la URL de su nuevo repositorio de GitHub. será algo como esto https://github.com/jennybc/myrepo.git.\nSea intencional acerca de dónde crea este proyecto.\nTe sugiero “Abrir en nueva sesión”.\nHaga clic en “Crear proyecto” para crear un nuevo directorio, que contendrá todas estas cosas:\n\nun directorio o “carpeta” en su computadora\nun repositorio Git, vinculado a un repositorio GitHub remoto\nun proyecto RStudio\n\n\nEn ausencia de otras limitaciones, sugiero que todos sus proyectos de R tengan exactamente esta configuración.\n\nEsto debería descargar el archivo README.md que creamos en GitHub en el paso anterior. Busque en el panel del explorador de archivos de RStudio el archivo README.md.\nDetrás de escena, RStudio ha hecho esto por usted:\ngit clone https://github.com/jennybc/myrepo.git",
    "crumbs": [
      "Primeras victorias en GitHub",
      "<span class='chapter-number'>16</span>  <span class='chapter-title'>Proyecto existente, GitHub primero</span>"
    ]
  },
  {
    "objectID": "usage-existing-project-github-first.html#traiga-su-proyecto-existente",
    "href": "usage-existing-project-github-first.html#traiga-su-proyecto-existente",
    "title": "16  Proyecto existente, GitHub primero",
    "section": "\n16.3 Traiga su proyecto existente",
    "text": "16.3 Traiga su proyecto existente\nUtilizando su método favorito para mover o copiar archivos, copie los archivos que constituyen su proyecto existente en el directorio de este nuevo proyecto.\nEn RStudio, consulte el panel de Git y el explorador de archivos.\n\n¿Estás viendo todos los archivos? Deberían estar aquí si su movimiento/copia fue exitoso.\n¿Aparecen en el panel de Git con signos de interrogación? Deberían aparecer como archivos nuevos sin seguimiento.",
    "crumbs": [
      "Primeras victorias en GitHub",
      "<span class='chapter-number'>16</span>  <span class='chapter-title'>Proyecto existente, GitHub primero</span>"
    ]
  },
  {
    "objectID": "usage-existing-project-github-first.html#verificar-y-confirmar",
    "href": "usage-existing-project-github-first.html#verificar-y-confirmar",
    "title": "16  Proyecto existente, GitHub primero",
    "section": "\n16.4 Verificar y confirmar",
    "text": "16.4 Verificar y confirmar\nConfirme sus archivos en este repositorio. ¿Cómo?\n\nHaga clic en la pestaña “Git” en el panel superior derecho\nMarque la casilla “Staged” para todos los archivos que desee confirmar.\n\nPredeterminado: verificado.\nCuándo reconsiderarlo: todo esto irá a GitHub. Considere si eso es apropiado para cada archivo. Puedes conservar absolutamente un archivo localmente, sin enviarlo al repositorio de Git y enviarlo a GitHub. Simplemente déjelo ahí en su panel de Git, sin que esté preparado. No se hará ningún daño. Si se trata de una situación a largo plazo, incluya el archivo en .gitignore.\n\n\nSi aún no estás en la ventana emergente de Git, haz clic en “Commit”.\nEscriba un mensaje en “Commit message”, como “Iniciar proyecto XYZ”.\nHaga clic en “Commit”",
    "crumbs": [
      "Primeras victorias en GitHub",
      "<span class='chapter-number'>16</span>  <span class='chapter-title'>Proyecto existente, GitHub primero</span>"
    ]
  },
  {
    "objectID": "usage-existing-project-github-first.html#envía-tus-cambios-locales-a-github",
    "href": "usage-existing-project-github-first.html#envía-tus-cambios-locales-a-github",
    "title": "16  Proyecto existente, GitHub primero",
    "section": "\n16.5 Envía tus cambios locales a GitHub",
    "text": "16.5 Envía tus cambios locales a GitHub\nHaga clic en el botón verde “Push” para enviar sus cambios locales a GitHub. RStudio mostrará algo como:\n&gt;&gt;&gt; /usr/bin/git push origin HEAD:refs/heads/main\nTo https://github.com/jennybc/myrepo.git\n   3a2171f..6d58539  HEAD -&gt; main",
    "crumbs": [
      "Primeras victorias en GitHub",
      "<span class='chapter-number'>16</span>  <span class='chapter-title'>Proyecto existente, GitHub primero</span>"
    ]
  },
  {
    "objectID": "usage-existing-project-github-first.html#confirmar-el-cambio-local-propagado-al-control-remoto-de-github",
    "href": "usage-existing-project-github-first.html#confirmar-el-cambio-local-propagado-al-control-remoto-de-github",
    "title": "16  Proyecto existente, GitHub primero",
    "section": "\n16.6 Confirmar el cambio local propagado al control remoto de GitHub",
    "text": "16.6 Confirmar el cambio local propagado al control remoto de GitHub\nVuelve al navegador. Supongo que todavía estamos viendo su nuevo repositorio de GitHub.\nActualice.\nDeberías ver todos los archivos del proyecto que confirmaste allí.\nSi hace clic en “commit”, debería ver uno con el mensaje que utilizó, p. “Iniciar proyecto XYZ”.",
    "crumbs": [
      "Primeras victorias en GitHub",
      "<span class='chapter-number'>16</span>  <span class='chapter-title'>Proyecto existente, GitHub primero</span>"
    ]
  },
  {
    "objectID": "usage-existing-project-github-first.html#el-fin",
    "href": "usage-existing-project-github-first.html#el-fin",
    "title": "16  Proyecto existente, GitHub primero",
    "section": "\n16.7 El fin",
    "text": "16.7 El fin\nAhora simplemente “haga espuma, enjuague, repita”. Trabaje en algún lugar: localmente o en GitHub. Confirme los cambios. Envielos o importelos, dependiendo de dónde haya realizado el trabajo, pero “sincronice” local y remoto. Repetir.\nTenga en cuenta que, en general (y especialmente en el futuro, cuando colabore con otros desarrolladores), normalmente necesitará importar cambios desde el control remoto (GitHub) antes de enviar los cambios locales que ha realizado. Por esta razón, es una buena idea intentar adquirir el hábito de importar antes de intentar enviar.",
    "crumbs": [
      "Primeras victorias en GitHub",
      "<span class='chapter-number'>16</span>  <span class='chapter-title'>Proyecto existente, GitHub primero</span>"
    ]
  },
  {
    "objectID": "usage-existing-project-github-last.html",
    "href": "usage-existing-project-github-last.html",
    "title": "17  Proyecto existente, GitHub último",
    "section": "",
    "text": "17.1 Preparar el proyecto local.\nEste es un flujo de trabajo explícito para conectar un proyecto R local existente a GitHub, cuando por alguna razón no puedes o no quieres realizar un flujo de trabajo “GitHub primero” (ver Capítulo 15) y ?sec-existing- github-primero).\n¿Cuándo surge esto? Ejemplo: es un proyecto existente que ya es un repositorio de Git con un historial que le interesa. Entonces tienes que hacer esto correctamente.\nEsto puede ser menos deseable para un principiante porque hay más oportunidades de confundirse y cometer un error. Pero este flujo de trabajo no es tan difícil, incluso con la línea de comandos de Git, y es aún más fácil si utiliza las comodidades del paquete usethis o el IDE de RStudio. Todos estos se tratan a continuación.\nAsumimos que tiene su proyecto R existente aislado en un directorio de su computadora. Si eso aún no es cierto, hazlo así. Cree un directorio y reúna allí todos los datos y scripts R existentes. Realmente no importa dónde hagas esto, pero ten en cuenta dónde se encuentra actualmente el proyecto.\nLe animo a que convierta este proyecto en un proyecto de RStudio, aunque no es absolutamente necesario. Si opta por no participar en esto, las instrucciones que usan la línea de comando Git o usethis seguirán funcionando para usted, fuera de RStudio.",
    "crumbs": [
      "Primeras victorias en GitHub",
      "<span class='chapter-number'>17</span>  <span class='chapter-title'>Proyecto existente, GitHub último</span>"
    ]
  },
  {
    "objectID": "usage-existing-project-github-last.html#preparar-el-proyecto-local.",
    "href": "usage-existing-project-github-last.html#preparar-el-proyecto-local.",
    "title": "17  Proyecto existente, GitHub último",
    "section": "",
    "text": "17.1.1 Realizar o verificar un Proyecto RStudio\nSi el proyecto aún no es un proyecto RStudio, hágalo así:\n\nDentro de RStudio puedes hacer: File &gt; New Project &gt; Existing Directory y, si lo deseas, “Abrir en nueva sesión”.\nAlternativamente, desde R, llame usethis::create_project(\"path/to/your/project\"), sustituyendo la ruta al directorio de su proyecto existente.\n\nSi su proyecto ya es un proyecto RStudio, ejecútelo.\n\n17.1.2 Crear o verificar un repositorio de Git\nDeberías estar en RStudio ahora, en tu proyecto.\n¿Ya es un repositorio de Git? La presencia del panel Git debería alertarte. Si es así, ya está.\nSi no, tienes varias opciones:\n\nEn la consola R, llame usethis::use_git().\nEn RStudio, vaya a Tools &gt; Project Options … &gt; Git/SVN. En “Sistema de control de versiones”, seleccione “Git”. ¿Confirmar el nuevo repositorio de Git? ¡Sí!\nEn el shell, con el directorio de trabajo configurado en el directorio del proyecto, haga git init.\n\nSi usó usethis o RStudio para inicializar el repositorio de Git, el proyecto debería reiniciarse en RStudio. Hágalo usted mismo si hizo git init. RStudio ahora debería tener un panel Git.",
    "crumbs": [
      "Primeras victorias en GitHub",
      "<span class='chapter-number'>17</span>  <span class='chapter-title'>Proyecto existente, GitHub último</span>"
    ]
  },
  {
    "objectID": "usage-existing-project-github-last.html#preparar-y-confirmar",
    "href": "usage-existing-project-github-last.html#preparar-y-confirmar",
    "title": "17  Proyecto existente, GitHub último",
    "section": "\n17.2 Preparar y confirmar",
    "text": "17.2 Preparar y confirmar\nSi su proyecto local ya era un repositorio de Git y estaba actualizado, continúe. De lo contrario, probablemente necesites preparar y confirmar.\n\nHaga clic en la pestaña “Git” en el panel superior derecho\nMarque la casilla “Staged” para todos los archivos que desee confirmar.\n\nPredeterminado: organizar todo\nCuándo hacer lo contrario: todo esto irá a GitHub. Así que considere si eso es apropiado para cada archivo. Puedes conservar absolutamente un archivo localmente, sin enviarlo al repositorio de Git y enviarlo a GitHub. Simplemente déjelo reposar en su panel Git, sin que esté preparado. No se hará ningún daño. Si se trata de una situación a largo plazo, incluya el archivo en .gitignore.\n\n\nSi aún no estás en la ventana emergente de Git, haz clic en “Commit”\nEscribe un mensaje en “Commit message”.\nHaga click en “Commit”",
    "crumbs": [
      "Primeras victorias en GitHub",
      "<span class='chapter-number'>17</span>  <span class='chapter-title'>Proyecto existente, GitHub último</span>"
    ]
  },
  {
    "objectID": "usage-existing-project-github-last.html#crear-y-conectar-un-repositorio-de-github",
    "href": "usage-existing-project-github-last.html#crear-y-conectar-un-repositorio-de-github",
    "title": "17  Proyecto existente, GitHub último",
    "section": "\n17.3 Crear y conectar un repositorio de GitHub",
    "text": "17.3 Crear y conectar un repositorio de GitHub\nMostraremos algunos métodos para crear un nuevo repositorio de GitHub y conectarlo a su repositorio local. Elegir uno.\n\n17.3.1 Cree y conecte un repositorio de GitHub con usethis\nPara utilizar usethis para esta tarea, debe haber configurado un token de acceso personal (PAT). Esto ya estará configurado para cualquiera que use HTTPS como protocolo, porque ya están usando PAT para autenticarse para otras operaciones de Git. Pero si eres una persona SSH, necesitarás configurar un PAT, lo cual se explica en Capítulo 9. Está bien tener claves PAT y SSH.\nEn su proyecto, en la Consola R, llame a:\n\nusethis::use_github()\n#&gt; ✓ Creating GitHub repository 'jennybc/myrepo'\n#&gt; ✓ Setting remote 'origin' to 'https://github.com/jennybc/myrepo.git'\n#&gt; ✓ Pushing 'main' branch to GitHub and setting 'origin/main' as upstream branch\n#&gt; ✓ Opening URL 'https://github.com/jennybc/myrepo'\n\n\n\n\n\nusethis::use_github() hace lo siguiente:\n\nCrea un nuevo repositorio en GitHub.\nConfigura ese nuevo repositorio como el remoto origin para el repositorio local.\nConfigura tu rama local predeterminada (por ejemplo, main) para rastrear la misma en origin y realiza un envío inicial.\nAbre el nuevo repositorio en tu navegador.\n\n17.3.2 Cree y conecte un repositorio de GitHub sin usar esto\nPrimero, necesitas crear un nuevo repositorio en GitHub.\nVaya a https://github.com y asegúrese de haber iniciado sesión.\nCerca de “Repositorios”, haga clic en el gran botón verde “Nuevo”. O, si está en su propia página de perfil, haga clic en “Repositorios” y luego haga clic en el gran botón verde “Nuevo”.\nCómo completar esto:\n\nPlantilla de repositorio: sin plantilla.\nNombre del repositorio: &lt;&lt;&gt;&gt;\n\nDescripción: &lt;&lt;&gt;&gt;\n\nPúblico.\n&lt;&lt;&gt;&gt;\n\n\nHaga clic en el gran botón verde que dice “Crear repositorio”.\nAhora haga clic en el gran botón verde que dice “&lt;&gt; Code”.\nCopie una URL clonada a su portapapeles. Si sigue nuestro consejo predeterminado, copie la URL HTTPS. Pero si opta por SSH, asegúrese de copiar la URL de SSH.\n\n\n\n\n\n\n\n\n\n17.3.2.1 Conecte el repositorio local al repositorio de GitHub con RStudio\nHaga clic en “dos cuadros morados y un cuadrado blanco” en el panel de Git. Haga clic en “Add remote”. Pegue aquí la URL del repositorio de GitHub y elija un nombre remoto, casi con seguridad origin. Ahora “Add”.\nDeberíamos volver al cuadro de diálogo “New branch” (si no, haga clic nuevamente en “dos cuadros morados y un cuadrado blanco” en el panel de Git). Supongo que estás en la rama main y quieres que rastree main en GitHub (o cualquier rama predeterminada que estés usando). Ingrese main como nombre de la rama y asegúrese de que “Sync branch with remote” esté marcado. Haga clic en “Create” (sí, aunque la rama ya existe). En el siguiente cuadro de diálogo, elija “overwrite”.\n\n17.3.2.2 Conecte el repositorio local al repositorio de GitHub con la línea de comando\nEn un shell, haz esto, sustituyendo tu URL:\ngit remote add origin https://github.com/jennybc/myrepo.git\nEnvie y consolide la relación de seguimiento entre su rama main local y main en GitHub (o como se llame su rama predeterminada):\ngit push --set-upstream origin main",
    "crumbs": [
      "Primeras victorias en GitHub",
      "<span class='chapter-number'>17</span>  <span class='chapter-title'>Proyecto existente, GitHub último</span>"
    ]
  },
  {
    "objectID": "usage-existing-project-github-last.html#confirme-los-archivos-locales-propagados-al-control-remoto-de-github",
    "href": "usage-existing-project-github-last.html#confirme-los-archivos-locales-propagados-al-control-remoto-de-github",
    "title": "17  Proyecto existente, GitHub último",
    "section": "\n17.4 Confirme los archivos locales propagados al control remoto de GitHub",
    "text": "17.4 Confirme los archivos locales propagados al control remoto de GitHub\nVuelve al navegador. Supongo que todavía estamos viendo su nuevo repositorio de GitHub.\nActualizar.\nDeberías ver todos los archivos del proyecto que confirmaste allí.\nSi este proyecto ya tenía un historial de Git, debería reflejarse en GitHub.",
    "crumbs": [
      "Primeras victorias en GitHub",
      "<span class='chapter-number'>17</span>  <span class='chapter-title'>Proyecto existente, GitHub último</span>"
    ]
  },
  {
    "objectID": "usage-existing-project-github-last.html#el-fin",
    "href": "usage-existing-project-github-last.html#el-fin",
    "title": "17  Proyecto existente, GitHub último",
    "section": "\n17.5 El fin",
    "text": "17.5 El fin\nAhora simplemente “haga espuma, enjuague, repita”. Trabaje en algún lugar: localmente o en GitHub. Confirme los cambios. Envielos o importelos, dependiendo de dónde haya realizado el trabajo, pero “sincronice” local y remoto. Repetir.\nTenga en cuenta que, en general (y especialmente en el futuro, cuando colabore con otros desarrolladores), normalmente necesitará importar cambios desde el control remoto (GitHub) antes de enviar los cambios locales que ha realizado. Por esta razón, es una buena idea intentar adquirir el hábito de importar antes de intentar enviar.",
    "crumbs": [
      "Primeras victorias en GitHub",
      "<span class='chapter-number'>17</span>  <span class='chapter-title'>Proyecto existente, GitHub último</span>"
    ]
  },
  {
    "objectID": "usage-rmd-and-github.html",
    "href": "usage-rmd-and-github.html",
    "title": "18  Prueba de R Markdown",
    "section": "",
    "text": "18.1 Hola Mundo\nCrearemos un documento R Markdown y lo representaremos en HTML. Analizamos cómo conservar el archivo Markdown intermedio, las cifras y qué enviar a Git y enviar a GitHub. Si GitHub es el lugar principal, renderizamos directamente en rebajas con sabor a GitHub y nunca creamos HTML.\nAquí está la documentación oficial de R Markdown: http://rmarkdown.rstudio.com\nPracticaremos con el documento estándar R Markdown de RStudio.\nInicie RStudio en un proyecto que sea un repositorio de Git que esté conectado a un repositorio de GitHub.\nAquí estamos modelando “caminar antes de correr”. Es mejor aumentar la complejidad en pequeños incrementos. Probamos la capacidad de nuestro sistema para representar el “hola mundo” de los documentos de R Markdown antes de enturbiar las aguas con nuestros documentos, que probablemente tienen errores.\nHaz esto: File &gt; New File &gt; R Markdown …\nGuarde este documento en un nombre de archivo y ubicación razonables. El nombre del archivo debe terminar en .Rmd o .rmd. Guarde en el nivel superior de este proyecto RStudio y en el repositorio Git, que también es el directorio de trabajo actual. Confía en mí y hazlo por un tiempo.\nQuizás quieras realizar un commit en este punto. Eso te ayudará a ver exactamente qué está sucediendo con tus archivos, porque aparecerá como una “diferencia” en el panel de Git. Hacer que los cambios sean muy visibles es uno de los grandes beneficios de usar Git.\nHaga clic en “Knit HTML” o haga File &gt; Knit Document. RStudio debería mostrar una vista previa del HTML resultante. Mire también el explorador de archivos. Debería ver el documento original de R Markdown, es decir, foo.Rmd Y el HTML resultante foo.html.\nFelicitaciones, acaba de realizar su primer informe reproducible con R Markdown.\nEste es otro buen momento para realizar cambios.",
    "crumbs": [
      "Primeras victorias en GitHub",
      "<span class='chapter-number'>18</span>  <span class='chapter-title'>Prueba de R Markdown</span>"
    ]
  },
  {
    "objectID": "usage-rmd-and-github.html#hola-mundo",
    "href": "usage-rmd-and-github.html#hola-mundo",
    "title": "18  Prueba de R Markdown",
    "section": "",
    "text": "Ponle un título informativo. Esto aparecerá en el documento pero no necesariamente tiene nada que ver con el nombre del archivo. ¡Pero el título y el nombre del archivo deberían estar relacionados! ¿Por qué confundirse? El título es para ojos humanos, por lo que puede contener espacios y puntuación. El nombre del archivo es para humanos y computadoras, por lo que debe tener palabras similares, pero sin espacios ni puntuación.\nAcepte el Autor predeterminado o edítelo si lo desea.\nAcepte el formato de salida predeterminado de HTML.\nHaga clic en Aceptar.",
    "crumbs": [
      "Primeras victorias en GitHub",
      "<span class='chapter-number'>18</span>  <span class='chapter-title'>Prueba de R Markdown</span>"
    ]
  },
  {
    "objectID": "usage-rmd-and-github.html#enviar-a-github",
    "href": "usage-rmd-and-github.html#enviar-a-github",
    "title": "18  Prueba de R Markdown",
    "section": "18.2 Enviar a GitHub",
    "text": "18.2 Enviar a GitHub\nEnvíe el estado actual a GitHub.\nVe a visitarlo en el navegador.\n¿Ves los nuevos archivos? ¿Un documento R Markdown y el HTML asociado? Visita ambos en el navegador. Verifica esto:\n\nRmd es bastante legible. Pero el resultado obviamente no está ahí.\nHTML es feo.",
    "crumbs": [
      "Primeras victorias en GitHub",
      "<span class='chapter-number'>18</span>  <span class='chapter-title'>Prueba de R Markdown</span>"
    ]
  },
  {
    "objectID": "usage-rmd-and-github.html#sec-output-format",
    "href": "usage-rmd-and-github.html#sec-output-format",
    "title": "18  Prueba de R Markdown",
    "section": "18.3 Formato de salida",
    "text": "18.3 Formato de salida\n¿Realmente quieres HTML? ¿Solo quieres HTML? ¿Estás absolutamente seguro? Si es así, ¡puedes saltarte este paso!\nEl proceso mágico que convierte tu R Markdown en HTML es el siguiente:\nfoo.Rmd --&gt; foo.md --&gt; foo.html\nTenga en cuenta el markdow, foo.md. De forma predeterminada, RStudio descarta esto, ¡pero es posible que desees conservar ese archivo markdow!\n¿Por qué? GitHub brinda un tratamiento muy especial a los archivos markdow. Se representan casi como HTML. Esto es genial porque conserva todos los encantos del texto plano, pero te ofrece una pseudopágina web gratuita cuando visitas el archivo en el navegador. Por el contrario, HTML se representa como texto sin formato en GitHub y tendrás que tomar medidas especiales para verlo como deseas.\nEn muchos casos, solo deseas el markdown. En ese caso, cambiamos el formato de salida a github_document. Esto significa que el renderizado se verá así:\nfoo.Rmd --&gt; foo.md\ndonde foo.md es un markdown con sabor a GitHub. Si aún desea el HTML pero también el markdown intermedia, también hay una manera de solicitarlo.\nEste punto que estamos señalando sobre la importancia de los archivos .md es la razón por la que tantos paquetes R tienen un archivo NEWS.md y README.md, a menudo generados a partir de README.Rmd.\nEl formato de salida es una de las muchas cosas que podemos controlar en la parte frontal YAML de los documentos .Rmd, es decir, el texto en la parte superior de su archivo entre las líneas iniciales y finales de ---.\nPuede realizar algunos cambios en YAML a través del IDE de RStudio: haga clic en el “engranaje” en la barra superior del editor de código fuente, cerca del botón “Knit HTML”. Seleccione “Opciones de salida”, vaya a la pestaña Avanzado y marque “Mantener archivo markdown”. Su YAML ahora debería parecerse más a esto:\n---\ntitle: \"Something fascinating\"\nauthor: \"Jenny Bryan\"\ndate: \"`r format(Sys.Date())`\"\noutput:\n  html_document:\n    keep_md: true\n---\nDeberías haber obtenido la línea keep_md: true. También puedes simplemente editar el archivo tú mismo para lograrlo. El IDE solo expone una pequeña fracción de lo que es posible configurar en YAML.\nDe hecho, es necesaria una edición manual si desea mantener solo el markdown y obtener un markdown con sabor a GitHub. En ese caso, haz que tu YAML se vea así:\n---\ntitle: \"Something fascinating\"\nauthor: \"Jenny Bryan\"\ndate: \"`r format(Sys.Date())`\"\noutput: github_document\n---\n¡Guardar!\nQuizás quieras realizar un commit en este punto.\nRenderizar mediante el botón “Knit HTML”.\nAhora vuelva a visitar el explorador de archivos. Además de foo.Rmd, ahora deberías ver foo.md. Si hay fragmentos de R que forman figuras, el uso de formatos de salida de rebajas también hará que esos archivos de figuras queden en un subdirectorio con un nombre sensato, como foo_files.\nSi confirma y presiona foo.md y todo lo que está dentro de foo_files, cualquiera que tenga permiso para ver su repositorio de GitHub podrá ver una versión decente de su informe.\nSi su formato de salida es html_document, aún debería ver foo.html. Si su formato de salida es github_document y ve foo.html, eso es un resto de experimentos anteriores. Borra eso. Sólo te confundirá más tarde.\nQuizás quieras realizar un commit aquí.",
    "crumbs": [
      "Primeras victorias en GitHub",
      "<span class='chapter-number'>18</span>  <span class='chapter-title'>Prueba de R Markdown</span>"
    ]
  },
  {
    "objectID": "usage-rmd-and-github.html#enviar-a-github-1",
    "href": "usage-rmd-and-github.html#enviar-a-github-1",
    "title": "18  Prueba de R Markdown",
    "section": "18.4 Enviar a GitHub",
    "text": "18.4 Enviar a GitHub\nEnvíe el estado actual a GitHub.\nVe a visitarlo en el navegador.\n¿Ves las modificaciones y los nuevos archivos? Su .Rmd debería modificarse, es decir, debería ver los cambios que realizó en el frontmatter de YAML. Y debería haber obtenido, al menos, el archivo de rebajas asociado, foo.md.\n\nVisite el archivo markdown y compárelo con nuestro HTML anterior.\n¿Ves cómo el markdown es mucho más útil directamente en GitHub? Interioriza esta lección.",
    "crumbs": [
      "Primeras victorias en GitHub",
      "<span class='chapter-number'>18</span>  <span class='chapter-title'>Prueba de R Markdown</span>"
    ]
  },
  {
    "objectID": "usage-rmd-and-github.html#ponle-tu-sello",
    "href": "usage-rmd-and-github.html#ponle-tu-sello",
    "title": "18  Prueba de R Markdown",
    "section": "18.5 Ponle tu sello",
    "text": "18.5 Ponle tu sello\nSeleccione todo menos el frontmatter YAML y… ¡bórrelo!\nEscribe una sola oración.\nInserte un fragmento de R vacío, a través del menú “Chunk” en la parte superior derecha del editor de código fuente o con el método abreviado de teclado correspondiente.\n```{r, eval=TRUE}`r ''`\n## inserte su brillante código aquí\n```\nInserta de 1 a 3 líneas de código funcional que sea relevante para ti o para el proyecto donde estás experimentando. “Recorre” y ejecuta esas líneas usando el botón “Ejecutar” o el método abreviado de teclado correspondiente. ¡DEBES asegurarte de que tu código realmente funcione!\n¿Satisfecho? ¡Guarde!\nQuizás quieras realizar un commit aquí.\nAhora renderice todo el documento mediante “Knit HTML”. ¡Voilá!\nQuizás quieras realziar un commit aquí. Y enviar. Y admire su progreso en GitHub.",
    "crumbs": [
      "Primeras victorias en GitHub",
      "<span class='chapter-number'>18</span>  <span class='chapter-title'>Prueba de R Markdown</span>"
    ]
  },
  {
    "objectID": "usage-rmd-and-github.html#desarrolla-tu-informe",
    "href": "usage-rmd-and-github.html#desarrolla-tu-informe",
    "title": "18  Prueba de R Markdown",
    "section": "18.6 Desarrolla tu informe",
    "text": "18.6 Desarrolla tu informe\nDe esta manera incremental, desarrolle su informe. Agregue código a este fragmento. Refinelo. Agrega nuevos trozos. Pero siga ejecutando el código “manualmente” para asegurarse de que realmente funcione.\nSi el código no funciona, puedo garantizarle que fallará, de una manera más espectacular y críptica, cuando se ejecute con los brazos extendidos a través de “Knit HTML” o rmarkdown::render().\nLimpie su espacio de trabajo, reinicie R y vuelva a ejecutar todo periódicamente, si las cosas se ponen raras. Hay muchos elementos de menú fragmentados y atajos de teclado para acelerar este flujo de trabajo. Represente todo el documento con frecuencia para detectar errores cuando sean fáciles de identificar y corregir. Guarde con frecuencia y confirme cada vez que llegue a un punto que desee como posición de “retroceso”.\nPronto desarrollarás tu propio mojo, pero esto debería brindarte tu primera experiencia exitosa con R Markdown.",
    "crumbs": [
      "Primeras victorias en GitHub",
      "<span class='chapter-number'>18</span>  <span class='chapter-title'>Prueba de R Markdown</span>"
    ]
  },
  {
    "objectID": "usage-rmd-and-github.html#publica-tu-informe",
    "href": "usage-rmd-and-github.html#publica-tu-informe",
    "title": "18  Prueba de R Markdown",
    "section": "18.7 Publica tu informe",
    "text": "18.7 Publica tu informe\nSi ha estado creando HTML, puede publicarlo en algún lugar de la web, enviarlo por correo electrónico a su colaborador, lo que sea.\nPase lo que pase, técnicamente puedes publicar este informe simplemente enviando una versión renderizada a GitHub. Sin embargo, ciertas prácticas hacen que este esfuerzo de publicación sea más satisfactorio para su audiencia.\nAquí hay dos comportamientos que encuentro muy frustrantes:\n\n“Aquí está mi código. He aquí”. Esto es cuando alguien solo publica su fuente, es decir, R Markdown o código R, Y realmente quiere que otras personas aprecien su “producto”. La suposición implícita es que el público objetivo descargará todos los datos y el código y los ejecutará localmente.\n“Aquí está mi HTML. He aquí”. Esto es cuando alguien acepta la salida predeterminada solo HTML. Recuerde, los humanos no pueden leer los archivos HTML en GitHub. Por lo tanto, la suposición implícita es que el público objetivo descargará el repositorio y apuntará su navegador a este archivo HTML para poder verlo. ¿HTML en GitHub? No es legible por humanos.\n\nA veces es muy poco realista esperar que su audiencia tome las medidas adicionales descritas anteriormente. A menudo, con un cambio muy pequeño por tu parte, puedes crear un artefacto en GitHub que tu público objetivo puede apreciar de inmediato.\nCrear, confirmar y enviar markdowns (es decir, archivos .md) es una estrategia de publicación muy funcional y liviana. Utilice output: github_document o, si la salida es html_document, agregue keep_md: true. En ambos casos, es fundamental confirmar y enviar todo lo que esté dentro de foo_files, es decir, cualquier figura que se haya creado. Ahora la gente puede visitar y consumir tu trabajo en GitHub, como cualquier otra página web.\nEste es (más o menos) otro ejemplo de un principio generalmente válido, que es mantener las cosas legibles por máquinas y humanos, siempre que sea posible. Al hacer que foo.Rmd esté disponible, otros pueden ver y ejecutar su código real. Al compartir también foo.md y/o foo.html, otros pueden explorar casualmente su producto final y decidir si quieren obtener y ejecutar el código.",
    "crumbs": [
      "Primeras victorias en GitHub",
      "<span class='chapter-number'>18</span>  <span class='chapter-title'>Prueba de R Markdown</span>"
    ]
  },
  {
    "objectID": "usage-rmd-and-github.html#html-en-github",
    "href": "usage-rmd-and-github.html#html-en-github",
    "title": "18  Prueba de R Markdown",
    "section": "18.8 HTML en GitHub",
    "text": "18.8 HTML en GitHub\nLos archivos HTML, como foo.html, no son útiles de inmediato en GitHub (aunque sus versiones locales se pueden ver fácilmente). Visita uno y verás el HTML sin formato. Qué asco. Pero hay formas de obtener una vista previa: como http://htmlpreview.github.io. Espere mucho dolor con los archivos HTML dentro de repositorios privados (de ahí las recomendaciones anteriores para enfatizar la reducción). Cuando se vuelve vital para todo el mundo ver HTML adecuado en todo su esplendor, es hora de utilizar una estrategia de publicación web más sofisticada.\nTengo más ideas generales sobre cómo hacer que un repositorio de GitHub funcione como un sitio web.",
    "crumbs": [
      "Primeras victorias en GitHub",
      "<span class='chapter-number'>18</span>  <span class='chapter-title'>Prueba de R Markdown</span>"
    ]
  },
  {
    "objectID": "usage-rmd-and-github.html#sec-rmd-troubleshooting",
    "href": "usage-rmd-and-github.html#sec-rmd-troubleshooting",
    "title": "18  Prueba de R Markdown",
    "section": "18.9 Solución de problemas",
    "text": "18.9 Solución de problemas\nAsegúrese de que RStudio y el paquete rmarkdown (y sus dependencias) estén actualizados. En caso de una falla catastrófica al renderizar el documento estándar de R Markdown, considere que su software puede ser demasiado antiguo. Detalles sobre el sistema utilizado para representar este documento y cómo verificar su configuración:\n\nversión rmarkdown r packageVersion(\"rmarkdown\"). Usar packageVersion(\"rmarkdown\") para comprobar el tuyo.\nr R.version.string. Usar R.version.string para comprobar el tuyo.\nRStudio IDE 2021.9.0.341 (“Ghost Orchid” Preview). Use RStudio &gt; About RStudio o RStudio.Version()$version para comprobar el tuyo.\n\nDeshazte de tu .Rprofile, por lo menos temporalmente. He descubierto que un .Rprofile “maduro” que se ha acumulado al azar a lo largo de los años puede causar problemas. Específicamente, si tiene algo relacionado con knitr, markdown, rmarkdown o el propio RStudio, es posible que esté impidiendo la instalación o el uso de los beneficios más recientes. Comente todo el archivo o cámbiele el nombre a otro y reinicie o incluso reinstale RStudio.\n“Ignoré tu consejo y agregué un montón de código a la vez. Ahora mi Rmd no se procesa.” Si no puedes descubrir qué está mal leyendo los mensajes de error, elige uno:\n\nBElimine estos cambios, vuelva a un estado funcional (posiblemente sin código) y restáurelos gradualmente. Ejecute su código de forma interactiva para asegurarse de que funcione. Renderice el documento completo con frecuencia. ¡Confirme después de cada adición exitosa! Cuando vuelvas a introducir el código roto, ahora será parte de un pequeño cambio y la raíz del problema será mucho más fácil de identificar y solucionar.\nDígale a knitr que siga adelante, incluso en presencia de errores. Algunos problemas son más fáciles de diagnosticar si puede ejecutar declaraciones R específicas durante el renderizado y dejar más evidencia para el examen forense.\n\nInserta este trozo cerca de la parte superior de tu documento .Rmd:\n```{r setup, include = FALSE, cache = FALSE}`r ''`\nknitr::opts_chunk$set(error = TRUE)\n```\nSi no es deseable aceptar errores globalmente, aún puedes especificar error = TRUE para un fragmento específico como este:\n```{r wing-and-a-prayer, error = TRUE}`r ''`\n## tu código incompleto va aquí ;)\n```\n\nAdaptar la estrategia “git bisect”:\n\nColoque knitr::knit_exit() en algún lugar temprano de su documento .Rmd, ya sea en código R en línea o en un fragmento. Continúe moviéndolo antes hasta que todo funcione. Ahora muévalo hacia abajo en el documento. Con el tiempo, podrá limitar la ubicación de su código roto lo suficiente como para encontrar las líneas y solucionarlo.\n\n\nConsulta tu directorio de trabajo. Te romperá el corazón saber con qué frecuencia tus errores son realmente mundanos y básicos. Pregúntame cómo lo sé. Cuando las cosas van mal, considere:\n\n¿Qué es el directorio de trabajo?\n¿Ese archivo que quiero leer/escribir está realmente donde creo que está?\n\nColoque estos comandos en fragmentos de R para comprobar lo anterior:\n\ngetwd() mostrará el directorio de trabajo en tiempo de ejecución. Si jugó con el directorio de trabajo con, por ejemplo, el mouse, ¿tal vez esté configurado en un lugar para su desarrollo interactivo y en otro cuando “Knit HTML” se haga cargo?\nlist.files() enumerará los archivos en el directorio de trabajo. ¿El archivo que deseas está ahí?\n\nNo intente cambiar el directorio de trabajo dentro de un documento de R Markdown. Simplemente no lo hagas. Ver Preguntas frecuentes sobre knitr #5. Esos es todo.\nNo tenga prisa por crear una estructura de subdirectorios complicada. RStudio/knitr/rmarkdown (que le ofrece el botón “Knit HTML”) son bastante obstinados acerca de que el directorio de trabajo se establezca en la ubicación archivo .Rmd y sobre todos los archivos que viven juntos en un gran directorio feliz. Todo esto se puede solucionar. Por ejemplo, recomiendo el paquete here para crear rutas de archivos, una vez que necesite subdirectorios. Pero no hagas esto hasta que realmente lo necesites.",
    "crumbs": [
      "Primeras victorias en GitHub",
      "<span class='chapter-number'>18</span>  <span class='chapter-title'>Prueba de R Markdown</span>"
    ]
  },
  {
    "objectID": "usage-r-script-and-github.html",
    "href": "usage-r-script-and-github.html",
    "title": "19  Renderizar un script R",
    "section": "",
    "text": "19.1 Transforme RMarkdown en un script R renderizable\nUn hecho subestimado es que mucho de lo que puedes hacer con R Markdown, también puedes hacerlo con un script R.\nSi está en modo de análisis y desea un informe como efecto secundario, escriba un script R. Si está escribiendo un informe con mucho código R, escriba .Rmd. En cualquier caso, renderice en Markdown y/o HTML para comunicarse con otros seres humanos.\nContinuará especificando cosas como el formato de salida a través de YAML en la parte superior del archivo. Esto deberá comentarse con #'.\nConsiga un archivo RMarkdown que funcione, como el que creó en su prueba de Rmd. O utilice el documento estándar .Rmd que RStudio crea con File &gt; New File &gt; R Markdown ….\nGuarde el archivo como foo.R, en lugar de foo.Rmd. Sí, por un breve momento, tendrás R Markdown guardado como un script R, pero eso no será así por mucho tiempo.\nTransforme RMarkdown a R:\nRenderice el script R a través de uno de estos métodos:\nObtendrá un informe de markdown y/o HTML, al igual que con R Markdown.\nSi tiene problemas para realizar todos los cambios necesarios y se siente frustrado, vea a continuación un ejemplo que puede copiar y pegar.\nTodos los consejos de flujo de trabajo de la prueba de Rmd se aplican aquí: cuando escriba un script de un análisis, preséntelo en markdown, confirme el .R, el .md, cualquier figura asociada y envíelo a GitHub. Los colaboradores pueden ver su código, pero también explorar los resultados sin tener que descargar y ejecutar el código. Esto hace que el estado actual de su análisis sea accesible para alguien que ni siquiera ejecuta R o que quiere echar un vistazo rápido a las cosas desde un teléfono celular o mientras está de vacaciones.",
    "crumbs": [
      "Primeras victorias en GitHub",
      "<span class='chapter-number'>19</span>  <span class='chapter-title'>Renderizar un script R</span>"
    ]
  },
  {
    "objectID": "usage-r-script-and-github.html#transforme-rmarkdown-en-un-script-r-renderizable",
    "href": "usage-r-script-and-github.html#transforme-rmarkdown-en-un-script-r-renderizable",
    "title": "19  Renderizar un script R",
    "section": "",
    "text": "¿Algo que no sea código R? ¿Te gusta el YAML y la prosa? Protégelo con comentarios estilo roxygen: comienza cada línea con #'.\n\n¿Algo que sea código R? Déjelo existir “tal cual” como código de nivel superior. Eso significa que necesitarás cambiar la sintaxis de los encabezados de fragmentos de R de esta manera:\nAntes: ```{r setup, include = FALSE}\nDespués: #+ r setup, include = FALSE\nReemplace las comillas invertidas iniciales y la llave de apertura con #+.\nEliminar la llave final.\nElimina las 3 comillas invertidas que finalizan cada fragmento.\n\n\n\n\nHaga clic en el icono “notebook” en RStudio para “Compile Report”.\nEn RStudio, haga File &gt; Knit Document.\nEn R, ejecute rmarkdown::render(\"foo.R\").",
    "crumbs": [
      "Primeras victorias en GitHub",
      "<span class='chapter-number'>19</span>  <span class='chapter-title'>Renderizar un script R</span>"
    ]
  },
  {
    "objectID": "usage-r-script-and-github.html#escribir-un-script-r-listo-para-renderizar",
    "href": "usage-r-script-and-github.html#escribir-un-script-r-listo-para-renderizar",
    "title": "19  Renderizar un script R",
    "section": "\n19.2 Escribir un script R listo para renderizar",
    "text": "19.2 Escribir un script R listo para renderizar\nEn lugar de transformar un archivo RMarkdown, creemos directamente un script R listo para renderizar.\nCree un nuevo script R y copie/pegue este código en él.\n\n#' Aquí hay algo de prosa en un comentario muy especial. Resumamos el conjunto de datos integrado `VADeaths`.\n# Aquí hay un comentario de código normal, que permanecerá como tal.\nsummary(VADeaths)\n\n#' Aquí hay algo más de prosa. Puedo usar la sintaxis habitual de Markdown para hacer cosas\n#' **negritas** o *italicas*. Usemos un ejemplo de la ayuda `dotchart()` para\n#' hacer un diagrama de puntos de Cleveland a partir de los datos de `VADeaths`. Incluso me molesto en nombrar\n#' este fragmento, entonces el PNG resultante tiene un nombre decente.\n#+ dotchart\ndotchart(VADeaths, main = \"Tasas de mortalidad en Virginia - 1940\")\n\nRenderice el script R mediante uno de estos métodos:\n\nHaga clic en el icono “notebook” en RStudio para “Compile Report”.\nEn RStudio, haz File &gt; Knit Document.\nEn R, haz rmarkdown::render(\"YOURSCRIPT.R\").\n\n¡Disfruta de tu atractivo informe casi sin esfuerzo! En serio, todo lo que tenías que hacer era pensar en cuándo usar los comentarios especiales #' para promocionarlo a un texto bien renderizado.\nBasándonos en los consejos de flujo de trabajo en Prueba de Rmd, agreguemos algo de contenido de YAML, comentado adecuadamente con #', y solicitemos github_document como formato de salida. Aquí está el guión completo nuevamente:\n\n#' ---\n#' title: \"¡Se pueden renderizar scripts R!\"\n#' output: github_document\n#' ---\n#'\n#' Aquí hay algo de prosa en un comentario muy especial. Resumamos el conjunto de datos integrado `VADeaths`.\n# Aquí hay un comentario de código normal, que permanecerá como tal.\nsummary(VADeaths)\n\n#' Aquí hay algo más de prosa. Puedo usar la sintaxis habitual de Markdown para hacer cosas\n#' **negritas** o *italicas*. Usemos un ejemplo de la ayuda `dotchart()` para\n#' hacer un diagrama de puntos de Cleveland a partir de los datos de `VADeaths`. Incluso me molesto en nombrar\n#' este fragmento, entonces el PNG resultante tiene un nombre decente.\n#+ dotchart\ndotchart(VADeaths, main = \"Tasas de mortalidad en Virginia - 1940\")\n\nAquí detrás de escena hemos usado rmarkdown::render() para representar este script y puedes ir y verlo en GitHub.",
    "crumbs": [
      "Primeras victorias en GitHub",
      "<span class='chapter-number'>19</span>  <span class='chapter-title'>Renderizar un script R</span>"
    ]
  },
  {
    "objectID": "git-intro.html",
    "href": "git-intro.html",
    "title": "Algunos conceptos básicos de Git",
    "section": "",
    "text": "¡Hasta ahora te hemos contado sorprendentemente poco sobre Git! Esto es por diseño.\nDescubrimos que el uso real, en el curso de su trabajo, es la forma más efectiva de construir un modelo mental útil para Git. En los talleres en vivo, nos esforzamos por presentar las ideas básicas más importantes en el contexto de nuestras actividades guiadas. Los autodidactas pueden lograr lo mismo si siguen las guías sobre “pilas incluidas” que aparecen anteriormente en las secciones anteriores.\nSin embargo, aprovechando este éxito inicial, ahora es el momento perfecto para definir explícitamente algo de vocabulario de Git. También queremos ayudarlo a vincular los conceptos de Git con tareas y proyectos de ciencia de datos.\nEsta parte recopila todo lo que hemos escrito sobre los conceptos básicos de Git. Es un trabajo en progreso y está concebido como un complemento a los excelentes recursos externos para Git, que no tenemos ningún deseo de reinventar.",
    "crumbs": [
      "Fundamentos de Git",
      "Algunos conceptos básicos de Git"
    ]
  },
  {
    "objectID": "git-basics.html",
    "href": "git-basics.html",
    "title": "20  Repo, commit, diff, tag",
    "section": "",
    "text": "20.1 Repos o repositorios\nGit es un sistema de control de versiones cuyo propósito original era ayudar a grupos de desarrolladores a trabajar de forma colaborativa en grandes proyectos de software. Git gestiona la evolución de un conjunto de archivos, llamado repositorio o repo, de una manera altamente estructurada. Históricamente, estos archivos habrían consistido en código fuente e instrucciones sobre cómo crear una aplicación a partir de su fuente.\nGit ha sido reutilizado por la comunidad científica de datos (Ram 2013; Bartlett 2016; Perez-Riverol et al. 2016). Lo usamos para gestionar la variada colección de archivos que componen los proyectos típicos de análisis de datos, que consisten en datos, cifras, informes y, sí, algo de código fuente.\nPara proyectos nuevos o existentes, le recomendamos que:\nEsta configuración ocurre una vez por proyecto y puede ocurrir al inicio del proyecto o en cualquier momento posterior. Es probable que sus proyectos existentes ya se encuentren en un directorio dedicado. Hacer de dicho directorio un proyecto RStudio y un repositorio Git se reduce a permitir que esas aplicaciones dejen notas en archivos o directorios ocultos. El proyecto sigue siendo un directorio normal en su computadora, que puede ubicar, nombrar, mover y, en general, interactuar con él como desee. ¡No es necesario manipularlo con guantes especiales!\nEl flujo de trabajo diario probablemente no sea dramáticamente diferente de lo que hace actualmente. Trabaja de la forma habitual, escribiendo scripts R o creando informes en LaTeX o R Markdown. Pero en lugar de guardar únicamente archivos individuales, periódicamente realiza una confirmación, que toma una instantánea de todos los archivos de todo el proyecto. Si alguna vez ha versionado un archivo agregando sus iniciales o la fecha, efectivamente ha realizado una confirmación, aunque solo para una sola archivo. Es una versión que es importante para usted y que quizás desee inspeccionar o volver a consultar más adelante. Periódicamente, envías confirmaciones a GitHub. Esto es como compartir un documento con colegas en DropBox o enviarlo como archivo adjunto de correo electrónico. Al acceder a GitHub, haces que tu trabajo y todo tu progreso acumulado sean accesibles para otros.\nEste es un cambio moderado en su flujo de trabajo diario normal. Al principio se siente extraño, pero rápidamente se convierte en algo natural. En STAT 545, los estudiantes deben enviar todos los trabajos del curso a través de GitHub, a partir de la primera semana. La mayoría nunca ha visto Git antes y no se identifican como programadores. Es un tema importante en las horas de clase y de oficina durante las dos primeras semanas. Entonces prácticamente nunca volvemos a hablar de ello.",
    "crumbs": [
      "Fundamentos de Git",
      "<span class='chapter-number'>20</span>  <span class='chapter-title'>Repo, commit, diff, tag</span>"
    ]
  },
  {
    "objectID": "git-basics.html#repos-o-repositorios",
    "href": "git-basics.html#repos-o-repositorios",
    "title": "20  Repo, commit, diff, tag",
    "section": "",
    "text": "Dedicarle un directorio o carpeta local.\nConviértalo en un proyecto RStudio. Opcional pero recomendado; obviamente solo se aplica a proyectos que involucran R y usuarios de RStudio.\nConviértelo en un repositorio Git.",
    "crumbs": [
      "Fundamentos de Git",
      "<span class='chapter-number'>20</span>  <span class='chapter-title'>Repo, commit, diff, tag</span>"
    ]
  },
  {
    "objectID": "git-basics.html#commits-diffs-y-tags",
    "href": "git-basics.html#commits-diffs-y-tags",
    "title": "20  Repo, commit, diff, tag",
    "section": "20.2 Commits, diffs, y tags",
    "text": "20.2 Commits, diffs, y tags\nAhora conectamos los conceptos fundamentales de Git con el flujo de trabajo de la ciencia de datos:\n\nrepository\ncommit\ndiff\n\nRecuerde que un repo o repositorio es solo un directorio de archivos que Git administra de manera integral. Una confirmación(commit) funciona como una instantánea de todos los archivos del repositorio, en un momento específico. En el fondo, no es así exactamente como Git implementa las cosas. Aunque los modelos mentales no tienen que ser precisos para ser útiles, en este caso ayuda alinear ambos.\n\n\n\n\n\n\nFigura 20.1: Historial de confirmaciones parciales para nuestro ejemplo de iris, destacando diferencias, mensajes de confirmación, SHA y etiquetas\n\n\n\nFigura 20.1 es una mirada a un análisis ficticio de los datos del iris, centrándose en la evolución de un guión, iris.R. Considere la versión A de este archivo y una versión modificada, la versión B. Supongamos que la versión A fue parte de una confirmación de Git y la versión B fue parte de la siguiente confirmación. El conjunto de diferencias entre A y B se llama “diff” y los usuarios de Git contemplan mucho las diferencias. La inspección de diferencias es la forma en que usted se vuelve a explicar en qué se diferencia la versión A de la versión B. La inspección de diferencias no se limita a confirmaciones adyacentes. Puede inspeccionar las diferencias entre dos confirmaciones cualesquiera.\nDe hecho, la noción de Git de cualquier versión específica de iris.R es una acumulación de diferencias. Si retrocede lo suficiente, encontrará la confirmación donde se creó el archivo en primer lugar. Git almacena cada versión posterior como esa versión inicial, más todas las diferencias intermedias en el historial que afectan el archivo. Dejaremos de lado estos detalles internos ahora, pero comprender la importancia de estos deltas hará que las operaciones de Git sean menos desconcertantes a largo plazo.\nEntonces, al observar las diferencias, es fácil ver en qué se diferencian dos instantáneas, pero ¿qué pasa con el por qué?\nCada vez que realiza una confirmación, también debe escribir un mensaje de confirmación breve. Idealmente, esto transmite la motivación para el cambio. Recuerde, la diferencia mostrará el contenido. Cuando vuelves a visitar un proyecto después de un descanso o necesitas digerir los cambios recientes realizados por un colega, mirar el historial, leer los mensajes de confirmación y hojear las diferencias, es una forma extremadamente eficiente de ponerte al día. Figura 20.1 muestra los mensajes asociados con las últimas tres confirmaciones.\nCada confirmación necesita algún tipo de apodo para que puedas identificarla. Git hace esto automáticamente, asignando a cada confirmación lo que se llama un SHA, una cadena aparentemente aleatoria de 40 letras y números (de hecho, no es aleatoria, sino que es un hash de suma de verificación SHA-1 de la confirmación). Aunque estará expuesto a estos, no es necesario que los maneje directamente con mucha frecuencia y, cuando lo hace, normalmente los primeros 7 caracteres son suficientes. Los mensajes de confirmación en Figura 20.1 tienen el prefijo SHA truncado. También puedes designar ciertas instantáneas como especiales con una etiqueta, que es el nombre que elijas. En un proyecto de software, es típico etiquetar una versión con su versión, por ejemplo, “v1.0.3”. Para un manuscrito o proyecto analítico, puede etiquetar la versión enviada a una revista o transmitida a colaboradores externos. Figura 20.1 muestra una etiqueta, “draft-01”, asociada con la última confirmación.\n\n\n\n\nBartlett, Alice. 2016. «Git for Humans». Financial Times, London; Talk at UX Brighton. https://speakerdeck.com/alicebartlett/git-for-humans.\n\n\nPerez-Riverol, Yasset, Laurent Gatto, Rui Wang, Timo Sachsenberg, Julian Uszkoreit, Felipe da Veiga Leprevost, Christian Fufezan, et al. 2016. «Ten Simple Rules for Taking Advantage of Git and GitHub». PLOS Computational Biology 12 (7): 1-11. https://doi.org/10.1371/journal.pcbi.1004947.\n\n\nRam, Karthik. 2013. «Git can facilitate greater reproducibility and increased transparency in science». Source Code for Biology and Medicine 8 (1): 7. https://doi.org/10.1186/1751-0473-8-7.",
    "crumbs": [
      "Fundamentos de Git",
      "<span class='chapter-number'>20</span>  <span class='chapter-title'>Repo, commit, diff, tag</span>"
    ]
  },
  {
    "objectID": "git-commands.html",
    "href": "git-commands.html",
    "title": "21  Comandos de git",
    "section": "",
    "text": "Una colección de algunos de los comandos de Git que se han estado ejecutando en gran medida bajo el capó. Hemos enfatizado los primeros flujos de trabajo que son posibles en RStudio. Pero todo esto y mucho más se puede hacer desde la línea de comandos. Esta lista está aquí principalmente para que podamos consultarla durante los talleres en vivo si es necesario.\nA menos que utilice la API de GitHub, la mayoría de los bits de GitHub realmente deben realizarse desde el navegador.\nNuevo repositorio de git local desde un repositorio en GitHub:\ngit clone https://github.com/jennybc/happy-git-with-r.git\nVerifique que el control remoto se haya clonado exitosamente:\ngit remote --verbose\nSeleccionar cambios locales, confirmar:\ngit add foo.txt\ngit commit --message \"Un mensaje de confirmación\"\nCompruebe el estado del mundo Git:\ngit status\ngit log\ngit log --oneline\nComparar versiones:\ngit diff\nAgregue un control remoto al repositorio local existente:\ngit remote add origin https://github.com/jennybc/happy-git-with-r\ngit remote --verbose\ngit remote show origin\nEnvíe el main local a GitHub main y haga que el main local rastree main en GitHub:\ngit push --set-upstream origin main\n# forma más corta\ngit push -u origin main\n# ¡solo necesitas configurar el seguimiento ascendente una vez!\nEnvío regular:\ngit push \n# lo anterior generalmente implica (y ciertamente lo hace en nuestro tutorial)\ngit push origin main\n# git push [remote-name] [branch-name]\nImportar confirmaciones desde GitHub:\ngit pull\nImportar confirmaciones y no evitar que esto le ponga en un aprieto de conflicto de fusión:\ngit pull --ff-only\nObtener confirmaciones\ngit fetch\nCambiar a una rama\ngit checkout [branch-name]\nComprobación del seguimiento remoto y de ramas\ngit remote -v\ngit remote show origin\ngit branch -vv",
    "crumbs": [
      "Fundamentos de Git",
      "<span class='chapter-number'>21</span>  <span class='chapter-title'>Comandos de git</span>"
    ]
  },
  {
    "objectID": "git-branches.html",
    "href": "git-branches.html",
    "title": "22  Ramas",
    "section": "",
    "text": "22.1 Crear una nueva rama\nRamificar significa tomar un desvío de la corriente principal de desarrollo y trabajar sin cambiar la corriente principal. Permite que una o varias personas trabajen en paralelo sin sobrescribir el trabajo de los demás. Permite a alguien que trabaja solo trabajar de forma incremental en una idea experimental, sin poner en peligro el estado del producto principal.\nLa bifurcación en Git es muy liviana, lo que significa crear una rama y El cambio entre ramas es casi instantáneo. Esto significa que Git fomenta los flujos de trabajo que crean pequeñas ramas para la exploración o nuevas funciones, y a menudo las fusionan rápidamente.\nPuede crear una nueva rama con git branch y luego verificar la rama con git checkout. Para distinguirlo de la corriente principal de desarrollo, presumiblemente en “principal”, lo llamaremos “rama de características”.\nTambién puedes usar el atajo git checkout -b issues-5 para crear y verificar la rama de una vez.\nUna vez que haya cambiado a una rama, puede confirmar cambios en ella como de costumbre.",
    "crumbs": [
      "Fundamentos de Git",
      "<span class='chapter-number'>22</span>  <span class='chapter-title'>Ramas</span>"
    ]
  },
  {
    "objectID": "git-branches.html#crear-una-nueva-rama",
    "href": "git-branches.html#crear-una-nueva-rama",
    "title": "22  Ramas",
    "section": "",
    "text": "git branch issue-5\ngit checkout issue-5",
    "crumbs": [
      "Fundamentos de Git",
      "<span class='chapter-number'>22</span>  <span class='chapter-title'>Ramas</span>"
    ]
  },
  {
    "objectID": "git-branches.html#cambiar-de-rama",
    "href": "git-branches.html#cambiar-de-rama",
    "title": "22  Ramas",
    "section": "22.2 Cambiar de rama",
    "text": "22.2 Cambiar de rama\nUsas git checkout para cambiar entre ramas.\nPero, ¿qué haces si estás trabajando en una rama y necesitas cambiar? ¿Pero el trabajo en la rama actual no está completo? Una opción es Git stash, pero generalmente una mejor opción es salvaguardar el estado actual con una confirmación temporal. Aquí utilizo “WIP” como mensaje de confirmación para indicar el trabajo en progreso.\ngit commit --all -m \"WIP\"\ngit checkout main\nLuego, cuando regreses a la rama y continúes con tu trabajo, Necesitas deshacer la confirmación temporal restableciendo tu estado. Específicamente, queremos un reinicio mixto. Este es un “directorio de trabajo seguro”, es decir, no afecta el estado de ningún archivo. Pero sí elimina el commit WIP temporal. A continuación, la referencia HEAD^ dice que se debe revertir el estado de confirmación al padre de la confirmación actual (HEAD).\ngit checkout issue-5\ngit reset HEAD^\nSi esto es difícil de recordar, o revertir el estado de confirmación a un estado anterior diferente, la referencia también se puede proporcionar como el SHA de una confirmación específica, que puede ver a través de git log. Aquí es donde creo que un cliente Git gráfico puede ser invaluable, ya que generalmente puedes hacer clic derecho en la confirmación de destino y luego seleccionar el tipo de reinicio deseado (por ejemplo, suave, mixto o duro). Este es exactamente el tipo de uso de Git intermedio a avanzado que a menudo parece más accesible en un cliente gráfico.",
    "crumbs": [
      "Fundamentos de Git",
      "<span class='chapter-number'>22</span>  <span class='chapter-title'>Ramas</span>"
    ]
  },
  {
    "objectID": "git-branches.html#fusionar-una-rama",
    "href": "git-branches.html#fusionar-una-rama",
    "title": "22  Ramas",
    "section": "22.3 Fusionar una rama",
    "text": "22.3 Fusionar una rama\nUna vez que haya hecho su trabajo y lo haya confirmado en la rama de funciones, puede volver a “principal” y fusionar la rama de funciones.\ngit checkout main\ngit merge issue-5",
    "crumbs": [
      "Fundamentos de Git",
      "<span class='chapter-number'>22</span>  <span class='chapter-title'>Ramas</span>"
    ]
  },
  {
    "objectID": "git-branches.html#sec-fusion-conflicts",
    "href": "git-branches.html#sec-fusion-conflicts",
    "title": "22  Ramas",
    "section": "22.4 Lidiar con los conflictos",
    "text": "22.4 Lidiar con los conflictos\nLa mayoría de las veces, la fusión se realizará sin problemas. Sin embargo, si ambas ramas que está fusionando cambiaron la misma parte del mismo archivo, obtendrá un conflicto de fusión.\ngit merge issue-5\n# Auto-merging index.html\n# CONFLICT (content): Merge conflict in index.html\n# Automatic merge failed; fix conflicts and then commit the result.\nLo primero que debe hacer es NO ENTRAR EN PÁNICO. Los conflictos de fusión no son el fin del mundo y la mayoría son relativamente pequeños y fáciles de resolver.\nEl primer paso para resolver un conflicto de fusión es determinar qué archivos están en conflicto, que puedes hacer con git status:\ngit status\n# On branch main\n# You have unmerged paths.\n#   (fix conflicts and run \"git commit\")\n# \n# Unmerged paths:\n#   (use \"git add &lt;file&gt;...\" to mark resolution)\n# \n#     both modified:      index.html\n# \n# no changes added to commit (use \"git add\" and/or \"git commit -a\")\nEntonces esto muestra que solo index.html no está fusionado y debe resolverse. Luego podemos abrir el archivo para ver qué líneas están en conflicto.\n&lt;&lt;&lt;&lt;&lt;&lt;&lt; HEAD:index.html\n&lt;div id=\"footer\"&gt;contact : email.support@github.com&lt;/div&gt;\n=======\n&lt;div id=\"footer\"&gt;\n please contact us at support@github.com\n&lt;/div&gt;\n&gt;&gt;&gt;&gt;&gt;&gt;&gt; issue-5:index.html\nEn este conflicto, las líneas entre &lt;&lt;&lt;&lt;&lt;&lt; HEAD:index.html y ====== son el contenido de la rama en la que se encuentra actualmente. Las líneas entre ======= y &gt;&gt;&gt;&gt;&gt;&gt;&gt; issues-5:index.html son de la rama de funciones que estamos fusionando.\nPara resolver el conflicto, edite esta sección hasta que refleje el estado que desea en el resultado combinado. Elige una versión u otra o crea un híbrido. También elimine los marcadores de conflicto &lt;&lt;&lt;&lt;&lt;&lt;, ====== y &gt;&gt;&gt;&gt;&gt;&gt;.\n&lt;div id=\"footer\"&gt;\nplease contact us at email.support@github.com\n&lt;/div&gt;\nAhora ejecute git add index.html y git commit para finalizar la fusión. CONFLICTOS RESUELTOS.\n\n22.4.1 Abortar\nSi, durante la fusión, se confunde sobre el estado de las cosas o hace una error, use git merge --abort para cancelar la fusión y volver al estado antes de ejecutar git merge. Luego puedes intentar completar la fusión nuevamente.\nBifurcación y fusión de Git Basic:\nhttps://git-scm.com/book/en/v2/Git-Branching-Basic-Branching-and-Merging",
    "crumbs": [
      "Fundamentos de Git",
      "<span class='chapter-number'>22</span>  <span class='chapter-title'>Ramas</span>"
    ]
  },
  {
    "objectID": "git-remotes.html",
    "href": "git-remotes.html",
    "title": "23  Remotos",
    "section": "",
    "text": "23.1 Listar qué controles remotos existen\nLos repositorios remotos son versiones de su proyecto que están alojadas en Internet o en otra red. Un solo proyecto puede tener 1, 2 o incluso cientos de controles remotos. Usted importa los cambios de otros desde los controles remotos y envía sus cambios a los controles remotos.\ngit remote enumera los nombres de los controles remotos disponibles, pero generalmente es más útil ver a qué URL corresponde cada nota (con -v).\ngit remote -v\n\norigin  https://github.com/davidrsch/hg-gh4res (fetch)\norigin  https://github.com/davidrsch/hg-gh4res (push)",
    "crumbs": [
      "Fundamentos de Git",
      "<span class='chapter-number'>23</span>  <span class='chapter-title'>Remotos</span>"
    ]
  },
  {
    "objectID": "git-remotes.html#agregar-un-nuevo-control-remoto",
    "href": "git-remotes.html#agregar-un-nuevo-control-remoto",
    "title": "23  Remotos",
    "section": "\n23.2 Agregar un nuevo control remoto",
    "text": "23.2 Agregar un nuevo control remoto\ngit clone agrega automáticamente un nuevo control remoto, por lo que a menudo no es necesario hacerlo manualmente inicialmente. Sin embargo, después de la clonación inicial, suele ser útil agregar controles remotos adicionales.\nUtilice git remote add para agregar un nuevo control remoto:\ngit remote add happygit https://github.com/jennybc/happy-git-with-r.git\nNota: cuando agregas un control remoto, le asignas un apodo (aquí happygit), que puedes usar en los comandos de git en lugar de la URL completa.\ngit fetch happygit\nBarra lateral sobre apodos: existe una fuerte convención para usar origin como apodo de su control remoto principal. En este punto, es común que el control remoto principal de un repositorio esté alojado en GitHub (o GitLab o Bitbucket). Es tentador utilizar un apodo más descriptivo (como github), pero es posible que valga la pena seguir la convención. Hace que su configuración sea más fácil de entender para otros y para que usted transfiera información que lee en la documentación, en Stack Overflow o en blogs.\nUna razón común para agregar un segundo control remoto es cuando ha realizado una “bifurcación y clonación” de un repositorio y su copia personal (su bifurcación) está configurada como el control remoto origin. Con el tiempo, querrás importar los cambios del repositorio original. Es común utilizar upstream como apodo para este control remoto.\ngit remote add upstream https://github.com/TRUE_OWNER/REPO.git",
    "crumbs": [
      "Fundamentos de Git",
      "<span class='chapter-number'>23</span>  <span class='chapter-title'>Remotos</span>"
    ]
  },
  {
    "objectID": "git-remotes.html#obteniendo-datos-de-controles-remotos",
    "href": "git-remotes.html#obteniendo-datos-de-controles-remotos",
    "title": "23  Remotos",
    "section": "\n23.3 Obteniendo datos de controles remotos",
    "text": "23.3 Obteniendo datos de controles remotos\nPara obtener nuevos datos desde un uso remoto git fetch &lt;remote_name&gt;. Esto recupera los datos localmente, pero lo más importante es que no cambia el estado de sus archivos locales de ninguna manera. Para incorporar los datos a su repositorio, necesita fusionar o cambiar la base de su proyecto con el proyecto remoto.\n# Obtener los datos\ngit fetch happygit\n\n# Fusionar con main local\ngit merge happygit/main main\n\n# git pull es un atajo que hace lo anterior en un solo comando\ngit pull happygit main\nPara obtener más detalles sobre los flujos de trabajo git pull, consulte Capítulo 29.",
    "crumbs": [
      "Fundamentos de Git",
      "<span class='chapter-number'>23</span>  <span class='chapter-title'>Remotos</span>"
    ]
  },
  {
    "objectID": "git-remotes.html#enviar-a-controles-remotos",
    "href": "git-remotes.html#enviar-a-controles-remotos",
    "title": "23  Remotos",
    "section": "\n23.4 Enviar a controles remotos",
    "text": "23.4 Enviar a controles remotos\nUtilice git push &lt;remote&gt; &lt;branch&gt; para enviar sus cambios locales a la rama &lt;branch&gt; en el control remoto &lt;remote&gt;.\n# enviar mis cambios locales a la rama principal del control remoto de origen\ngit push origin main\n\n# enviar mis cambios locales a la rama de prueba del control remoto happygit\ngit push happygit test",
    "crumbs": [
      "Fundamentos de Git",
      "<span class='chapter-number'>23</span>  <span class='chapter-title'>Remotos</span>"
    ]
  },
  {
    "objectID": "git-remotes.html#cambiar-el-nombre-y-cambiar-los-controles-remotos",
    "href": "git-remotes.html#cambiar-el-nombre-y-cambiar-los-controles-remotos",
    "title": "23  Remotos",
    "section": "\n23.5 Cambiar el nombre y cambiar los controles remotos",
    "text": "23.5 Cambiar el nombre y cambiar los controles remotos\ngit remote rename se puede utilizar para cambiar el nombre de un control remoto:\ngit remote rename happygit hg\ngit remote set-url se puede utilizar para cambiar la URL de un control remoto. Esto a veces es útil si inicialmente configuró un control remoto usando HTTPS, pero ahora desea usar SSH en su lugar (o viceversa).\ngit remote set-url happygit git@github.com:jennybc/happy-git-with-r.git\nUn flujo de trabajo bastante común es que inicialmente clonaste un repositorio en GitHub localmente (sin bifurcarlo), pero ahora quieres crear tu propia bifurcación y enviarle cambios. Como se describió anteriormente, es común llamar al repositorio de origen upstream y llamar a su bifurcación origin. Entonces, en este caso, primero debe cambiar el nombre del control remoto existente (de origin a upstream). Luego agrega tu tenedor como un nuevo control remoto, con el nombre origin.\ngit remote rename origin upstream\ngit remote add origin git@github.com:jimhester/happy-git-with-r.git",
    "crumbs": [
      "Fundamentos de Git",
      "<span class='chapter-number'>23</span>  <span class='chapter-title'>Remotos</span>"
    ]
  },
  {
    "objectID": "git-remotes.html#upstream-seguimiento-de-ramas",
    "href": "git-remotes.html#upstream-seguimiento-de-ramas",
    "title": "23  Remotos",
    "section": "\n23.6 Upstream seguimiento de ramas",
    "text": "23.6 Upstream seguimiento de ramas\nEs posible configurar la rama en el control remoto al que corresponde cada uno de sus controles remotos locales. git clone configura esto automáticamente, por lo que para tu propia rama main esto no es algo con lo que te toparás. Sin embargo, de forma predeterminada, si crea una nueva rama e intenta acceder a ella, verá algo como esto:\ngit checkout -b mybranch\ngit push\n# fatal: The current branch foo has no upstream branch.\n# To push the current branch and set the remote as upstream, use\n#\n#     git push --set-upstream origin foo\nPuede hacer lo que dice el mensaje de error y configurar explícitamente la rama upstream con --set-upstream. Sin embargo, recomendaría cambiar el comportamiento predeterminado de push para configurar automáticamente la rama upstream en la rama con el mismo nombre en el control remoto.\nPuedes hacer esto cambiando la opción git push.default a current.\ngit config --global push.default current\nConsulte también Trabajar con controles remotos:\nhttps://git-scm.com/book/en/v2/Git-Basics-Working-with-Remotes",
    "crumbs": [
      "Fundamentos de Git",
      "<span class='chapter-number'>23</span>  <span class='chapter-title'>Remotos</span>"
    ]
  },
  {
    "objectID": "git-refs.html",
    "href": "git-refs.html",
    "title": "24  Referencias",
    "section": "",
    "text": "24.1 Referencias útiles\nMuchos flujos de trabajo de Git extremadamente útiles requieren que identifiques un punto específico en el historial de tu repositorio, es decir, una confirmación específica.\nHemos explicado en otra parte que cada confirmación está asociada con el llamado SHA, es decir, una suma de verificación SHA-1 de la confirmación misma. Estas cadenas opacas de 40 letras y números no son especialmente agradables para los humanos. La estrategia de afrontamiento básica es trabajar con una forma abreviada del SHA. Es típico utilizar solo los primeros 7 caracteres, ya que esto casi siempre identifica de forma única una confirmación.\nAfortunadamente, hay aún más formas de hablar sobre una confirmación específico, que son mucho más fáciles de entender para los humanos. Estos se denominan “refs” de Git, abreviatura de referencias y, si está familiarizado con el concepto de programación de un puntero, ese es exactamente el modelo mental correcto.\nEstas son algunas de las referencias más útiles:\nSi desea que todo esto sea más concreto, puede usar git rev-parse en el shell para observar cómo las referencias se resuelven en SHA concretos. Aquí está el patrón general:\nAquí hay algunos ejemplos ejecutados en el repositorio Happy Git:\nObserve que HEAD y main se resuelven en el mismo SHA, ya que la rama main estaba desprotegida en ese momento. testing-something es el nombre de una rama que estaba por ahí.\nEstas referencias se pueden usar en todo tipo de operaciones de Git, como git diff, git reset y git checkout:",
    "crumbs": [
      "Fundamentos de Git",
      "<span class='chapter-number'>24</span>  <span class='chapter-title'>Referencias</span>"
    ]
  },
  {
    "objectID": "git-refs.html#referencias-útiles",
    "href": "git-refs.html#referencias-útiles",
    "title": "24  Referencias",
    "section": "",
    "text": "Un nombre de rama. Ejemplo: main, wild-experiment. Cuando te refieres a la rama main, eso se resuelve en el SHA de la punta de la rama main. Piense en una referencia de rama como una referencia deslizante que evoluciona a medida que lo hace la rama.\n\n\n\n\n\n\n\nHEAD. Esto (casi siempre) se resuelve en la punta de la rama que está actualmente desprotegida.1 Puedes pensar en HEAD como una referencia que apunta a la punta de la rama actual, que a su vez es una ref, que apunta a un SHA específico. Hay dos capas de dirección indirecta. Esto también se llama referencia simbólica.\n\n\n\n\n\n\n\nUna etiqueta. Ejemplo: v1.4.2. Las etiquetas se diferencian de las referencias de rama y de la referencia HEAD en que tienden a ser mucho más estáticas. Las etiquetas no se deslizan por naturaleza, aunque es posible reposicionar una etiqueta para que apunte a un nuevo SHA, si se hace un esfuerzo explícito. El uso más común de una etiqueta es proporcionar una etiqueta agradable para un SHA específico.\n\n\n\n\n\n\n\ngit rev-parse YOUR_REF_GOES_HERE\n\n~/rrr/happy-git-with-r % git rev-parse HEAD\n631fee855db49d87f6c2a2cab474e89c11322bf4\n\n~/rrr/happy-git-with-r % git rev-parse main\n631fee855db49d87f6c2a2cab474e89c11322bf4\n\n~/rrr/happy-git-with-r % git rev-parse testing-something                       \n1eeb91d177b7cb5f9a0b29ebee3e6c0c8ff98f88\n\n\ngit diff main testing-something\n\ngit reset testing-something -- README.md\n\ngit checkout -b my-new-branch main",
    "crumbs": [
      "Fundamentos de Git",
      "<span class='chapter-number'>24</span>  <span class='chapter-title'>Referencias</span>"
    ]
  },
  {
    "objectID": "git-refs.html#referencias-relativos",
    "href": "git-refs.html#referencias-relativos",
    "title": "24  Referencias",
    "section": "24.2 Referencias relativos",
    "text": "24.2 Referencias relativos\nTambién hay modificadores que le ayudan a especificar una confirmación relativa a una referencia, p. “la confirmación justo antes de este”.\nHEAD~1 se refiere a la confirmación justo antes de HEAD. HEAD^ es otra forma de decir exactamente lo mismo.\n\n\n\n\n\nAquí hay algunos ejemplos ejecutados en el repositorio Happy Git:\n~/rrr/happy-git-with-r % git rev-parse HEAD~1\n5dacec4950a3746310bb30704417a792302b044a\n\n~/rrr/happy-git-with-r % git rev-parse HEAD^\n5dacec4950a3746310bb30704417a792302b044a\nObserve que HEAD~1 y HEAD^ se resuelven en el mismo SHA.\nAmbos patrones se generalizan. HEAD~3 y HEAD^^^ son referencias válidas y equivalentes.\nDebo admitir que no soy un gran admirador de estos atajos de referencia relativa y especialmente cuando retrocedo más de una confirmación. Me preocupa tener algún tipo de error uno por uno según tengo entendido y terminaré apuntando a la confirmación incorrecta.\nHerramientas como GitKraken y GitHub hacen que sea extremadamente fácil copiar SHA específicos a su portapapeles. Entonces, cuando necesito una referencia que no sea un simple nombre de rama o etiqueta, casi siempre me apoyo en herramientas fáciles de usar como GitKraken o GitHub para permitirme expresar mi intención utilizando el SHA de interés real. Sospecho que los atajos de referencia relativos son más populares entre las personas que usan exclusivamente la línea de comandos Git y operan bajo diferentes restricciones. En realidad, existe un amplio conjunto de formas de especificar una confirmación de destino que va mucho más allá de la sintaxis ^ y ~ que se muestra aquí. Puede obtener más información en la documentación oficial de Git sobre parámetros de revisión.\nEn GitKraken, haga clic con el botón derecho o control en la confirmación de destino para acceder a un menú que incluye “Copiar confirmación sha”, entre muchos otros comandos útiles. Si está utilizando otro cliente Git, probablemente haya una manera de hacerlo y vale la pena descubrirla.\n\n\n\n\n\nGitHub también hace que sea extremadamente fácil copiar un SHA en muchos contextos. Esta captura de pantalla muestra solo un ejemplo. Una vez que empiece a buscar esta función, la encontrará en muchos lugares de GitHub.",
    "crumbs": [
      "Fundamentos de Git",
      "<span class='chapter-number'>24</span>  <span class='chapter-title'>Referencias</span>"
    ]
  },
  {
    "objectID": "git-refs.html#footnotes",
    "href": "git-refs.html#footnotes",
    "title": "24  Referencias",
    "section": "",
    "text": "¿Cuándo HEAD no se resuelve en el SHA en la punta de alguna rama? Cuando estás en un estado detached HEAD. ¡CABEZA separada! Eso suena mal, pero no es intrínsecamente bueno o malo. Sin embargo, ES malo estar en un estado de CABEZA separada si no era tu intención y no entiendes el trato. Entras en un estado CABEZA separada cuando verificas directamente una confirmación específica, en lugar de verificar o cambiar a una rama. En manos experimentadas, esto puede ser algo legítimo. Pero mientras tanto, te recomiendo que siempre visites un estado específico en el historial consultando una rama, incluso si eso significa que necesitas crear una rama temporal como holder o time-travel. Para salir del estado CABEZA separada, consulte alguna rama existente, con git checkout main o similar. De lo contrario, el hilo de StackOverflow ¿Cómo puedo arreglar un cabezal separado de Git? aborda muchos escenarios desconcertantes de CABEZA separada.↩︎",
    "crumbs": [
      "Fundamentos de Git",
      "<span class='chapter-number'>24</span>  <span class='chapter-title'>Referencias</span>"
    ]
  },
  {
    "objectID": "remote-setups-intro.html",
    "href": "remote-setups-intro.html",
    "title": "Configuraciones remotas de Git",
    "section": "",
    "text": "La parte anterior terminó con algunos conceptos básicos sobre Git remotos, como cómo definir o cambiar el nombre de uno. Recuerde que un control remoto de Git es otra copia del repositorio, que generalmente se encuentra en otro lugar (de ahí el término “remoto”), desde donde puede importar cambios o enviarlos. Los controles remotos son la base de todo el trabajo colaborativo de Git.\nPero conocer la mecánica de cómo agregar o cambiar el nombre de un control remoto no sirve de nada si no sabes por qué o cuándo hacerlo. Afortunadamente, tenemos opiniones muy firmes sobre cómo debes configurar tus controles remotos, todas motivadas por prepararte para un trabajo colaborativo fluido y feliz.\nEn esta parte describimos varias configuraciones remotas que son comunes (para bien o para mal) y para qué sirven (o qué tienen de malo y cómo solucionarlo).",
    "crumbs": [
      "Configuraciones de remotos",
      "Configuraciones remotas de Git"
    ]
  },
  {
    "objectID": "remote-setups-common.html",
    "href": "remote-setups-common.html",
    "title": "25  Configuraciones remotas comunes",
    "section": "",
    "text": "25.1 Sin GitHub\nAquí sólo consideramos un conjunto muy limitado de controles remotos:\nSi utiliza un host diferente o nombres remotos diferentes, aún debería poder traducir estos ejemplos a su configuración.\nA lo largo del camino, observamos cómo estas configuraciones se relacionan con el paquete usethis, es decir, cómo usethis puede ayudarlo a lograr una configuración favorable o cómo una configuración favorable desbloquea todo el poder de usethis. Muchas de estas operaciones, incluida la caracterización de sus controles remotos de GitHub, requieren que haya configurado un token de acceso personal de GitHub. Consulte Sección 9.3 para obtener más detalles sobre por qué y cómo hacerlo. Si no utiliza usethis, no dude en ignorar estos aspectos.\nComo punto de partida, considere un repositorio de Git local que aún no esté conectado a GitHub.\nEsto no es muy emocionante, pero prepara el escenario para lo que está por venir. Introducimos el ícono que usamos para un repositorio de Git, que parece una pila de monedas o un barril. Este es azul, lo que indica que tienes permiso de escritura.\nComo alcanzar:\nusethis describe esta configuración como “no_github”.",
    "crumbs": [
      "Configuraciones de remotos",
      "<span class='chapter-number'>25</span>  <span class='chapter-title'>Configuraciones remotas comunes</span>"
    ]
  },
  {
    "objectID": "remote-setups-common.html#sin-github",
    "href": "remote-setups-common.html#sin-github",
    "title": "25  Configuraciones remotas comunes",
    "section": "",
    "text": "Línea de comando Git: git init\nCon usethis, proyecto existente: usethis::use_git()\nCon RStudio:\n\nProyecto existente: Tools &gt; Version Control &gt; Project Setup, seleccione Git como el sistema de control de versión\nNuevo proyecto: asegúrese de que esté seleccionado “Create a Git repository”",
    "crumbs": [
      "Configuraciones de remotos",
      "<span class='chapter-number'>25</span>  <span class='chapter-title'>Configuraciones remotas comunes</span>"
    ]
  },
  {
    "objectID": "remote-setups-common.html#sec-ours-you",
    "href": "remote-setups-common.html#sec-ours-you",
    "title": "25  Configuraciones remotas comunes",
    "section": "25.2 La nuestra (más específicamente, la tuya)",
    "text": "25.2 La nuestra (más específicamente, la tuya)\nUn siguiente paso común es asociar un repositorio local con una copia en GitHub, de su propiedad.\n\n\n\n\n\nSe configura un control remoto llamado origin y usted tiene permiso para enviar (e importar) origin. (Es por eso que origin está coloreado en azul y hay flechas sólidas que van en ambas direcciones). El control remoto origin en GitHub es lo que llamaremos un repositorio fuente, lo que significa que no es una bifurcación (es decir, una copia). de cualquier otra cosa en GitHub. En este caso, origin es también lo que llamaremos su repositorio principal, lo que significa que es el control remoto principal con el que interactúa en GitHub (para este proyecto).\nCómo lograr si el repositorio local existe primero:\n\nLas instrucciones detalladas se encuentran en Proyecto existente, GitHub último.\nCon usethis: usethis::use_github().\nLínea de comando Git o RStudio: no puede completar esta tarea completamente desde la línea de comando o desde RStudio:\n\nCree un nuevo repositorio de GitHub en el navegador, con el nombre correcto, y capture su URL HTTPS o SSH.\nConfigurar el repositorio como el remoto origin.\nPush.\nIncluso ahora, la configuración puede no ser ideal, porque las relaciones de seguimiento ascendentes probablemente no estén configuradas, lo que significa que es posible que no pueda enviar e importar fácilmente. Es posible que deba configurar explícitamente una rama upstream para una o más ramas locales. La próxima vez que quieras crear un repositorio de GitHub desde un repositorio local, considera usar usethis::use_github(), que completa toda esta configuración de una sola vez.\n\n\nCómo lograr si el repositorio remoto existe primero:\n\nLas instrucciones detalladas se encuentran en Nuevo proyecto RStudio mediante git clone.\nCon usethis: usethis::create_from_github(\"OWNER/REPO\", fork = FALSE)\nLínea de comando: git clone &lt;URL&gt;, con la URL HTTPS o SSH del repositorio de origen\nEn RStudio: capture la URL HTTPS o SSH del repositorio de origen y haga File &gt; New Project &gt; Version Control &gt; Git.\n\nusethis describe esta configuración como “ours”.",
    "crumbs": [
      "Configuraciones de remotos",
      "<span class='chapter-number'>25</span>  <span class='chapter-title'>Configuraciones remotas comunes</span>"
    ]
  },
  {
    "objectID": "remote-setups-common.html#sec-ours-them",
    "href": "remote-setups-common.html#sec-ours-them",
    "title": "25  Configuraciones remotas comunes",
    "section": "25.3 Nuestra",
    "text": "25.3 Nuestra\nAquí hay una variación sobre “ours” que es equivalente en la práctica.\n\n\n\n\n\nSe configura un control remoto llamado origin y puede enviar (e importar) origin. Como se indicó anteriormente, origin es un repositorio fuente, lo que significa que no es una bifurcación (o copia) de nada más en GitHub. Sin embargo, el control remoto origin no es de su propiedad. En cambio, es propiedad de otro usuario u organización de GitHub. origin también es su repositorio principal en esta configuración.\n¿Como sucedió esto?\n\nEl repositorio de origen es propiedad de una organización y su función en esta organización le confiere poder suficiente para crear repositorios o enviarlos a este repositorio.\nEl propietario del repositorio de origen lo agregó, específicamente, como colaborador de este repositorio específico.\n\n¿Como lograr esto? El procedimiento es el mismo que para la configuración “ours” anterior. Pero recuerde especificar usethis::use_github(organization = \"ORGNAME\") si desea crear un nuevo repositorio bajo una organización, en lugar de su cuenta personal.\nusethis describe esta configuración como “ours”.",
    "crumbs": [
      "Configuraciones de remotos",
      "<span class='chapter-number'>25</span>  <span class='chapter-title'>Configuraciones remotas comunes</span>"
    ]
  },
  {
    "objectID": "remote-setups-common.html#sec-theirs",
    "href": "remote-setups-common.html#sec-theirs",
    "title": "25  Configuraciones remotas comunes",
    "section": "25.4 Suyo",
    "text": "25.4 Suyo\nEsta es una configuración en la que muchas personas se meten, cuando en realidad no es lo que necesitan. No está roto per se, pero es limitante.\n\n\n\n\n\nNo puede enviar al origin, que es tanto el repositorio de origen como el repositorio principal. (Esto se indica con el color naranja de origin y la flecha de “enviar” discontinua y atenuada). origin es de solo lectura para usted.\nSi está realizando un repositorio para una prueba rápida, esta configuración está bien. Pero no hay forma de recuperar los cambios en el repositorio de origen, ya que no puede enviarlos y no ha creado una bifurcación, que es necesaria para una solicitud de fusión.\n¿Como sucedió esto?\n\nClonando el repositorio de origen, ya sea mediante git clone &lt;URL&gt; (línea de comando) o mediante un cliente Git, p. Flujo de trabajo Archivo &gt; Nuevo proyecto &gt; Control de versiones &gt; Git de RStudio.\nEjecutando usethis::create_from_github(\"OWNER/REPO\", fork = FALSE).\n\nusethis describe esta configuración como “theirs”.\n¿Qué sucede si desea realizar una solicitud de fusión? Esto significa que deberías haber hecho fork-and-clone en lugar de clone. Si no ha realizado cambios o es fácil guardarlos en algún lugar temporalmente, simplemente comience de nuevo con un flujo de trabajo de bifurcación y clonación (explicado completamente en Capítulo 31) y vuelva a introducir sus cambios. También es posible conservar su trabajo en una rama local, bifurcar el repositorio de origen, reconfigurar sus controles remotos, volver a sincronizar con el repositorio de origen y volver a la normalidad. Pero es mucho más fácil equivocarse. ¡Y recuerda bifurcar y clonar (no sólo clonar) en el futuro!",
    "crumbs": [
      "Configuraciones de remotos",
      "<span class='chapter-number'>25</span>  <span class='chapter-title'>Configuraciones remotas comunes</span>"
    ]
  },
  {
    "objectID": "remote-setups-common.html#sec-fork-them",
    "href": "remote-setups-common.html#sec-fork-them",
    "title": "25  Configuraciones remotas comunes",
    "section": "25.5 Fork (theirs)",
    "text": "25.5 Fork (theirs)\nEsta es una configuración ideal si desea realizar una solicitud de fusión y, en general, seguir el desarrollo de un repositorio fuente propiedad de otra persona.\n\n\n\n\n\nEsto muestra un “fork-and-clone” exitoso. Su repositorio local puede importar cambios del repositorio de origen, que está configurado como “upstream”, al cual no puede enviar cambios (pero sí puede importarlos). Tienes un fork del repositorio fuente (una copia muy especial, en GitHub) y está configurado como origin. origin es su repositorio principal. Puede enviar e importar desde el origin. Puede realizar una solicitud de fusión al repositorio de origen a través de su bifurcación.\nusethis describe esta configuración como “fork”.\nComo alcanzar:\n\nLas instrucciones detalladas se dan en Fork y clone.\nCon usethis: usethis::create_from_github(\"OWNER/REPO\", fork = TRUE)\nLínea de comando Git o RStudio: no puede completar esta tarea completamente desde la línea de comando o RStudio:\n\nBifurca el repositorio fuente en el navegador, captura la URL HTTPS o SSH de tu bifurcación, luego usa git clone &lt;FORK_URL&gt; (línea de comando) o RStudio. File &gt; New Project &gt; Version Control &gt; Git flujo de trabajo. Pero espera, ¡aún no has terminado! Si se detiene aquí, tendrá la configuración incompleta a la que nos referimos como “fork (salvageable)”.\nAún necesita agregar el repositorio de origen como control remoto upstream. Capture la URL HTTPS o SSH del repositorio de origen. En la línea de comando, haga git remoto add upstream &lt;SOURCE_URL&gt; o haga clic en el botón Nueva rama de RStudio, que abre una ventana donde puede agregar el control remoto upstream.\nIncluso entonces, la configuración puede no ser ideal, porque su rama predeterminada local probablemente esté rastreando el origin, no el upstream, lo cual es preferible para una bifurcación. usethis::create_from_github() completa toda esta configuración de una sola vez.\nEstos dos últimos pasos se describen en Finalizar la configuración de bifurcación y clonación.",
    "crumbs": [
      "Configuraciones de remotos",
      "<span class='chapter-number'>25</span>  <span class='chapter-title'>Configuraciones remotas comunes</span>"
    ]
  },
  {
    "objectID": "remote-setups-common.html#fork-ours",
    "href": "remote-setups-common.html#fork-ours",
    "title": "25  Configuraciones remotas comunes",
    "section": "25.6 Fork (ours)",
    "text": "25.6 Fork (ours)\nEsta es una variación menos común en la configuración de fork.\n\n\n\n\n\nEn este caso, tiene permiso para enviar al repositorio de origen, pero elige crear una bifurcación personal de todos modos. Ciertos proyectos favorecen este enfoque y ofrece la máxima flexibilidad de desarrollo para usuarios avanzados. Sin embargo, en este caso, a la mayoría de los usuarios les resulta mejor la configuración más sencilla “ours”.\nComo lograrlo:\n\nEn general, es lo mismo que la configuración de bifurcación normal anterior.\nCon usethis, asegúrese de especificar explícitamente fork = TRUE, es decir, ejecute usethis::create_from_github(\"OWNER/REPO\", fork = TRUE).\n\nusethis describe esta configuración como “fork”.",
    "crumbs": [
      "Configuraciones de remotos",
      "<span class='chapter-number'>25</span>  <span class='chapter-title'>Configuraciones remotas comunes</span>"
    ]
  },
  {
    "objectID": "remote-setups-common.html#sec-fork_upstream_is_not_origin_parent",
    "href": "remote-setups-common.html#sec-fork_upstream_is_not_origin_parent",
    "title": "25  Configuraciones remotas comunes",
    "section": "25.7 Fork (salvageable)",
    "text": "25.7 Fork (salvageable)\nAquí hay una última configuración de bifurcación que no es óptima, pero se puede salvar.\n{fig-align=“center” fig-alt = “Setup described as ‘fork_upstream_is_not_origin_parent’” width=“60%”}\nEsto es lo que sucede cuando haces bifurcación y clonación y solo haces bifurcación y clonación. Lo que falta es una conexión con el repositorio de origen.\n¿Como sucedió esto?\n\nClonar su propia bifurcación, ya sea mediante git clone en el shell o mediante un cliente Git, como RStudio. Y luego parando aquí.\n\nSi solo planea realizar una solicitud de cambios, esta configuración está bien. Cuando finalice el intercambio, elimine su repositorio local y su bifurcación y continúe con su vida. Siempre puedes volver a bifurcar en el futuro. Pero si su solicitud de cambios permanece abierta por un tiempo o si planea realizar contribuciones repetidas, deberá incorporar los desarrollos en curso en el repositorio fuente a su copia local.\nPuedes convertir esto en la configuración de bifurcación ideal así:\n\nLas instrucciones detalladas se encuentran en Finalizar la configuración de bifurcación y clonación.\nAgregue el repositorio de origen como remoto upstream.\nEstablezca upstream/main como la rama de seguimiento ascendente para main local (sustituya el nombre de su rama predeterminada).\n\nLa próxima vez que hagas fork-and-clone, considera usar usethis::create_from_github(fork = TRUE) en su lugar, lo que completa toda esta configuración de una sola vez.\nusethis describe esta configuración como “fork_upstream_is_not_origin_parent”.",
    "crumbs": [
      "Configuraciones de remotos",
      "<span class='chapter-number'>25</span>  <span class='chapter-title'>Configuraciones remotas comunes</span>"
    ]
  },
  {
    "objectID": "remote-setups-equivocal.html",
    "href": "remote-setups-equivocal.html",
    "title": "26  Configuraciones remotas equívocas",
    "section": "",
    "text": "26.1 Tal vez “ours” o “theirs”\nAl igual que en la sección anterior sobre las configuraciones más comunes, solo consideramos un conjunto muy limitado de controles remotos:\nLas configuraciones descritas aquí se caracterizan por información incompleta. Esta sección existe principalmente para explicar los comentarios que el uso de este paquete podría brindar sobre una configuración remota de GitHub.\nPara identificar cualquiera de las configuraciones remotas descritas en Capítulo 25, necesitamos información de GitHub:\nA veces, parte de esta información está disponible públicamente, pero otra nunca lo está, como los permisos de repositorio. Esto significa que el acceso programático a esta información, es decir, las solicitudes a la API de GitHub, generalmente requiere la autorización de un usuario de GitHub autenticado.\nEsto significa que los paquetes de cliente, como usethis, funcionan mejor cuando has configurado un token de acceso personal (PAT) de GitHub. Consulte Sección 9.3 para obtener más detalles sobre por qué y cómo hacerlo.\nSi configuró un PAT y le dicen que su configuración de GitHub es problemática, considere estas otras explicaciones: ¿Está desconectado? ¿GitHub está caído? ¿Ha perdido el permiso para acceder al repositorio? ¿Ha caducado su PAT? De forma predeterminada, ahora caducan después de 30 días.\nCuando detectamos solo un control remoto de GitHub, pero no podemos verificar la información anterior, usethis describe la configuración como “maybe_ours_or_theirs”.\n{fig-align=“center” fig-alt=“Setup described as ‘maybe_ours_or_theirs’” width = “60%”}\nUna vez que un PAT está disponible, esta configuración se puede identificar como “ours” (que le pertenece a usted), “ours” (pero que pertenece a otra persona) , o “theirs”.",
    "crumbs": [
      "Configuraciones de remotos",
      "<span class='chapter-number'>26</span>  <span class='chapter-title'>Configuraciones remotas equívocas</span>"
    ]
  },
  {
    "objectID": "remote-setups-equivocal.html#tal-vez-fork",
    "href": "remote-setups-equivocal.html#tal-vez-fork",
    "title": "26  Configuraciones remotas equívocas",
    "section": "26.2 Tal vez fork",
    "text": "26.2 Tal vez fork\nCuando detectamos dos controles remotos de GitHub, pero no podemos verificar la información anterior, usethis describe la configuración como “maybe_fork”.\n\n\n\n\n\nUna vez que un PAT está disponible, esta configuración se puede identificar como una bien configurada fork o una bifurcación con configuración incompleta (o posiblemente algo más raro).",
    "crumbs": [
      "Configuraciones de remotos",
      "<span class='chapter-number'>26</span>  <span class='chapter-title'>Configuraciones remotas equívocas</span>"
    ]
  },
  {
    "objectID": "remote-setups-equivocal.html#como-arreglar",
    "href": "remote-setups-equivocal.html#como-arreglar",
    "title": "26  Configuraciones remotas equívocas",
    "section": "26.3 Como arreglar",
    "text": "26.3 Como arreglar\nEstas configuraciones no necesariamente están rotas, pero su uso necesita más información para funcionar.\nPara “solucionar” esto, configure un token de acceso personal de GitHub. Consulte Sección 9.3 para obtener más detalles sobre por qué y cómo hacerlo.",
    "crumbs": [
      "Configuraciones de remotos",
      "<span class='chapter-number'>26</span>  <span class='chapter-title'>Configuraciones remotas equívocas</span>"
    ]
  },
  {
    "objectID": "workflows-intro.html",
    "href": "workflows-intro.html",
    "title": "Patrones de Git útiles para la vida real",
    "section": "",
    "text": "Gran parte de esto se origina como materiales de talleres en vivo; Los flujos de trabajo no vinculados están planificados pero aún no convertidos a prosa aquí..\nPatrones de Git que aparecen con frecuencia en el trabajo real:\n\nConfirme temprano y con frecuencia. Empuje con menos frecuencia. Enmendar repetidamente.\n¡Ayuda, mi push fue rechazado!\nIntegrando el trabajo remoto y local. Probablemente para que puedas enviar de nuevo.\nQuémalo todo.\nViaje en el tiempo:\n\n“Solo necesito ver el pasado”. Navega y busca en GitHub.\n“Necesito visitar el pasado”. Crea una caja en una sucursal.\n“Quiero volver al pasado”. git revert, git reset\n“Comí una gran galleta en octubre pasado.”. git cherry pick, git checkout REF -- path\n\n\nJuega bien con los demás:\n\nBifurca y clona.\nObtener los cambios en upstream para una bifurcación.\nBifurcación desechable.\nHaz que tu repositorio sea gratificante para navegar en GitHub.\nExplorar y ampliar una solicitud de cambio",
    "crumbs": [
      "Flujos de trabajo diarios",
      "Patrones de Git útiles para la vida real"
    ]
  },
  {
    "objectID": "workflows-repeated-amend.html",
    "href": "workflows-repeated-amend.html",
    "title": "27  Enmendar repetidamente",
    "section": "",
    "text": "27.1 Analogía de la escalada en roca\nUno de los principales placeres del control de versiones es la libertad de experimentar sin miedo. Si arruinas las cosas, siempre puedes volver a una versión más feliz de tu proyecto. Describimos varios métodos de este tipo de viajes en el tiempo en Capítulo 30. ¡Pero debes tener un buen commit al que recurrir!\nHablemos de esto:\nCuando hago algo complicado, a menudo avanzo hacia mi objetivo en pequeños incrementos, comprobando que todo sigue funcionando en el camino. ¿Si, funciona? Haz un commit. Este es mi nuevo peor escenario. Sigue adelante.\n¿Qué no se podría amar?\nEsto puede generar una gran cantidad de pequeñas confirmaciones. Esto está absolutamente bien y no hay nada de qué avergonzarse. Pero algún día puede que empieces a preocuparte por la utilidad y la estética de tu historial de Git.\nLa modificación repetida es un patrón en el que, en lugar de saturar su historial con muchas confirmaciones pequeñas, construye una confirmación “buena” gradualmente, mediante modificaciones.\nSí, hay otras formas de hacer esto, p. mediante squashingo y rebase interactivo, pero creo que modificar es la mejor manera de comenzar.",
    "crumbs": [
      "Flujos de trabajo diarios",
      "<span class='chapter-number'>27</span>  <span class='chapter-title'>Enmendar repetidamente</span>"
    ]
  },
  {
    "objectID": "workflows-repeated-amend.html#analogía-de-la-escalada-en-roca",
    "href": "workflows-repeated-amend.html#analogía-de-la-escalada-en-roca",
    "title": "27  Enmendar repetidamente",
    "section": "",
    "text": "Usar una confirmación de Git es como usar anclajes y otras protecciones al escalar. Si estás cruzando una pared rocosa peligrosa, debes asegurarte de haber usado protección para atraparte si te caes. Las confirmaciones desempeñan un papel similar: si comete un error, no podrá superar la confirmación anterior. Codificar sin confirmaciones es como escalar libremente: puedes viajar mucho más rápido en el corto plazo, pero en el largo plazo las posibilidades de fallas catastróficas son altas. Al igual que la protección para la escalada en roca, debes ser prudente en el uso de confirmaciones. Realizar commits con demasiada frecuencia ralentizará su progreso; utilice más confirmaciones cuando se encuentre en territorio incierto o peligroso. Los cmmits también son útiles para los demás porque muestran su viaje, no sólo el destino.\nPaquetes R, Hadley Wickham (Wickham (2015))\n\n\n\nusa más confirmaciones cuando estés en territorio incierto o peligroso",
    "crumbs": [
      "Flujos de trabajo diarios",
      "<span class='chapter-number'>27</span>  <span class='chapter-title'>Enmendar repetidamente</span>"
    ]
  },
  {
    "objectID": "workflows-repeated-amend.html#bosquejo-del-flujo-de-trabajo",
    "href": "workflows-repeated-amend.html#bosquejo-del-flujo-de-trabajo",
    "title": "27  Enmendar repetidamente",
    "section": "27.2 Bosquejo del flujo de trabajo",
    "text": "27.2 Bosquejo del flujo de trabajo\n\n27.2.1 Condición inicial\nComience con su proyecto en un estado funcional:\n\n¿Paquete R? Ejecute sus pruebas o R CMD check.\n¿Análisis de los datos? Vuelva a ejecutar su secuencia de comandos o vuelva a representar su .Rmd con el nuevo fragmento.\n¿Sitio web o libro? Asegúrese de que el proyecto aún se compile.\nYa entiendes la idea.\n\nAsegúrese de que su “árbol de trabajo esté limpio” y esté sincronizado con su control remoto de GitHub. git status debería mostrar algo como:\n~/tmp/myrepo % git status                                                          \nOn branch main\nYour branch is up to date with 'origin/main'.\n\nnothing to commit, working tree clean\n\n\n27.2.2 Ponte a trabajar\nImaginemos que comenzamos en la confirmación C, la confirmación anterior es B y, antes de eso, A:\n... -- A -- B -- C\nDa un pequeño paso hacia tu objetivo. Vuelva a comprobar que su proyecto “funciona”.\nRealice esos cambios y realice una confirmación con el mensaje “WIP”, que significa “trabajo en progreso”. Haz esto en RStudio o en el shell. (Apéndice A):\ngit add ruta/al/archivo/cambiado\ngit commit -m \"WIP\"\nEl mensaje puede ser cualquier cosa, pero “WIP” es una convención común. Si lo usa, cada vez que regrese a un proyecto donde el mensaje de confirmación más reciente es “WIP”, sabrá que probablemente estaba en medio de algo. Si presiona un commit “WIP”, a propósito o por error, le indica a otras personas que es posible que se produzcan más commits.\nTu historial ahora se ve así:\nA -- B -- C -- WIP*\n¡No envies! El * anterior significa una confirmación que existe solo en tu repositorio local, no (todavía) en GitHub. Si llamaste a git status, verías algo como “Your branch is ahead of ‘origin/main’ by 1 commit.”, que también se muestra en el panel Git de RStudio.\nTrabaja un poco más. Vuelva a verificar que su proyecto aún esté en un estado funcional. Organiza y confirma nuevamente, pero esta vez modifica tu confirmación anterior. RStudio ofrece una casilla de verificación para “Amend previous commit” o en el shell:\ngit commit --amend --no-edit\nLa parte --no-edit conserva el mensaje de confirmación actual de “WIP”.\n¡No envies! Tu historial ahora se ve así:\nA -- B -- C -- WIP*\npero los cambios asociados con la confirmación WIP* ahora representan sus dos últimas confirmaciones, es decir, todos los cambios acumulados desde el estado C.\nSigue así.\nDigamos que finalmente has logrado tu objetivo. Una última vez, verifique que su proyecto sea funcional y se encuentre en un estado que esté dispuesto a compartir con otros.\nConfirme, enmendando nuevamente, pero esta vez con un mensaje de confirmación real. Piense en esto como una confirmación D. Envie. Haga esto en RStudio o el shell:\ngit commit --amend -m \"Implementa una característica increíble; cierra #43\"\ngit push\nTu historial, y el de GitHub, se ve así:\nA -- B -- C -- D\nHasta donde el mundo sabe, implementaste la función de una sola vez. Pero tenías que trabajar en la tarea de forma gradual, con la tranquilidad de que nunca podrías romper las cosas.",
    "crumbs": [
      "Flujos de trabajo diarios",
      "<span class='chapter-number'>27</span>  <span class='chapter-title'>Enmendar repetidamente</span>"
    ]
  },
  {
    "objectID": "workflows-repeated-amend.html#sec-manually-reset",
    "href": "workflows-repeated-amend.html#sec-manually-reset",
    "title": "27  Enmendar repetidamente",
    "section": "27.3 ¿Qué pasa si necesito retroceder?",
    "text": "27.3 ¿Qué pasa si necesito retroceder?\nImagine que está en medio de un flujo de trabajo de Enmendar repetidamente:\nA -- B -- C -- WIP*\ny realiza algunos cambios que rompen su proyecto, p. las pruebas empiezan a fallar. Estos malos cambios aún no se han confirmado, pero están guardados. Quiere volver al último buen estado, representado por WIP*.\nEn la jerga de Git, desea realizar un restablecimiento completo al estado WIP*. Sus archivos locales se restablecerán a la fuerza a su estado a partir de la confirmación WIP*. Con la línea de comando:\ngit reset --hard\nque es implícitamente lo mismo que\ngit reset --hard HEAD\nque dice: “restablecer mis archivos a su estado en la confirmación más reciente”.\nEsto también es posible en RStudio. De hecho, la forma RStudio hace que sea más fácil restablecer selectivamente sólo archivos específicos o sólo ciertos cambios. Haga clic en “Diff” o “Commit”. Seleccione un archivo con cambios que no desee. Utilice “Discard All” para descartar todos los cambios en ese archivo. Utilice “Discard chunk” para descartar cambios específicos en un archivo. Repita este procedimiento para cada archivo afectado hasta que vuelva a un estado aceptable. Continuar.\nSi confrimo una versión en mal estado, vaya a Capítulo 38 para ver más escenarios de reinicio.",
    "crumbs": [
      "Flujos de trabajo diarios",
      "<span class='chapter-number'>27</span>  <span class='chapter-title'>Enmendar repetidamente</span>"
    ]
  },
  {
    "objectID": "workflows-repeated-amend.html#por-qué-no-enviamos-el-progreso-intermedio",
    "href": "workflows-repeated-amend.html#por-qué-no-enviamos-el-progreso-intermedio",
    "title": "27  Enmendar repetidamente",
    "section": "27.4 ¿Por qué no enviamos el progreso intermedio?",
    "text": "27.4 ¿Por qué no enviamos el progreso intermedio?\nModificar una confirmación es un ejemplo de lo que se llama “reescribir el historial de Git”.\nReescribir el historial que ya ha sido enviado a GitHub (y, por lo tanto, potencialmente retirado por otra persona) es una práctica controvertida. Como la mayoría de las prácticas controvertidas, mucha gente todavía se entrega a ellas, al igual que yo.\nPero existe la posibilidad muy real de que crees dolores de cabeza a ti mismo y a los demás, por lo que en debemos recomendarte que te abstengas. Una vez que hayas enviado algo, considéralo escrito en piedra y sigue adelante.",
    "crumbs": [
      "Flujos de trabajo diarios",
      "<span class='chapter-number'>27</span>  <span class='chapter-title'>Enmendar repetidamente</span>"
    ]
  },
  {
    "objectID": "workflows-repeated-amend.html#um-y-si-lo-envie",
    "href": "workflows-repeated-amend.html#um-y-si-lo-envie",
    "title": "27  Enmendar repetidamente",
    "section": "27.5 Um, ¿y si lo envie?",
    "text": "27.5 Um, ¿y si lo envie?\n¡Te dije que no lo hicieras!\nPero bueno, aquí estamos.\nImaginemos que enviaste este estado a GitHub por error:\nA -- B -- C -- WIP (85bf30a)\ny procedió a git commit --amend nuevamente localmente, lo que llevó a este estado:\nA -- B -- C -- WIP* (6e884e6)\nEstoy mostrando deliberadamente dos historiales que parecen iguales, en términos de mensajes de confirmación. Pero el último SHA revela que en realidad son diferentes.\nEstás en un aprieto ahora, ya que no puedes hacer un simple enviar o importar. Una inserción será rechazada e importar probablemente dará lugar a una fusión que no desea.\nTienes dos opciones:\n\nSi tiene colaboradores que pueden haber retirado el repositorio en la confirmación WIP (85bf30a), debe considerar esa historia en particular como escrita en piedra ahora. Si hay algún trabajo muy valioso que solo existe localmente, como un archivo específico, guarde una copia de ese en una nueva ruta de archivo, temporalmente. Restablezca por completo su repositorio local a C (git reset --hard HEAD^) e importe de GitHub. GitHub y la historia local ahora muestran esto:\nA -- B -- C -- WIP (85bf30a)\nSi guardó algún trabajo valioso en una ruta de archivo temporal, importelo nuevamente al repositorio ahora; guardar, preparar, confirmar y enviar. GitHub y la historia local ahora muestran esto:\nA -- B -- C -- WIP (85bf30a) -- E\nSi no tiene colaboradores o tiene motivos para creer que no se han importado, puede reescribir el historial, incluso en GitHub. También puedes asegurarte de que tu confirmación local tenga un mensaje real que no sea “WIP” en este momento. Fuerza el envío de tu historial a GitHub (git push --force). GitHub y la historia local ahora muestran esto:\nA -- B -- C -- D\n\nEn ambos casos, has realizado los cambios que deseas y tu repositorio local y el control remoto de GitHub están sincronizados nuevamente. La historia es mejor en el segundo caso, pero eso es una cuestión secundaria.\nHay muchas maneras diferentes de reescribir la historia y rescatar algunas de estas situaciones, pero consideramos que los enfoques descritos anteriormente son muy accesibles.\n\n\n\n\nWickham, Hadley. 2015. R Packages. 1st ed. O’Reilly Media, Inc.",
    "crumbs": [
      "Flujos de trabajo diarios",
      "<span class='chapter-number'>27</span>  <span class='chapter-title'>Enmendar repetidamente</span>"
    ]
  },
  {
    "objectID": "workflows-push-rejected.html",
    "href": "workflows-push-rejected.html",
    "title": "28  Lidiar con el rechazo del envio",
    "section": "",
    "text": "28.1 ¡El que envia primero gana!\nProblema: desea enviar cambios a GitHub, pero lo rechazan así:\nEsto significa que su historial de Git local y el del control remoto de GitHub no son compatibles, es decir, han divergido.\nLe sugiero que use git status, su cliente Git, o visite su control remoto de GitHub en el navegador para obtener más información sobre la situación, es decir, para tener una idea de este trabajo que no hace. tener.\nEn resumen, este es el estado en GitHub:\nY este es tu estado local:\nNo puedes provocar que se produzca algún tipo de fusión en la copia de GitHub cuando envias.\nEn su lugar, debe extraer la confirmación C e integrarla de alguna manera en su historial que contiene D. Entonces podrás volver a enviar.\nEsto está cubierto en el flujo de trabajo Extraer, pero tienes trabajo local.\nPero antes de que contemplen todo el horror de esto, este es un buen momento para reflexionar sobre lo que podemos aprender de esta situación.\nEs posible que hayas notado que tú, el autor de D, estás jugando con Git más que la persona que confirmo y envió C, es decir, tu colaborador.\n¡Hay una lección que aprender aqui!\nSi hubieras enviado D primero, te estarías relajando y ellos estarían descubriendo cómo integrar C en su historial para poder enviar. Así que envia tu trabajo con frecuencia. No se quede a oscuras y trabaje “sin conexión” durante largos períodos de tiempo.\nObviamente, debes enviar el trabajo a main porque está “listo” para compartir (o al menos “lo suficientemente listo”), no para evitar fusiones de Git.\nHay un punto verdaderamente legítimo aquí: es mejor para la salud general de un proyecto confirmar, enviar e integrarse con más frecuencia, no menos. Esto no elimina la necesidad de integrar diferentes líneas de trabajo, pero hace que cada integración sea más pequeña, menos onerosa y menos propensa a errores.",
    "crumbs": [
      "Flujos de trabajo diarios",
      "<span class='chapter-number'>28</span>  <span class='chapter-title'>Lidiar con el rechazo del envio</span>"
    ]
  },
  {
    "objectID": "workflows-push-rejected.html#mantente-en-contacto",
    "href": "workflows-push-rejected.html#mantente-en-contacto",
    "title": "28  Lidiar con el rechazo del envio",
    "section": "28.2 Mantente en contacto",
    "text": "28.2 Mantente en contacto\nOtra conclusión es la siguiente: cuanto antes conozca C, mejor. Importe (o busque) con frecuencia.\nPensemos en tu confirmación D. Tal vez se desarrolló durante un par de días mediante el patrón de Enmendar repetidamente. Tal vez C estuvo ahí en GitHub todo el tiempo o apareció muy temprano en su proceso.\nConsidere que podría ser más fácil integrar C en su trabajo D más temprano que tarde. A veces esto no es cierto, pero más a menudo sí lo es.\nEn general, vale la pena estar consciente de manera proactiva de lo que otros están haciendo (por ejemplo, importar o buscar con frecuencia) que estar siempre en modo reactivo, aprendiendo sobre el trabajo de su colaborador sólo cuando su envio es rechazado.",
    "crumbs": [
      "Flujos de trabajo diarios",
      "<span class='chapter-number'>28</span>  <span class='chapter-title'>Lidiar con el rechazo del envio</span>"
    ]
  },
  {
    "objectID": "workflows-push-rejected.html#use-ramas",
    "href": "workflows-push-rejected.html#use-ramas",
    "title": "28  Lidiar con el rechazo del envio",
    "section": "28.3 Use ramas",
    "text": "28.3 Use ramas\nFinalmente, tus primeras experiencias colaborando con otros y contigo mismo en main te darán una comprensión visceral de por qué la mayoría de los usuarios de Git eventualmente comienzan a usar ramas.\nLas ramas ofrecen flujos de trabajo explícitos para integrar diferentes líneas de trabajo en sus propios términos. Esto es mucho mejor que intentar realizar una fusión complicada o un rebase en medio de un pánico frustrado, porque al final del día necesitas enviar tu trabajo a GitHub.",
    "crumbs": [
      "Flujos de trabajo diarios",
      "<span class='chapter-number'>28</span>  <span class='chapter-title'>Lidiar con el rechazo del envio</span>"
    ]
  },
  {
    "objectID": "workflows-pull.html",
    "href": "workflows-pull.html",
    "title": "29  Importar, pero tienes trabajo local",
    "section": "",
    "text": "29.1 El trabajo local no está confirmado.\nProblema: desea importar cambios desde el upstream, pero ha realizado algunos trabajos nuevos localmente desde la última vez que los realizó. Esto suele surgir porque lo que realmente quieres hacer es enviar, pero Git no te lo permitirá hasta que incorpores por primera vez los cambios anteriores.\nEn aras de la simplicidad, supongamos que estamos tratando con la rama upstream y la remota se llama origin.\nHistorial reciente de confirmaciones de origin/main:\nHistorial de confirmaciones recientes de la rama upstream local:\no tal vez\nSu objetivo: obtener la confirmación C en su rama local, manteniendo al mismo tiempo el trabajo en la confirmación D o sus cambios no confirmados.\nPriorizamos enfoques simples que son buenos para el uso inicial de Git, pero mencionamos alternativas más agradables a largo plazo.\nEl estado remoto es A--B--C.\nEl estado local es A--B--(cambiosnoconfirmados).",
    "crumbs": [
      "Flujos de trabajo diarios",
      "<span class='chapter-number'>29</span>  <span class='chapter-title'>Importar, pero tienes trabajo local</span>"
    ]
  },
  {
    "objectID": "workflows-pull.html#el-trabajo-local-no-está-confirmado.",
    "href": "workflows-pull.html#el-trabajo-local-no-está-confirmado.",
    "title": "29  Importar, pero tienes trabajo local",
    "section": "",
    "text": "29.1.1 Casos simples felices\nHay dos escenarios felices en los que git pull “simplemente funcionará”:\n\nHa introducido archivos completamente nuevos que no existen en la rama remota y, por lo tanto, no es posible que tengan cambios conflictivos. ¡Estás de suerte! Puedes simplemente git pull.\nLos archivos afectados por su trabajo local tienen CERO superposición con los archivos afectados por los cambios que necesita importar del control remoto. ¡Tú también estás de suerte! Puedes simplemente git pull.\n\nResumen de estos felices escenarios de git pull:\n                 Remote: A--B--C\n\nLocal before 'git pull': A--B--(cambiosnoconfirmados)\n Local after 'git pull': A--B--C--(cambiosnoconfirmados)\nLo que realmente sucedió aquí es que git pull resultó en una fusión rápida, es decir, colocamos la confirmación C justo al final de su historial. Este también sería el caso en la situación más simple en la que el historial local reciente fuera simplemente A--B, es decir, no se hubiera agregado ningún trabajo local desde la última sincronización con origin/main.\n\n\n29.1.2 git stash funciona, a veces\nSi sus cambios afectan un archivo (foo.R en el ejemplo siguiente) que también se modificó en la confirmación C, no puede git pull. No está de más intentarlo, pero fallarás y se verá así:\njenny@2015-mbp ethel $ git pull\nremote: Enumerating objects: 5, done.\nremote: Counting objects: 100% (5/5), done.\nremote: Compressing objects: 100% (2/2), done.\nremote: Total 3 (delta 1), reused 1 (delta 0), pack-reused 0\nUnpacking objects: 100% (3/3), done.\nFrom github.com:jennybc/ethel\n   db046b4..2d33a6f  main     -&gt; origin/main\nUpdating db046b4..2d33a6f\nerror: Your local changes to the following files would be overwritten by merge:\n        foo.R\nPlease commit your changes or stash them before you merge.\nAborting\n¿Ahora que? En primer lugar, debe salvaguardar los cambios locales guardándolos o confirmándolos. (Yo personalmente elegiría confirmar y ejecutar un flujo de trabajo descrito en Sección 29.2.)\nNo soy un gran admirador de git stash; Creo que normalmente es mejor aprovechar todas las oportunidades posibles para solidificar sus habilidades en torno a conceptos y operaciones centrales, por ejemplo, confirmar, posiblemente en una rama. Pero si desea utilizar git stash, esta oportunidad es la mejor posible.\ngit stash es una forma de almacenar temporalmente algunos cambios para eliminarlos. Ahora puedes hacer otra cosa, sin mucho problema. En nuestro caso, “hacer algo más” es obtener los cambios ascendentes con un simple y agradable git pull. Luego vuelves a aplicar, eliminas el stash y continúas donde lo dejaste.\nPara obtener más detalles sobre el almacenamiento, recomiendo\n\nLa cobertura oculta en el capítulo “Interacciones del sistema de archivos” de Git en la práctica (sitio web del libro o leer en GitHub)\n7.3 Herramientas Git: almacenamiento y limpieza En Git Pro.\n\nEste es el mejor escenario para “stash, pull, unstash” en el ejemplo anterior:\ngit stash save\ngit pull\ngit stash pop\nY aquí está el resultado de nuestro ejemplo:\njenny@2015-mbp ethel $ git stash save\nSaved working directory and index state WIP on main: db046b4 Merge branch 'main'of github.com:jennybc/ethel\n\njenny@2015-mbp ethel $ git pull\nUpdating db046b4..2d33a6f\nFast-forward\n foo.R | 2 +-\n 1 file changed, 1 insertion(+), 1 deletion(-)\n\njenny@2015-mbp ethel $ git stash pop\nAuto-merging foo.R\nOn branch main\nYour branch is up-to-date with 'origin/main'.\n\nChanges not staged for commit:\n  (use \"git add &lt;file&gt;...\" to update what will be committed)\n  (use \"git checkout -- &lt;file&gt;...\" to discard changes in working directory)\n\n        modified:   foo.R\n\nno changes added to commit (use \"git add\" and/or \"git commit -a\")\nDropped refs/stash@{0} (012c4dcd3a4c3af6757c4c3ca99a9eaeff1eb2a4)\nAsí es como se ve el éxito. Has logrado esto:\n      Remote: A--B--C\n\nLocal before: A--B--(cambiosnoconfrimados)\n Local after: A--B--C--(cambiosnoconfrimados)\nComo se indicó anteriormente, acabamos de disfrutar de una combinación de avance rápido, posible al ocultar temporalmente y luego desbloquear los cambios locales no confirmados.\n\n\n29.1.3 git stash con conflictos\nSi sus cambios locales se superponen con los cambios que está realizando, obtendrá un conflicto de fusión de git stash pop. Ahora tienes que hacer algunos trabajos de recuperación. En este caso, no has ganado nada al usar git stash en primer lugar, lo que explica mi falta general de entusiasmo por git stash.\nAquí se explica cómo ejecutar el flujo de trabajo git stash en nuestro ejemplo, frente a conflictos (basado en esta respuesta de Stack Overflow):\njenny@2015-mbp ethel $ git stash save\nSaved working directory and index state WIP on main: 2d33a6f Back to 5\n\njenny@2015-mbp ethel $ git pull\nUpdating 2d33a6f..1eddf9e\nFast-forward\n foo.R | 1 +\n 1 file changed, 1 insertion(+)\n \njenny@2015-mbp ethel $ git stash pop\nAuto-merging foo.R\nCONFLICT (content): Merge conflict in foo.R\nEn este punto, debes resolver el conflicto de fusión Sección 22.4. Literalmente, en cada lugar de conflicto, elija una versión u otra (anticipada o oculta) o cree un híbrido usted mismo. Retire todos los marcadores insertados para delimitar los conflictos. Guarde.\nDado que git stash pop no funcionó correctamente, debemos restablecer manualmente Sección 27.3 y eliminar el stash para finalizar.\njenny@2015-mbp ethel $ git reset\nUnstaged changes after reset:\nM       foo.R\n\njenny@2015-mbp ethel $ git stash drop\nDropped refs/stash@{0} (7928db50288e9b4d934803b6b451a000fd7242ed)\nUf, hemos terminado. Hemos logrado esto:\n      Remote: A--B--C\n\nLocal before: A--B--(cambiosnoconfirmados)\n Local after: A--B--C--(cambiosnoconfirmados*)\nEl asterisco en cambiosnoconfirmados* indica que sus cambios no confirmados ahora podrían reflejar los ajustes realizados cuando resolvió los conflictos.",
    "crumbs": [
      "Flujos de trabajo diarios",
      "<span class='chapter-number'>29</span>  <span class='chapter-title'>Importar, pero tienes trabajo local</span>"
    ]
  },
  {
    "objectID": "workflows-pull.html#sec-git-pull-with-local-commits",
    "href": "workflows-pull.html#sec-git-pull-with-local-commits",
    "title": "29  Importar, pero tienes trabajo local",
    "section": "29.2 El trabajo local está cnfirmado",
    "text": "29.2 El trabajo local está cnfirmado\nEl estado remoto es A--B--C.\nEl estado local es A--B--D.\n\n29.2.1 Importar (buscar y fusionar)\nLa opción más sencilla es recuperar las confirmaciones desde arriba y fusionarlas, que es lo que hace git pull. Esta es una buena opción si eres nuevo en Git. Esto lleva a una historia más complicada, pero cuando eres nuevo, esta es la menor de tus preocupaciones. Fúndete, sé feliz y continúa.\nAquí está el mejor caso, la versión sin conflictos de fusión de git pull:\njenny@2015-mbp ethel $ git pull\n\n&lt; PROBABLEMENTE SERÁS ENVIADO A UN EDITOR AQUÍ RE: ¡MENSAJE DE COMUNICACIÓN DE FUSIÓN! &gt;\n\nMerge made by the 'recursive' strategy.\n README.md | 4 ++--\n 1 file changed, 2 insertions(+), 2 deletions(-)\nDependiendo de su versión de Git, su configuración y su uso de una GUI, es posible que deba confirmar/editar un mensaje de confirmación para la confirmación de fusión.\n¿O qué pasa si las cosas no van tan bien? Si la confirmación C (en el control remoto) y la confirmación D (local) tienen cambios en las mismas partes de uno o más archivos, es posible que Git no pueda fusionarse automáticamente y obtendrá conflictos de fusión. Se verá algo como esto:\njenny@2015-mbp ethel $ git pull\nAuto-merging foo.R\nCONFLICT (content): Merge conflict in foo.R\nAutomatic merge failed; fix conflicts and then commit the result.\nDebes resolver estos conflictos Sección 22.4. Literalmente, en cada lugar de conflicto, elija una versión u otra (ascendente o local) o cree un híbrido usted mismo. Retire todos los marcadores insertados para delimitar los conflictos. Guarde.\nMarque el archivo afectado foo.R como resuelto mediante git add y haga un git commit explícito para finalizar esta fusión.\njenny@2015-mbp ethel $ git add foo.R\njenny@2015-mbp ethel $ git commit\n[main 20b297b] Merge branch 'main' of github.com:jennybc/ethel\nNuevamente, no se sorprenda si, durante el git commit, se encuentra en un editor, confirmando/editando el mensaje de confirmación para la confirmación de fusión.\nHemos logrado esto:\n      Remote: A--B--C\n\nLocal before: A--B--D\n Local after: A--B--D--(confirmación de fusión)\n                  \\_C_/\n\n\n29.2.2 Importar y rebase\ngit pull --rebase crea una historia mejor que git pull al integrar confirmaciones locales y remotas. Evita una confirmación de fusión, por lo que el historial está menos desordenado y es lineal. Puede hacer que los conflictos de fusión sean más difíciles de resolver, por lo que sigo recomendando git pull como solución básica.\nAquí está el mejor caso, la versión sin conflictos de fusión de git pull --rebase:\njenny@2015-mbp ethel $ git pull --rebase\nFirst, rewinding head to replay your work on top of it...\nApplying: Take max\nTenga en cuenta que NO lo enviaron a un editor para manipular el mensaje de confirmación para la confirmación de fusión, ¡porque no hay confirmación de fusión! Ésta es la belleza del rebase.\nHemos logrado esto:\n      Remote: A--B--C\n\nLocal before: A--B--D\n Local after: A--B--C--D\nEs como si sacáramos el trabajo ascendente en la confirmación C y luego hiciéramos el trabajo local incorporado en la confirmación D. No tenemos confirmaciones de fusión desordenadas y un historial lineal. ¡Lindo!\nLa mala noticia: al igual que con git pull simple, todavía es posible tener conflictos de fusión con git pull --rebase. Si tiene varias confirmaciones locales, incluso puede encontrarse resolviendo conflictos una y otra vez, ya que estas confirmaciones se reproducen secuencialmente. Por lo tanto, esto es más adecuado para usuarios de Git más experimentados y en situaciones donde los conflictos son poco probables (en realidad, tienden a estar correlacionados).\nEn este punto, si intentas hacer git pull --rebase y te atascas en conflictos de fusión, te recomiendo git rebase --abort para retroceder. Por ahora, simplemente siga una estrategia más sencilla.",
    "crumbs": [
      "Flujos de trabajo diarios",
      "<span class='chapter-number'>29</span>  <span class='chapter-title'>Importar, pero tienes trabajo local</span>"
    ]
  },
  {
    "objectID": "workflows-pull.html#otros-enfoques",
    "href": "workflows-pull.html#otros-enfoques",
    "title": "29  Importar, pero tienes trabajo local",
    "section": "29.3 Otros enfoques",
    "text": "29.3 Otros enfoques\nHay muchas más formas de manejar esta situación, que puedes descubrir y explorar a medida que adquieres experiencia y empiezas a preocuparte más por la historia. Esbozamos aquí algunas ideas.\n\n29.3.1 Utilice una rama temporal para el trabajo local\nRecordar:\nEl estado remoto es A--B--C.\nEl estado local es A--B--(cambiosnoconfirmados).\nEsta es una alternativa al flujo de trabajo oculto que tiene la ventaja de brindarle práctica con técnicas de Git que son más útiles en general. También conduce a una bonita historia.\nCree una nueva rama temporal y confirme allí los cambios no confirmados. Consulte main y git pull para obtener cambios desde arriba. Ahora necesitas recuperar el trabajo de la confirmación en la rama temporal. Opciones:\n\nFusiona la rama temporal en main.\nCherry elige la confirmación de la rama temporal a main.\n\nEn cualquier caso, aún es posible que tengas que lidiar con conflictos de fusión.\nEn cualquier caso, si se sintió obligado a confirmar antes de estar listo o a aceptar una confirmación de fusión fea, puede realizar un reinicio mixto para “desconfirmar” pero mantener los cambios en main o seguir modificando hasta que esté satisfecho con la confirmación.",
    "crumbs": [
      "Flujos de trabajo diarios",
      "<span class='chapter-number'>29</span>  <span class='chapter-title'>Importar, pero tienes trabajo local</span>"
    ]
  },
  {
    "objectID": "workflows-pull.html#algunos-trabajos-locales-están-confirmados-otros-no.",
    "href": "workflows-pull.html#algunos-trabajos-locales-están-confirmados-otros-no.",
    "title": "29  Importar, pero tienes trabajo local",
    "section": "29.4 Algunos trabajos locales están confirmados, otros no.",
    "text": "29.4 Algunos trabajos locales están confirmados, otros no.\nEsta es una situación híbrida incómoda que se puede manejar con una combinación de estrategias vistas anteriormente: realizar una confirmación pragmática en main o una rama temporal. Integre los cambios locales y ascendentes en main. Si no está satisfecho con la confirmación pragmática final (que solo existe localmente), reiníciela o modifíquela hasta que lo esté.",
    "crumbs": [
      "Flujos de trabajo diarios",
      "<span class='chapter-number'>29</span>  <span class='chapter-title'>Importar, pero tienes trabajo local</span>"
    ]
  },
  {
    "objectID": "workflows-see-the-past.html",
    "href": "workflows-see-the-past.html",
    "title": "30  Viaje en el tiempo: ver el pasado",
    "section": "",
    "text": "30.1 ¡Los hipervínculos son increíbles!\nA veces solo necesitas ver varios archivos de tu proyecto tal como estaban en algún momento importante del pasado. Ejemplos:\nTodos los proyectos pasan por varios estados que usted considera “buenos” versus “malos” o algo intermedio. Puede resultar útil explorar el pasado cuando se intenta llegar a un “buen” estado.\nAquí es donde GitHub (y GitLab o BitBucket) realmente brillan. La capacidad de explorar rápidamente diferentes confirmaciones/estados, cambiar entre ramas, inspeccionar archivos individuales y ver la discusión en temas vinculados es increíblemente poderosa.\nSí, técnicamente, puedes visitar estados anteriores de tu proyecto usando comandos de Git localmente. Pero es mucho más complicado. Por lo general, hay que verificar estos estados anteriores, lo que aumenta la posibilidad de sentirse cómodo en el estado de “detached head” y, sin querer, realizar nuevas confirmaciones en la rama equivocada o en ninguna rama.\nLa presentación rica en hipervínculos de GitHub de su repositorio y su historial es una de las principales razones para sincronizar el trabajo local con una copia en GitHub, incluso si lo mantiene privado. Puede ser mucho más fácil concentrarse en un estado o cambio de interés haciendo clic o usando las funciones de búsqueda de GitHub. Además, debido a que es claramente una acción remota y de solo lectura, no hay posibilidad de cometer un error en el estado local o enviar un nuevo trabajo a la rama equivocada.",
    "crumbs": [
      "Flujos de trabajo diarios",
      "<span class='chapter-number'>30</span>  <span class='chapter-title'>Viaje en el tiempo: ver el pasado</span>"
    ]
  },
  {
    "objectID": "workflows-see-the-past.html#explorar-el-historial-de-confirmaciones-y-confirmaciones-específicas",
    "href": "workflows-see-the-past.html#explorar-el-historial-de-confirmaciones-y-confirmaciones-específicas",
    "title": "30  Viaje en el tiempo: ver el pasado",
    "section": "30.2 Explorar el historial de confirmaciones y confirmaciones específicas",
    "text": "30.2 Explorar el historial de confirmaciones y confirmaciones específicas\nDesde la página de inicio de su repositorio, acceda al historial de confirmaciones haciendo clic en “xyz commits”. Esto es como usar git log localmente, pero mucho más gratificante. Si tiene un buen cliente Git local, probablemente también proporcione una descripción gráfica del historial.\n\n\n\nEnlace para confirmar la lista en GitHub.\n\n\nUna vez que esté viendo el historial, observe tres formas de acceder a más información para cada confirmación:\n\nEl icono del portapapeles copia el SHA-1 de la confirmación. Esto puede resultar útil si necesita consultar esta confirmación en otro lugar, p. en un hilo de problema o un mensaje de confirmación o en un comando de Git que estás formando para ejecución local.\nHaga clic en el SHA-1 abreviado para ver la diferencia asociada con la confirmación.\nHaga clic en los corchetes angulares dobles &lt;&gt; para explorar el estado de todo el repositorio en ese punto de la historia.\n\n\n\n\nEjemplo de listado de confirmaciones en GitHub.\n\n\nSalga de cualquier vista detallada haciendo clic en USTED/REPO para regresar a la página de inicio de su repositorio. Esto lo devuelve al estado actual y al nivel superior de su repositorio.\n\n30.2.1 ¡Utilice hipervínculos usted mismo!\nUna vez que haya identificado una confirmación, diferencia o estado de archivo relevante, puede copiar la URL actual desde su navegador y usarla para mejorar la discusión en línea en otros lugares, es decir, para llevar a otras personas a esta vista exacta del repositorio. Los hipervínculos de los repositorios alojados en GitHub pueden hacer que la discusión en línea de un proyecto sea mucho más precisa y eficiente.",
    "crumbs": [
      "Flujos de trabajo diarios",
      "<span class='chapter-number'>30</span>  <span class='chapter-title'>Viaje en el tiempo: ver el pasado</span>"
    ]
  },
  {
    "objectID": "workflows-see-the-past.html#consultas-basadas-en-archivos",
    "href": "workflows-see-the-past.html#consultas-basadas-en-archivos",
    "title": "30  Viaje en el tiempo: ver el pasado",
    "section": "30.3 Consultas basadas en archivos",
    "text": "30.3 Consultas basadas en archivos\n¿Qué sucede si está interesado en saber cómo un archivo específico llegó a ser como es? Primero navegue hasta el archivo, luego observe “Blame” e “History” en la esquina superior derecha.\n\n\n\nVisitando un archivo específico en GitHub.\n\n\n\n30.3.1 Blame\nLa vista de “blame” de un archivo está relacionada con lo que hace git blame en la línea de comando. Revela quién tocó por última vez cada línea del archivo, hace cuánto tiempo y el mensaje de confirmación asociado. Haga clic en el mensaje de confirmación para visitar esa confirmación. O haga clic en el icono de “rectángulos apilados” para retroceder en el tiempo, pero manteniendo la vista de culpa. Esto es útil cuando se realizan análisis forenses en un conjunto pequeño y específico de líneas.\nagregue una captura de pantalla (y actualícela arriba) pero primero elija un ejemplo mejor que Happy Git, es decir, uno con más contribuyentes/historial más interesante\n\n\n30.3.2 Historial\nLa vista de “history” de un archivo es muy parecida al historial general de confirmaciones descrito anteriormente, excepto que solo incluye confirmaciones que afectan el archivo de interés. Esto puede resultar útil cuando su consulta es bastante difusa y está intentando digerir el arco argumental general de un archivo.\n\n\n30.3.3 Hipervínculo a líneas específicas en un estado específico\nAl ver un archivo en GitHub, puede hacer clic en un número de línea para resaltarlo. Utilice “hacer clic… mayús-clic” para seleccionar un rango de líneas. Observe que la URL de su navegador muestra algo parecido a este:\nhttps://github.com/OWNER/REPO/blob/SHA/path/to/file.R#L27-L31\nSi la URL no contiene el SHA, escriba “y” para alternar a ese formulario.\nEstas URL específicas de archivos y SHA son una excelente manera de señalar a las personas líneas de código particulares en conversaciones en línea. Es una buena práctica utilizar los enlaces más feos que contienen SHA, ya que resistirán la prueba del tiempo.",
    "crumbs": [
      "Flujos de trabajo diarios",
      "<span class='chapter-number'>30</span>  <span class='chapter-title'>Viaje en el tiempo: ver el pasado</span>"
    ]
  },
  {
    "objectID": "workflows-see-the-past.html#buscar",
    "href": "workflows-see-the-past.html#buscar",
    "title": "30  Viaje en el tiempo: ver el pasado",
    "section": "30.4 Buscar",
    "text": "30.4 Buscar\nLa búsqueda siempre está disponible en la esquina superior derecha de GitHub.\n\n\n\nEscribiendo en la barra de búsqueda de GitHub.\n\n\nUna vez que ingresa algo de texto en el cuadro de búsqueda, un menú desplegable le brinda la opción de buscar en el repositorio actual (el predeterminado) o en todo GitHub. GitHub busca el contenido de los archivos (descritos como “Code”), confirma mensajes y problemas. Aproveche los resultados de búsqueda en estos diferentes dominios. Nuevamente, esta es una manera poderosa de acercarse a líneas de código específicas, volver a visitar un momento interesante en la historia del proyecto o redescubrir un hilo de conversación.\n\n30.4.1 Búsqueda de problemas\nSi desea buscar problemas específicamente, el cuadro de búsqueda en la página de Problemas de cualquier repositorio está precargado con los filtros is:issue y is:open.",
    "crumbs": [
      "Flujos de trabajo diarios",
      "<span class='chapter-number'>30</span>  <span class='chapter-title'>Viaje en el tiempo: ver el pasado</span>"
    ]
  },
  {
    "objectID": "workflows-fork-and-clone.html",
    "href": "workflows-fork-and-clone.html",
    "title": "31  Bifurcar y clonar",
    "section": "",
    "text": "31.1 Bifurcar y clonar sin usethis\nUtilice bifurcar y clonar para obtener una copia del repositorio de otra persona si existe alguna posibilidad de que desee proponer un cambio al propietario, es decir, enviar una solicitud de cambio. Si está dudando entre “simplemente clonar” y “bifurcar y clonar”, opte por “bifurcar y clonar”.\nQueremos lograr esto:\nA continuación mostramos un par de métodos para bifurcar y clonar y debes elegir uno:\nVocabulario: DUEÑO/REPO se refiere a lo que llamamos el repositorio fuente, propiedad de DUEÑO, que no eres tú. TU/REPO se refiere a su bifurcación, es decir, su copia remota del repositorio fuente, en GitHub. Este es el mismo vocabulario utilizado en otros lugares, como el capítulo sobre configuraciones remotas comunes.\nEste es un buen momento para navegar hasta el repositorio GitHub de interés, es decir, el repositorio fuente. DUEÑO/REPO.\nSupongo que ya estás visitando el repositorio fuente en el navegador. En la esquina superior derecha, haz clic en Bifurcación.\nEsto crea una copia de REPO en su cuenta de GitHub y lo lleva allí en el navegador. Ahora estamos mirando TU/REPO.\nClonar TU/REPO, que es tu copia del repositorio, también conocido como tu bifurcación, en tu máquina local. Asegúrese de clonar su repositorio, no el repositorio de origen. En otro lugar, describimos múltiples métodos para clonar un repositorio remoto. Elegir uno:\nTome una decisión consciente sobre el directorio de destino local y la URL HTTPS versus SSH.",
    "crumbs": [
      "Flujos de trabajo diarios",
      "<span class='chapter-number'>31</span>  <span class='chapter-title'>Bifurcar y clonar</span>"
    ]
  },
  {
    "objectID": "workflows-fork-and-clone.html#bifurcar-y-clonar-sin-usethis",
    "href": "workflows-fork-and-clone.html#bifurcar-y-clonar-sin-usethis",
    "title": "31  Bifurcar y clonar",
    "section": "",
    "text": "Las instrucciones de clonación en Proyecto existente, GitHub primero cubrir usethis y RStudio.\nLas instrucciones de clonación en Conectarse a GitHub muestra cómo hacer esto con la línea de comando Git.\n\n\n\n31.1.1 Finaliza la configuración de bifurcación y clonación.\nSi se detiene en este punto, tendrá lo que considero una configuración incompleta, descrita en otro lugar como “fork (salvable)”.\n\n\n\n\nEsto es triste, porque no existe una conexión directa entre su copia local del repositorio y el repositorio fuente TU/REPO.\nHay dos piezas de configuración más recomendadas:\n\nConfigure el repositorio de origen como upstream remoto\nConfigure su rama main local (o cualquiera que sea la predeterminada) para rastrear upstream/main, no origin/main\n\n\nEl apodo upstream técnicamente puede ser lo que quieras. Existe una fuerte tradición de utilizar upstream en este contexto y, aunque tengo mejores ideas, creo que es mejor conformarme. Cada libro, publicación de blog e hilo de Stack Overflow que lea utilizará upstream aquí. Guarda tu energía psíquica para otras cosas.\nEstos pasos le facilitan mantenerse actualizado con los desarrollos en el repositorio de origen. Hablamos más a continuación sobre por qué nunca debes confirmar con la rama predeterminada, p. main, cuando estás trabajando en una bifurcación (ver Sección 31.4).\n\n31.1.2 Configurar el control remoto upstream\n\nEl primer paso es obtener la URL del repositorio fuente DUEÑO/REPO. Navegue hasta el repositorio de origen en GitHub. Es fácil llegar desde su bifurcación, TU/REPO, a través del enlace “forked from” en la parte superior izquierda.\nUtilice el gran botón verde “Code” para obtener la URL de DUEÑO/REPO en su portapapeles. Sea intencional al copiar la URL HTTPS o SSH.\nPuede configurar el control remoto upstream con la línea de comando Git, usethis o RStudio.\nA continuación se explica cómo utilizar la línea de comandos de Git en un shell:\ngit remote add upstream https://github.com/OWNER/REPO.git\nusethis::use_git_remote() le permite configurar un control remoto Git. Ejecute esto en R:\n\nusethis::use_git_remote(\n  name = \"upstream\",\n  url = \"https://github.com/DUEÑO/REPO.git\"\n)\n\nFinalmente, puedes hacer esto en RStudio, aunque parece un poco extraño. Haga clic en “New Branch” en el panel de Git (“dos cuadros morados y un cuadrado blanco”).\n\n\n\n\nEsto revelará un botón para “Agregar control remoto”. Pinchalo. Ingrese upstream como nombre remoto y pegue la URL de DUEÑO/REPO que obtuvo de GitHub. Haga clic en “Agregar”. Rechace la oportunidad de agregar una nueva rama haciendo clic en “Cancelar”.\nIndependientemente de cómo haya configurado upstream, haga esto en un shell:\ngit fetch upstream\n\n31.1.3 Configurar la rama de seguimiento ascendente para la rama predeterminada\nEsto es opcional pero muy recomendable para la mayoría de situaciones de bifurcación y clonación. Vamos a configurar upstream/main desde el repositorio de origen como la rama de seguimiento ascendente del main local. (Si su sucursal predeterminada tiene un nombre diferente, sustitúyalo según corresponda.)\nEsto es deseable para que un simple git pull importe cambios del repositorio fuente, no de su bifurcación. También significa que un simple git push (intentará) enviar al repositorio de origen, que casi siempre será rechazado ya que probablemente no tenga permiso. Esta falla le alertará del hecho de que está haciendo algo cuestionable, aunque aún será fácil echarse atrás.\nPrimero, obtenga información para el control remoto upstream. Esto es especialmente importante si acaba de configurar upstream por primera vez.\ngit fetch upstream\nLos dos comandos siguientes hacen lo mismo; el primero es sólo una abreviatura del segundo. Haga esto con la línea de comando Git en un shell:\ngit branch -u upstream/main\ngit branch --set-upstream-to upstream/main\nSi este flujo de trabajo de bifurcación y clonación le pareció largo y tedioso, ¡considere usar usethis::create_from_github() la próxima vez!",
    "crumbs": [
      "Flujos de trabajo diarios",
      "<span class='chapter-number'>31</span>  <span class='chapter-title'>Bifurcar y clonar</span>"
    ]
  },
  {
    "objectID": "workflows-fork-and-clone.html#sec-fork-and-clone-create-from-github",
    "href": "workflows-fork-and-clone.html#sec-fork-and-clone-create-from-github",
    "title": "31  Bifurcar y clonar",
    "section": "\n31.2 usethis::create_from_github(\"OWNER/REPO\", fork = TRUE)\n",
    "text": "31.2 usethis::create_from_github(\"OWNER/REPO\", fork = TRUE)\n\nEl paquete usethis tiene una función conveniente, create_from_github(), que puede hacer “bifurcación y clonación” (además de simplemente clonar). El argumento fork controla si el repositorio fuente está clonado o bifurcado y clonado. Tenga en cuenta que create_from_github(fork = TRUE) requiere que haya configurado un token de acceso personal de GitHub.\nSupongo que ya estás visitando el repositorio fuente en el navegador. Ahora haga clic en el gran botón verde que dice “&lt;&gt; Código”. Copie una URL clonada a su portapapeles. Si sigue nuestro consejo predeterminado, copie la URL HTTPS. Pero si opta por SSH, asegúrese de copiar la URL de SSH.\nPuede ejecutar el siguiente comando en cualquier sesión de R. Si usa RStudio, hágalo en la consola R de cualquier instancia de RStudio. En cualquier caso, después de completarlo exitosamente, deberías encontrarte en el nuevo proyecto que es el repositorio local conectado a tu bifurcación.\n\nusethis::create_from_github(\n  \"https://github.com/DUEÑO/REPO\",\n  destdir = \"~/ruta/a/dónde/quieres/el/local/repositorio/\",\n  fork = TRUE\n)\n\nEl primer argumento es repo_spec y acepta la especificación del repositorio de GitHub en varias formas. En particular, puede utilizar la URL que acabamos de copiar para el repositorio fuente.\nEl argumento destdir especifica el directorio principal donde desea que resida la nueva carpeta (y el repositorio local de Git). Si no especifica destdir, use este valor predeterminado en algún lugar muy visible, como su escritorio. Si desea mantener los repositorios de Git en una determinada carpeta de su computadora, puede personalizar este valor predeterminado configurando la opción usethis.destdir en su .Rprofile.\nEl argumento fork especifica si se debe clonar (fork = FALSE) o bifurcar y clonar (fork = TRUE). A menudo no es necesario especificar “fork” y simplemente puedes disfrutar del comportamiento predeterminado, que se rige por tus permisos en el repositorio de origen. De forma predeterminada, fork = FALSE si puede enviar al repositorio de origen y fork = TRUE si no puede.\nAsí es como podría verse (tenga en cuenta que aceptamos el comportamiento predeterminado para muchos argumentos):\n\nusethis::create_from_github(\"https://github.com/DUEÑO/REPO\")\n#&gt; ℹ Defaulting to 'https' Git protocol\n#&gt; ✔ Setting `fork = TRUE`\n#&gt; ✔ Creating '/aluguna/rutal/al/local/REPO/'\n#&gt; ✔ Forking 'DUEÑO/REPO'\n#&gt; ✔ Cloning repo from 'https://github.com/TU/REPO.git' into '/alguna/ruta/al/local/REPO'\n#&gt; ✔ Setting active project to '/alguna/ruta/al/local/REPO'\n#&gt; ℹ Default branch is 'main'\n#&gt; ✔ Adding 'upstream' remote: 'https://github.com/DUEÑO/REPO.git'\n#&gt; ✔ Pulling changes from 'upstream/main'.\n#&gt; ✔ Setting remote tracking branch for local 'main' branch to 'upstream/main'\n#&gt; ✔ Setting active project to '&lt;no active project&gt;'\n\nPara un usuario de RStudio, create_from_github(fork = TRUE) hace todo esto:\n\nBifurca el repositorio fuente en GitHub.\nClona tu bifurcación en un nuevo repositorio local (y en el Proyecto RStudio). Esto configura su bifurcación como el control remoto origin.\nConfigura el repositorio de origen como el repositorio remoto upstream.\nEstablece la rama de seguimiento ascendente para main (o cualquiera que sea la rama predeterminada) en upstream/main.\nAbre una nueva instancia de RStudio en el nuevo repositorio local (y RStudio Project).",
    "crumbs": [
      "Flujos de trabajo diarios",
      "<span class='chapter-number'>31</span>  <span class='chapter-title'>Bifurcar y clonar</span>"
    ]
  },
  {
    "objectID": "workflows-fork-and-clone.html#interactúe-con-el-nuevo-repositorio",
    "href": "workflows-fork-and-clone.html#interactúe-con-el-nuevo-repositorio",
    "title": "31  Bifurcar y clonar",
    "section": "\n31.3 Interactúe con el nuevo repositorio",
    "text": "31.3 Interactúe con el nuevo repositorio\nSi usaste usethis::create_from_github()o bifurcó y clonó a través de Proyecto existente, GitHub primero, probablemente esté en un proyecto RStudio para este nuevo repositorio.\nDe todos modos, únete a este proyecto, sea lo que sea que eso signifique para ti, utilizando tu método habitual.\nExplore el nuevo repositorio de alguna manera adecuada. Si es un paquete, puede ejecutar las pruebas o verificarlo. Si se trata de un proyecto de análisis de datos, ejecute un script o renderice un Rmd. Convéncete de que has recibido el código.\nAhora debería estar en la posición perfecta para sincronizarse con los desarrollos en curso en el repositorio de origen y proponer nuevos cambios a través de una solicitud de cambios desde su bifurcación.\n{fig-align=“center” fig-alt = “Fork and clone, ideal setup.” width=“60%”}\nPuede utilizar los siguientes comandos para revisar más detalles esenciales de Git de su configuración de bifurcación y clonación:\n\nLínea de comando Git en un shell:\n\ngit remote -v\n\ngit remote show origin (o upstream)\ngit branch -vv\n\n\nEn R:\n\nusethis::git_remotes()\nusethis::git_sitrep()\n\n\n\nEn el shell, git remote -v debería revelar que sus controles remotos están configurados así:\norigin    https://github.com/YOU/REPO.git (fetch)\norigin    https://github.com/YOU/REPO.git (push)\nupstream  https://github.com/OWNER/REPO.git (fetch)\nupstream  https://github.com/OWNER/REPO.git (push)\nInformación comparable está disponible en R con usethis::git_remotes():\n\ngit_remotes()\n#&gt; $origin\n#&gt; [1] \"https://github.com/YOU/REPO.git\"\n#&gt; \n#&gt; $upstream\n#&gt; [1] \"https://github.com/OWNER/repo.git\"\n\nEn el shell, con la rama predeterminada seleccionada, git branch -vv debería revelar que upstream/main es la rama de seguimiento ascendente:\n~/some/repo/ % git branch -vv                   \n* main 2739987 [upstream/main] Some commit message\nToda esta información sobre controles remotos y sucursales también se incluye en la rica información reportada con usethis::git_sitrep().",
    "crumbs": [
      "Flujos de trabajo diarios",
      "<span class='chapter-number'>31</span>  <span class='chapter-title'>Bifurcar y clonar</span>"
    ]
  },
  {
    "objectID": "workflows-fork-and-clone.html#sec-fork-dont-touch-main",
    "href": "workflows-fork-and-clone.html#sec-fork-dont-touch-main",
    "title": "31  Bifurcar y clonar",
    "section": "\n31.4 No te metas con main\n",
    "text": "31.4 No te metas con main\n\nAquí hay algunos consejos finales sobre cómo trabajar en una situación de bifurcación y clonación.\nSi realiza alguna confirmación en su repositorio local, recomiendo encarecidamente que trabaje en una nueva rama, no en main (o como se llame la rama predeterminada).\nLe recomiendo enfáticamente que no realice confirmaciones con el main de un repositorio que haya bifurcado. Si se confirma main en un repositorio que no es de su propiedad, se crea una divergencia entre el historial de esa rama en el repositorio de origen y en su repositorio. De esto no surgirá más que dolor. (Si ya ha hecho esto, discutiremos cómo solucionar la situación en Um, ¿qué pasa si toco main?.)\nCuando tratas main como de solo lectura, hace la vida mucho más fácil cuando quieres importar upstream en tu copia. El DUEÑO de REPO también estará más feliz de recibir su solicitud de cambio de una rama que no sea main.\nPara obtener más detalles, estas preguntas y respuestas sobre Stack Overflow son útiles: ¿Por qué es una mala práctica confirmar en la rama maestra de su bifurcación?.",
    "crumbs": [
      "Flujos de trabajo diarios",
      "<span class='chapter-number'>31</span>  <span class='chapter-title'>Bifurcar y clonar</span>"
    ]
  },
  {
    "objectID": "workflows-upstream-changes-into-fork.html",
    "href": "workflows-upstream-changes-into-fork.html",
    "title": "32  Importar cambios de upstream en una bifurcación",
    "section": "",
    "text": "32.1 Verifique la configuración de su repositorio local\nEste flujo de trabajo es relevante si ha realizado bifurcación y clonación y ahora necesita incorporar los cambios posteriores del repositorio de origen a su copia. Estamos hablando tanto de tu bifurcación (tu copia remota del repositorio, en GitHub) como de tu copia local.\nEsta es la situación inicial ideal:\nPrimero, verificaremos activamente la configuración anterior. Si su configuración no es óptima, discutiremos cómo solucionarlo.\nVocabulario: DUEÑO/REPO se refiere a lo que llamamos el repositorio fuente, propiedad de DUEÑO, que no eres tú. TU/REPO se refiere a su bifurcación, es decir, su copia remota del repositorio fuente, en GitHub. Este es el mismo vocabulario utilizado en otros lugares, como el capítulo sobre configuraciones remotas comunes.",
    "crumbs": [
      "Flujos de trabajo diarios",
      "<span class='chapter-number'>32</span>  <span class='chapter-title'>Importar cambios de upstream en una bifurcación</span>"
    ]
  },
  {
    "objectID": "workflows-upstream-changes-into-fork.html#verifique-la-configuración-de-su-repositorio-local",
    "href": "workflows-upstream-changes-into-fork.html#verifique-la-configuración-de-su-repositorio-local",
    "title": "32  Importar cambios de upstream en una bifurcación",
    "section": "",
    "text": "32.1.1 Lista tus controles remotos\nInspeccionemos los controles remotos actuales para su repositorio local.\nPuedes comprobar esto con la línea de comando Git en el shell (Apéndice A):\ngit remote -v\nQueremos ver algo como esto:\norigin    https://github.com/YOU/REPO.git (fetch)\norigin    https://github.com/YOU/REPO.git (push)\nupstream  https://github.com/OWNER/REPO.git (fetch)\nupstream  https://github.com/OWNER/REPO.git (push)\nInformación comparable está disponible en R con usethis::git_remotes():\n\ngit_remotes()\n#&gt; $origin\n#&gt; [1] \"https://github.com/YOU/REPO.git\"\n#&gt; \n#&gt; $upstream\n#&gt; [1] \"https://github.com/OWNER/repo.git\"\n\nSi solo tiene un control remoto, probablemente origin, le recomiendo que modifique la configuración del control remoto. Pero primero comprobaremos otra cosa.\n\n32.1.2 Ver la rama de seguimiento ascendente\nIdealmente, su rama main local tiene upstream/main como su rama de seguimiento ascendente. Incluso si tiene un control remoto upstream configurado correctamente, vale la pena comprobarlo. Si su rama predeterminada tiene una rama distinta a main, sustitúyala según corresponda.\nEn el shell, con la rama predeterminada seleccionada, git branch -vv debería revelar que upstream/main es la rama de seguimiento ascendente:\n~/some/repo/ % git branch -vv                   \n* main 2739987 [upstream/main] Some commit message\nSi, en cambio, ve origin/main, le recomiendo que reconfigure la rama de seguimiento.\nToda esta información sobre controles remotos y sucursales también se incluye en la rica información reportada con usethis::git_sitrep().\n\n32.1.3 Repara o completa la configuración de tu repositorio\nLas instrucciones para agregar el control remoto upstream y configurar el seguimiento ascendente para su rama predeterminada se proporcionan en Finalizar la configuración de bifurcación y clonación.",
    "crumbs": [
      "Flujos de trabajo diarios",
      "<span class='chapter-number'>32</span>  <span class='chapter-title'>Importar cambios de upstream en una bifurcación</span>"
    ]
  },
  {
    "objectID": "workflows-upstream-changes-into-fork.html#verifica-que-tu-árbol-de-trabajo-esté-limpio",
    "href": "workflows-upstream-changes-into-fork.html#verifica-que-tu-árbol-de-trabajo-esté-limpio",
    "title": "32  Importar cambios de upstream en una bifurcación",
    "section": "\n32.2 Verifica que tu “árbol de trabajo esté limpio”",
    "text": "32.2 Verifica que tu “árbol de trabajo esté limpio”\nAsumimos que su repositorio tiene esta configuración favorable:\n\n\n\n\nAsegúrate de estar en la rama predeterminada, p. main, y que su “árbol de trabajo esté limpio”. Primero, asegurémonos de que nuestra información en el control remoto upstream esté actualizada:\ngit fetch upstream\ngit status ahora debería mostrar algo como:\nOn branch main\nYour branch is up to date with 'origin/main'.\n\nnothing to commit, working tree clean\nSi ha modificado archivos, debe descartar esos cambios o crear una nueva rama y confirmar los cambios allí para guardarlos.\nTambién está bien si ves algo como esto:\nYour branch is behind 'upstream/main' by 2 commits, and can be fast-forwarded.\nSin embargo, si ve algo como esto:\nYour branch is ahead of 'upstream/main' by 1 commit.\no esto:\nYour branch and 'upstream/main' have diverged,\nand have 1 and 1 different commits each, respectively.\nEsta es una señal de que ha tomado algunas decisiones lamentables.\nLe recomiendo que nunca haga sus propias confirmaciones con la rama predeterminada de una bifurcación o con cualquier rama de la que no sea (co)propietario efectivamente. Sin embargo, si ya lo ha hecho, le explicamos cómo solucionar el problema en Um, ¿qué pasa si toco main?.",
    "crumbs": [
      "Flujos de trabajo diarios",
      "<span class='chapter-number'>32</span>  <span class='chapter-title'>Importar cambios de upstream en una bifurcación</span>"
    ]
  },
  {
    "objectID": "workflows-upstream-changes-into-fork.html#opción-de-sincronización-1-importe-los-cambios-desde-upstream-y-luego-envíelos-a-origin",
    "href": "workflows-upstream-changes-into-fork.html#opción-de-sincronización-1-importe-los-cambios-desde-upstream-y-luego-envíelos-a-origin",
    "title": "32  Importar cambios de upstream en una bifurcación",
    "section": "\n32.3 Opción de sincronización 1: importe los cambios desde upstream y luego envíelos a origin\n",
    "text": "32.3 Opción de sincronización 1: importe los cambios desde upstream y luego envíelos a origin\n\nAhora estamos listos para incorporar los cambios que no tenemos del repositorio fuente DUEÑO/REPO a nuestra copia local.\ngit pull upstream main --ff-only\nEsto dice: “importe los cambios del control remoto conocido como upstream a la rama main de mi repositorio local”. Estoy siendo explícito sobre el control remoto (upstream) y la rama (main) en este caso, tanto para hacerlo más claro como para que este comando sea robusto para configuraciones de Git a nivel de repositorio y de usuario. Pero si ha seguido nuestras recomendaciones de configuración, no es necesario que sea tan explícito.\nTambién recomiendo encarecidamente usar el indicador --ff-only en este caso, para que también diga “si hice mis propias confirmaciones con main, por favor oblígueme a enfrentar este problema AHORA”. Así es como se ve si no es posible realizar una combinación de avance rápido:\n$ git pull upstream main --ff-only\nFrom github.com:OWNER/REPO\n * branch              main     -&gt; FETCH_HEAD\nfatal: Not possible to fast-forward, aborting.\nVer Um, ¿qué pasa si toco main? para volver al camino feliz.\nSuponiendo que haya tenido éxito con git pull, el siguiente paso es opcional y muchas personas que tienen facilidad con Git no se molestan.\nSi sigues mi consejo de nunca trabajar en main de una bifurcación, entonces el estado de la rama main en tu bifurcación TU/REPO técnicamente no importa . Nunca realizará una solicitud de cambio desde main y hay formas de establecer la base correcta para las ramas y solicitudes de cambio que cree.\nSin embargo, si su comprensión de todos estos conceptos de Git es, en el mejor de los casos, escasa, puede resultar útil intentar mantener las cosas simples, ordenadas y sincronizadas.\nSiéntase libre de enviar el estado recientemente actualizado de main local a su bifurcación TU/REPO y disfrute de la satisfacción de estar “atrapado” con DUEÑO/REPO, tanto en su bifurcación remota como en su repositorio local.\nEn el shell:\ngit push origin main\nSi ha seguido nuestros consejos de configuración, realmente necesita ser así de explícito para poder enviar al origin (no al upstream).",
    "crumbs": [
      "Flujos de trabajo diarios",
      "<span class='chapter-number'>32</span>  <span class='chapter-title'>Importar cambios de upstream en una bifurcación</span>"
    ]
  },
  {
    "objectID": "workflows-upstream-changes-into-fork.html#opción-de-sincronización-2-sincroniza-tu-bifurcación-en-github-importe-los-cambios-del-origen-al-repositorio-local",
    "href": "workflows-upstream-changes-into-fork.html#opción-de-sincronización-2-sincroniza-tu-bifurcación-en-github-importe-los-cambios-del-origen-al-repositorio-local",
    "title": "32  Importar cambios de upstream en una bifurcación",
    "section": "\n32.4 Opción de sincronización 2: sincroniza tu bifurcación en GitHub, importe los cambios del origen al repositorio local",
    "text": "32.4 Opción de sincronización 2: sincroniza tu bifurcación en GitHub, importe los cambios del origen al repositorio local\nDurante muchos años, esto no fue posible, aunque muchos usuarios de GitHub deseaban esta característica. Afortunadamente, ahora es posible sincronizar una bifurcación con su repositorio de origen en el navegador, es decir, realizar la sincronización entre los 2 repositorios de GitHub. La documentación oficial de GitHub para esto es Sincronizar una rama bifurcada desde la interfaz de usuario web.\nNavegue a la página principal de su bifurcación TU/REPO, es decir, su repositorio principal que está configurado como el control remoto origin.\nEn la parte superior verá información sobre cómo se relaciona el estado de main en su bifurcación con main en el repositorio de origen, similar a lo que vemos con git status en el enfoque alternativo anterior. Lo ideal es que veas algo como:\nThis branch is 2 commits behind DUEÑO:main.\nlo que indica que puedes sincronizar en el sentido de avance rápido ideal.\nSi ves algo como esto:\nThis branch is 1 commit ahead, 2 commits behind DUEÑO:main.\nEsta es una señal de que ha tomado algunas decisiones lamentables.\nTe recomiendo que nunca hagas tus propias confirmaciones en la rama predeterminada de una bifurcación o a cualquier sucursal de la que no sea (co)propietario efectivamente. Sin embargo, si ya lo ha hecho, le explicamos cómo solucionar el problema en Um, ¿qué pasa si toco main?.\nUna vez que esté listo para continuar, haga clic en “Sync fork” en la esquina superior derecha. Si tiene éxito, la página principal de TU/REPO muestra algo como\n\nEsta sucursal está actualizada con PROPIETARIO/REPO:main.\n\nSi ha realizado confirmaciones en la rama predeterminada de su bifurcación, lo cual desaconsejamos encarecidamente, esto puede resultar en una confirmación de fusión (o incluso conflictos de fusión). Si está sufriendo debido a las confirmaciones que realizó en main y está más allá de la ayuda que describimos a continuación, considere eliminar su bifurcación y repositorio local y comenzar de nuevo con Bifurcar y clonar. Vive y aprende.\nUna vez que haya sincronizado exitosamente la rama predeterminada de TU/REPO con la rama predeterminada de PROPIETARIO/REPO, probablemente desee hacer lo mismo con su repositorio local. Dado que están sincronizados, puede importarlos desde upstream u origin.\nEn el shell, con la rama predeterminada desprotegida, ejecute uno de estos:\ngit pull upstream main --ff-only\ngit pull origin main --ff-only\nSi ha seguido nuestros consejos de configuración, en realidad no necesita especificar el control remoto y la rama, porque esta rama está configurada para importar desde upstream. Por las mismas razones que antes, es una buena idea incluir la opción --ff-only. Si ha realizado confirmaciones locales con main, esto hará surgir el problema, que se resuelve en la siguiente sección.",
    "crumbs": [
      "Flujos de trabajo diarios",
      "<span class='chapter-number'>32</span>  <span class='chapter-title'>Importar cambios de upstream en una bifurcación</span>"
    ]
  },
  {
    "objectID": "workflows-upstream-changes-into-fork.html#sec-touched-main",
    "href": "workflows-upstream-changes-into-fork.html#sec-touched-main",
    "title": "32  Importar cambios de upstream en una bifurcación",
    "section": "\n32.5 Um, ¿qué pasa si toco main?",
    "text": "32.5 Um, ¿qué pasa si toco main?\n¡Te dije que no lo hicieras!\nPero bueno, aquí estamos.\nImaginemos que este es el estado de main (o como se llame la rama predeterminada) en el repositorio fuente PROPIETARIO/REPO:\n... -- A -- B -- C -- D -- E -- F\ny este es el estado de la rama main en su copia local:\n... -- A -- B -- C -- X -- Y -- Z\nLas dos historias coinciden, hasta confirmar o indicar C, luego divergen.\nSi desea conservar el trabajo en las confirmaciones X, Y y Z, cree una nueva rama ahora mismo, con la sugerencia en Z, así, pero sustituyendo el nombre de su rama preferida:\ngit checkout -b my-great-innovations\nEsto protege sus grandes innovaciones de las confirmaciones X, Y y Z. Ahora revisa main nuevamente:\ngit checkout main\nAhora supongo que has conservado el trabajo en X, Y y Z (con una rama) o has decidido dejarlo ir.\nHaga un restablecimiento completo de la rama main para C.\ngit reset --hard C\nTendrás que descubrir cómo transmitir C en Git-speak. Especifíquelo en relación con HEAD o proporcione el SHA. Consulte Capítulo 30 para obtener más ayuda.\n\nEl historial de su rama main ahora es compatible con su historial en PROPIETARIO/REPO. Las instrucciones anteriores para importar cambios desde upstream ahora deberían funcionar. Un avance rápido debería tener éxito.\ngit pull upstream main --ff-only\nY ahora su historial local para main debería coincidir con el del repositorio de origen:\n... -- A -- B -- C -- D -- E -- F\nSi eliges crear una sucursal con tu trabajo, también la tendrás localmente:\n... -- A -- B -- C -- D -- E -- F (main)\n                   \\\n                    -- X -- Y -- Z (my-great-innovations)\nSi envió su historial alternativo (con confirmaciones X, Y y Z) a su bifurcación TU/REPO y le gusta mantener todo sincronizado, también necesitará forzar el envío de main al control remoto origin:\ngit push --force origin main\nSin embargo, realmente no nos gusta hablar de empujes forzados en Happy Git. Aquí solo lo hacemos porque estamos hablando de una bifurcación, que es bastante fácil de reemplazar si algo sale mal.",
    "crumbs": [
      "Flujos de trabajo diarios",
      "<span class='chapter-number'>32</span>  <span class='chapter-title'>Importar cambios de upstream en una bifurcación</span>"
    ]
  },
  {
    "objectID": "workflows-explore-extend-pull-request.html",
    "href": "workflows-explore-extend-pull-request.html",
    "title": "33  Explorar y ampliar una solicitud de cambio",
    "section": "",
    "text": "33.1 Actualización del futuro\nEscenario: mantiene un paquete R en GitHub con solicitudes de cambio (PR) de contribuyentes externos, p. Jane Doe, janedoe en GitHub. A veces es necesario experimentar con las relaciones públicas para poder brindar retroalimentación o decidir si fusionarse o no. Yendo más allá, a veces desea agregar algunas confirmaciones y luego fusionarlas. O tal vez simplemente haya algunos conflictos de fusión que requieran su atención local y personal. Supongamos también que desea que el autor de relaciones públicas original obtenga crédito por sus confirmaciones, es decir, desea preservar la historia y la procedencia, no solo las diferencias.\n¿Cómo se paga y posiblemente se extiende un PR externo?\nLas lecciones aprendidas aquí finalmente conducen a la familia de funciones pr_*() en uso. pr_fetch() y pr_push() son ahora mis caballos de batalla para explorar y ampliar las relaciones públicas. Puede leer más sobre las funciones de usethis para ayudar con las solicitudes de cambio en su propio artículo: Ayudantes de solicitudes de cambios.",
    "crumbs": [
      "Flujos de trabajo diarios",
      "<span class='chapter-number'>33</span>  <span class='chapter-title'>Explorar y ampliar una solicitud de cambio</span>"
    ]
  },
  {
    "objectID": "workflows-explore-extend-pull-request.html#terminología",
    "href": "workflows-explore-extend-pull-request.html#terminología",
    "title": "33  Explorar y ampliar una solicitud de cambio",
    "section": "\n33.2 Terminología",
    "text": "33.2 Terminología\nVocabulario que utilizo en todo momento.\nrama de bifurcación El nombre de la rama en la bifurcación a partir de la cual se creó la solicitud. En el mejor de los casos: nombre informativo como arreglar-conejo-peludo. En el peor de los casos: PR es de master.\nrama local de solicitud de cambio El nombre de la rama local que utilizará para trabajar con el cmbio. En el mejor de los casos: puede ser lo mismo que la rama de bifurcación. En el peor de los casos: los cambios proviene de maester, por lo que debe inventar un nuevo nombre basado en algo sobre la solicitudde cambio, p. pr-666 o janedoe-master.\npadre de solicitud de cambio El SHA de la confirmación en el repositorio principal que es la base de la solicitud de cambio.\nsolicitud de cambio remota La URL SSH o HTTPS para la bifurcación desde la cual se realizó la solicitud de cambio. O el apodo del control remoto, si te has molestado en configurarlo.",
    "crumbs": [
      "Flujos de trabajo diarios",
      "<span class='chapter-number'>33</span>  <span class='chapter-title'>Explorar y ampliar una solicitud de cambio</span>"
    ]
  },
  {
    "objectID": "workflows-explore-extend-pull-request.html#consejo-oficial-de-github-versión-1",
    "href": "workflows-explore-extend-pull-request.html#consejo-oficial-de-github-versión-1",
    "title": "33  Explorar y ampliar una solicitud de cambio",
    "section": "\n33.3 Consejo oficial de GitHub, versión 1",
    "text": "33.3 Consejo oficial de GitHub, versión 1\nCada solicitud de cambio en GitHub tiene un enlace a “instrucciones de línea de comando” sobre cómo fusionar la solicitud de cambio localmente a través de la línea de comando Git. En este viaje, hay un punto en el que puedes hacer una pausa y explorar las relaciones públicas a nivel local.\nAquí están sus pasos con mi vocabulario y algunos comandos de ejemplo:\n\n\nCrear y verificar la rama de solicitud de cambio local, anticipando su relación con la sucursal bifurcación. Plantilla del comando Git, además de un ejemplo de cómo se ve en ambos escenarios de nombres:\n# Template of the Git command\ngit checkout -b LOCAL_PR_BRANCH master \n# How it looks under both naming scenarios\ngit checkout -b fix-fluffy-bunny master \ngit checkout -b janedoe-master master \n\n\nImporte de la bifurcación del control remoto la solicitud de cambio:\n# Template of the Git command\ngit pull REMOTE FORK_PR_BRANCH\n# How it looks under both naming scenarios\ngit pull https://github.com/janedoe/yourpackage.git fix-fluffy-bunny\ngit pull https://github.com/janedoe/yourpackage.git master\n\nConfía en que todo está bien y quieres fusionarte.\n\nVerificar master:\ngit checkout master\n\n\nFusione la rama de la solicitud de cambio local en la maestra con --no-ff, que significa “sin combinación de avance rápido”. Esto garantiza que obtendrá una confirmación de fusión, con dos padres.\n# Template of the Git command\ngit merge --no-ff LOCAL_PR_BRANCH\n# How it looks under both naming scenarios\ngit merge --no-ff fix-fluffy-bunny\ngit merge --no-ff janedoe-master\n\n\nEnvie master a GitHub.\ngit push origin master\n\n\n¿Que es no le gusta? Es casi seguro que la confirmación principal de la rama de solicitud de cambio local no será la confirmación principal de la rama de solicitud de cambio bifurcada, donde el colaborador externo hizo su trabajo. Esto a menudo significa que tendrás conflictos de fusión en git pull, con los que tendrás que lidiar lo antes posible. Cuanto más antigua sea la solicitud, más probable será esto y más complicados serán los conflictos.\nPreferio ocuparme de los conflictos de fusión solo después de haber examinado la solicitud y resolver los conflictos localmente, no en GitHub. Así que no uso este flujo de trabajo exacto.",
    "crumbs": [
      "Flujos de trabajo diarios",
      "<span class='chapter-number'>33</span>  <span class='chapter-title'>Explorar y ampliar una solicitud de cambio</span>"
    ]
  },
  {
    "objectID": "workflows-explore-extend-pull-request.html#consejo-oficial-de-github-versión-2",
    "href": "workflows-explore-extend-pull-request.html#consejo-oficial-de-github-versión-2",
    "title": "33  Explorar y ampliar una solicitud de cambio",
    "section": "\n33.4 Consejo oficial de GitHub, versión 2",
    "text": "33.4 Consejo oficial de GitHub, versión 2\nGitHub tiene otro conjunto de instrucciones: Consultar solicitudes de cambio localmente\nComienza haciendo referencia a las instrucciones de la Versión 1, pero continúa abordando una solicitud de cambio inactiva”, definida como un solicitud “cuyo propietario dejó de responder o, más probablemente, eliminó su bifurcación”.\nEs posible que este flujo de trabajo NO otorgue crédito al autor de relaciones públicas original (la próxima vez que sea fácil probar esto, lo actualizaré con una respuesta definitiva). Nunca lo he usado palabra por palabra porque nunca he tenido este problema exacto con respecto a la bifurcación eliminada.",
    "crumbs": [
      "Flujos de trabajo diarios",
      "<span class='chapter-number'>33</span>  <span class='chapter-title'>Explorar y ampliar una solicitud de cambio</span>"
    ]
  },
  {
    "objectID": "workflows-explore-extend-pull-request.html#consejo-oficial-de-github-versión-3",
    "href": "workflows-explore-extend-pull-request.html#consejo-oficial-de-github-versión-3",
    "title": "33  Explorar y ampliar una solicitud de cambio",
    "section": "\n33.5 Consejo oficial de GitHub, versión 3",
    "text": "33.5 Consejo oficial de GitHub, versión 3\nGitHub tiene otro conjunto de instrucciones: Confirmar cambios en una rama de solicitud de cambio creada a partir de una bifurcación\nLa página vinculada anteriormente explica todas las condiciones previas, pero la versión corta es que un mantenedor probablemente pueda enviar nuevas confirmaciones a una solicitud, lo que efectivamente llevará las confirmaciones a una bifurcación. ¡Extraño pero cierto!\nEste conjunto de instrucciones sugiere que clones la bifurcación, revises la rama desde la cual se realizó la solictud, realices las confirmaciones que desees y luego envies. Cualquier confirmación nueva que realice aparecerá en la solictud. Y luego podrías fusionar.\nMi principal conclusión: el mantenedor puede acceder a la rama de una bifurcación asociada con una solicitud.",
    "crumbs": [
      "Flujos de trabajo diarios",
      "<span class='chapter-number'>33</span>  <span class='chapter-title'>Explorar y ampliar una solicitud de cambio</span>"
    ]
  },
  {
    "objectID": "workflows-explore-extend-pull-request.html#un-flujo-de-trabajo-que-utilicé-una-vez",
    "href": "workflows-explore-extend-pull-request.html#un-flujo-de-trabajo-que-utilicé-una-vez",
    "title": "33  Explorar y ampliar una solicitud de cambio",
    "section": "\n33.6 Un flujo de trabajo que utilicé una vez",
    "text": "33.6 Un flujo de trabajo que utilicé una vez\nLas lecciones aprendidas aquí eventualmente conducen a la familia de funciones pr_() en usethis. pr_fetch() y pr_push() son ahora mis caballos de batalla para explorar y ampliar las solicitude de cambio. Puede leer más sobre las funciones de usethis para ayudar con las solicitudes de cambios en su propio artículo: Ayudantes de solicitudes de cambios.*\nEsto combina ideas de los tres enfoques anteriores, pero con algunos ajustes. Estoy bosquejando esto en código R, con la esperanza de ponerlo en una función y paquete en algún momento. Esta es una revisión de un enfoque anterior, basada en los comentarios de Jim Hester.\nEjemplo de una solicitud de cambio de la rama master (subóptimo pero que sucede con frecuencia) del usuario ficticio de GitHub abcde en usethis.\n\nlibrary(git2r)\n\n## agregue la bifurcación del solicitante de cambios como un control remoto con nombre\nremote_add(name = \"abcde\", url = \"git@github.com:abcde/usethis.git\")\n\n## importe\nfetch(name = \"abcde\")\n\n## enumerar ramas remotas y aislar la que quiero\nb &lt;- branches(flags = \"remote\")\nb &lt;- b[[\"abcde/master\"]]\n\n## obtenga el SHA de HEAD en esta rama\nsha &lt;- branch_target(b)\n\n## crear rama local\nbranch_create(commit = lookup(sha = sha), name = \"abcde-master\")\n\n## échale un vistazot\ncheckout(object = \".\", branch = \"abcde-master\")\n\n## establecer rama de seguimiento upstream\nbranch_set_upstream(repository_head(), name = \"abcde/master\")\n\n## confirmar la rama de seguimiento upstream\nbranch_get_upstream(repository_head())\n\n## haga una o más confirmaciones aquí\n\n## envie hacia la rama en la bifurcación y, por tanto, hacia la solicitud de cambio\npush()",
    "crumbs": [
      "Flujos de trabajo diarios",
      "<span class='chapter-number'>33</span>  <span class='chapter-title'>Explorar y ampliar una solicitud de cambio</span>"
    ]
  },
  {
    "objectID": "workflows-make-github-repo-browsable.html",
    "href": "workflows-make-github-repo-browsable.html",
    "title": "34  Hacer que un repositorio de GitHub sea navegable",
    "section": "",
    "text": "34.1 Sea inteligente con sus archivos\nLa efectividad irrazonable de la navegabilidad de GitHub. Uno de mis aspectos favoritos de GitHub es la capacidad de inspeccionar los archivos de un repositorio en un navegador. Ciertas prácticas hacen que la navegación sea más gratificante y pueden posponer el día en que debas crear un sitio web adecuado para un proyecto. Quizás indefinidamente.\nMantenga los archivos en el formato más sencillo y compatible con sus objetivos principales. El texto sin formato es lo mejor. GitHub ofrece un manejo especial para ciertos tipos de archivos:",
    "crumbs": [
      "Flujos de trabajo diarios",
      "<span class='chapter-number'>34</span>  <span class='chapter-title'>Hacer que un repositorio de GitHub sea navegable</span>"
    ]
  },
  {
    "objectID": "workflows-make-github-repo-browsable.html#sea-inteligente-con-sus-archivos",
    "href": "workflows-make-github-repo-browsable.html#sea-inteligente-con-sus-archivos",
    "title": "34  Hacer que un repositorio de GitHub sea navegable",
    "section": "",
    "text": "Archivos Markdown, que pueden estar destinados a la conversión, por ejemplo, a HTML.\nArchivos Markdown denominados README.md\n\nArchivos HTML, a menudo el resultado de compilar archivos Markdown.\nCódigo fuente, como archivos .R\n\nArchivos delimitados, como CSV y TSV\nArchivos PNG",
    "crumbs": [
      "Flujos de trabajo diarios",
      "<span class='chapter-number'>34</span>  <span class='chapter-title'>Hacer que un repositorio de GitHub sea navegable</span>"
    ]
  },
  {
    "objectID": "workflows-make-github-repo-browsable.html#supere-sus-complejos-con-respecto-a-confirme-productos-derivados",
    "href": "workflows-make-github-repo-browsable.html#supere-sus-complejos-con-respecto-a-confirme-productos-derivados",
    "title": "34  Hacer que un repositorio de GitHub sea navegable",
    "section": "\n34.2 Supere sus complejos con respecto a: confirme productos derivados",
    "text": "34.2 Supere sus complejos con respecto a: confirme productos derivados\nReconozcamos la incomodidad que algunas personas sienten al poner productos derivados bajo control de versiones. Específicamente, si tiene un documento R Markdown foo.Rmd, puede ser knit() para producir el producto intermedio foo.md, que se puede convertir al resultado final foo.html. ¿Cuál de esos archivos tiene “permitido” poner bajo control de versiones? Los partidarios de la línea dura de Source-is-real sólo dirán foo.Rmd, pero los pragmáticos saben que esto puede ser un serio fastidio en la vida real. Sólo porque puedo reconstruir todo desde cero, no significa que quiera hacerlo.\nEl tabú de mantener los productos derivados bajo control de versiones se origina en la compilación de ejecutables binarios desde el código fuente. El software creado en una Mac no funcionaría en Windows, por lo que tenía sentido mantener estos binarios fuera del sagrado repositorio de código fuente. Además, se podría asumir que las personas con acceso al repositorio tienen la pila de desarrollo completa y disfrutan de las oportunidades de utilizarla. Ninguno de estos argumentos se aplica realmente al flujo de trabajo foo.Rmd --&gt; foo.md --&gt; foo.html. ¡No tenemos que seguir ciegamente las tradiciones del dominio de compilación!\nDe hecho, mirar las diferencias de foo.md o foo-figure-01.png puede resultar extremadamente informativo. Esto también es cierto en proyectos de análisis de datos más grandes después de una operación de limpieza; realizar todas las operaciones. Al observar las diferencias en los productos posteriores, a menudo se detectan cambios inesperados. Esto puede alertarle sobre cambios en los datos subyacentes y/o el comportamiento de los paquetes de los que depende.\nEste capítulo explora cosas interesantes que GitHub puede hacer con varios tipos de archivos, si terminan en su repositorio. No te preguntaré cómo llegaron allí.",
    "crumbs": [
      "Flujos de trabajo diarios",
      "<span class='chapter-number'>34</span>  <span class='chapter-title'>Hacer que un repositorio de GitHub sea navegable</span>"
    ]
  },
  {
    "objectID": "workflows-make-github-repo-browsable.html#markdown",
    "href": "workflows-make-github-repo-browsable.html#markdown",
    "title": "34  Hacer que un repositorio de GitHub sea navegable",
    "section": "\n34.3 Markdown",
    "text": "34.3 Markdown\nDescubrirá rápidamente que GitHub procesa muy bien los archivos Markdown. Al hacer clic en foo.md, obtendrá una vista previa decente de foo.html. ¡Hurra! Deberías leer la guía propia de GitHub sobre cómo aprovechar el renderizado automático de Markdown.\nExplota esto agresivamente. Haga de Markdown su formato predeterminado para archivos de texto narrativo y utilícelos libremente para insertar notas para usted y para otras personas en un repositorio alojado en Github. Es una manera fácil de obtener pseudopáginas web dentro de un proyecto “gratis”. Es posible que ni siquiera compiles estos archivos en HTML explícitamente; En muchos casos, la vista previa HTML que ofrece GitHub es todo lo que necesitas.",
    "crumbs": [
      "Flujos de trabajo diarios",
      "<span class='chapter-number'>34</span>  <span class='chapter-title'>Hacer que un repositorio de GitHub sea navegable</span>"
    ]
  },
  {
    "objectID": "workflows-make-github-repo-browsable.html#r-markdown",
    "href": "workflows-make-github-repo-browsable.html#r-markdown",
    "title": "34  Hacer que un repositorio de GitHub sea navegable",
    "section": "\n34.4 R Markdown",
    "text": "34.4 R Markdown\n¿Qué significa esto para los archivos R Markdown? Mantener Markdown intermedio. O solo renderizar en Markdown. Confirme tanto foo.Rmd como foo.md, incluso si elige .gitignore el producto final, p.e. foo.html o foo.pdf o foo.docx. Desde septiembre de 2014, GitHub representa muy bien los archivos R Markdown, como Markdown, y con resaltado de sintaxis adecuado, lo cual es genial. Pero, por supuesto, los bloques de código simplemente permanecen ahí sin ejecutarse, por lo que mi consejo sobre mantener Markdown sigue siendo válido.\nSi su formato de salida de destino no es Markdown, desea YAML frontmatter eso se parece a esto para .Rmd:\n---\ntitle: \"Something fascinating\"\nauthor: \"Jenny Bryan\"\ndate: \"`r format(Sys.Date())`\"\noutput:\n  html_document:\n    keep_md: TRUE\n---\no así para .R:\n#' ---\n#' title: \"Something fascinating\"\n#' author: \"Jenny Bryan\"\n#' date: \"`r format(Sys.Date())`\"\n#' output:\n#'   html_document:\n#'     keep_md: TRUE\n#' ---\nLa parte keep_md: TRUE dice que se mantenga el Markdown intermedio. En RStudio, al editar .Rmd, haga clic en el engranaje junto a “Knit HTML” para obtener ayuda sobre la creación de YAML.\nDesde 2016, rmarkdown ofrece un formato de salida personalizado para Markdown con sabor a GitHub, github_document. Lea acerca de flujos de trabajo de R Markdown para ejemplos explícitos de cómo utilizar esto. Si Markdown es su formato de salida de destino, su YAML puede ser aún más simple y verse así por .Rmd:\n---\noutput: github_document\n---\no así para .R:\n#' ---\n#' output: github_document\n#' ---\nPara obtener un documento rápido e independiente que no encaje perfectamente en un repositorio o proyecto (todavía), conviértalo en Gist. Ejemplo: consejos de Hadley Wickham sobre lo que debe hacer para convertirse en científico de datos. Los gists pueden contener varios archivos, por lo que aún puedes proporcionar el script R o la fuente R Markdown y el Markdown resultante, como lo hice en este artículo de Consejos para tabulación cruzada obtenidos en Twitter. He recopilado ejemplos YAML para todos los escenarios anteriores en esencia.",
    "crumbs": [
      "Flujos de trabajo diarios",
      "<span class='chapter-number'>34</span>  <span class='chapter-title'>Hacer que un repositorio de GitHub sea navegable</span>"
    ]
  },
  {
    "objectID": "workflows-make-github-repo-browsable.html#readme.md",
    "href": "workflows-make-github-repo-browsable.html#readme.md",
    "title": "34  Hacer que un repositorio de GitHub sea navegable",
    "section": "\n34.5 README.md\n",
    "text": "34.5 README.md\n\nProbablemente ya sepas que GitHub muestra README.md en el nivel superior de tu repositorio como la página de inicio de facto. Esto es análogo a lo que sucede cuando apunta un navegador web a un directorio en lugar de a una página web específica: si hay un archivo llamado index.html, eso es lo que el servidor le mostrará de forma predeterminada. En GitHub, los archivos llamados README.md desempeñan exactamente esta función para los directorios de su repositorio.\nImplicación: para cualquier grupo lógico de archivos o mini proyecto dentro de su proyecto, cree un subdirectorio en su repositorio. Y luego cree un archivo README.md para anotar estos archivos, recopilar enlaces relevantes, etc. Ahora, cuando navegue al subdirectorio en GitHub, simplemente aparecerá el README.md muy bien renderizado. El repositorio de GitHub que respalda el gapminder data package has a README en el subdirectorio data-raw eso explica exactamente cómo se crean los datos del paquete. De hecho, se genera programáticamente a partir de README.Rmd.\nAlgunos repositorios constan únicamente de README.md. Ejemplos: artículos de Jeff Leek sobre Cómo compartir datos con un estadístico o Desarrollar paquetes de R. Me estoy volviendo cada vez más fanático de los repositorios solo README que de los gists porque los problemas con los repositorios activan notificaciones, mientras que los comentarios sobre gists no.\nSi tiene un directorio lleno de figuras compatibles con la web, como PNG, puede usar código como este generar un README.md para una rápida galería de bricolaje, como lo ha hecho Karl Broman con sus FruitSnacks. Hice lo mismo con todas las fantásticas portadas de libros de O RLY hecho por The Practical Dev.\nTambién he usado este dispositivo para compartir diapositivas de Keynote en GitHub (¡mea culpa!). Exportarlos como imágenes PNG y colocarlos en una galería README: diapositivas en organización de archivos and some en denominación de archivos.",
    "crumbs": [
      "Flujos de trabajo diarios",
      "<span class='chapter-number'>34</span>  <span class='chapter-title'>Hacer que un repositorio de GitHub sea navegable</span>"
    ]
  },
  {
    "objectID": "workflows-make-github-repo-browsable.html#encontrar-cosas",
    "href": "workflows-make-github-repo-browsable.html#encontrar-cosas",
    "title": "34  Hacer que un repositorio de GitHub sea navegable",
    "section": "\n34.6 Encontrar cosas",
    "text": "34.6 Encontrar cosas\nVale, estos son consejos puros de GitHub, pero si has llegado hasta aquí, obviamente estás más interesado.\n\nPresione t para activar el buscador de archivos siempre que esté en la vista de archivos y directorios de un repositorio. IMPRESIONANTE, especialmente cuando hay archivos escondidos en muchos subdirectorios.\nPresione y para obtener un enlace permanente cuando estás viendo un archivo específico. Observe los cambios en la URL. Esto es importante si está a punto de vincular a un archivo o a líneas específicas. De lo contrario, tus enlaces se romperán fácilmente en el futuro. Si el archivo se elimina o se le cambia el nombre, o si se insertan o eliminan líneas, sus enlaces ya no apuntarán a lo que pretendía. Utilice y para obtener enlaces que incluyan una confirmación específica en la URL.",
    "crumbs": [
      "Flujos de trabajo diarios",
      "<span class='chapter-number'>34</span>  <span class='chapter-title'>Hacer que un repositorio de GitHub sea navegable</span>"
    ]
  },
  {
    "objectID": "workflows-make-github-repo-browsable.html#html",
    "href": "workflows-make-github-repo-browsable.html#html",
    "title": "34  Hacer que un repositorio de GitHub sea navegable",
    "section": "\n34.7 HTML",
    "text": "34.7 HTML\nSi tiene un archivo HTML en un repositorio de GitHub, simplemente visitar el archivo muestra el HTML sin formato. Aquí hay un bonito y feo ejemplo:\n\nhttps://github.com/STAT545-UBC/STAT545-UBC.github.io/blob/master/bit003_api-key-env-var.html\n\nNadie quiere mirar eso. Puede proporcionar esta URL a rawgit.com para publicar este HTML de forma más adecuada y obtener una vista previa decente..\nPuedes formar dos tipos diferentes de URL con rawgit.com:\n\n\nPara compartir ejemplos o demostraciones temporales de poco tráfico con un número reducido de personas, haga lo siguiente:\n\nhttps://rawgit.com/STAT545-UBC/STAT545-UBC.github.io/master/bit003_api-key-env-var.html\nBásicamente: reemplace https://github.com/ con https://rawgit.com/\n\n\n\nPara usar en sitios web de producción con cualquier cantidad de tráfico, haga esto:\n\nhttps://cdn.rawgit.com/STAT545-UBC/STAT545-UBC.github.io/master/bit003_api-key-env-var.html\nBásicamente: reemplace https://github.com/ con https://cdn.rawgit.com/\n\n\n\n2018-10-09 actualización: RawGit announced que se encuentra en una fase de puesta de sol y pronto cerrará. Ellos recomendaron: jsDelivr, GitHub Pages, CodeSandbox, y unpkg como alternativas.\nEste tipo de enlace mejorado podría ser una de las cosas útiles para incluir en un README.md u otro archivo Markdown en el repositorio.\nQuizás también quieras consultar esta extensión de Chrome o Vista previa HTML de GitHub y BitBucket, aunque recientemente he tenido más éxito con rawgit.com. (Ninguno de los dos funciona con repositorios privados de GitHub, lo cual es una razón más para conservar archivos de rebajas intermedios para HTML, como se describe anteriormente.)\nA veces, incluir archivos HTML hará que GitHub piense que su repositorio R es HTML. Además de ser un poco molesto, esto puede dificultar que las personas encuentren su trabajo si buscan específicamente repositorios de R. Puedes excluir estos archivos o directorios de las estadísticas de idioma de GitHub agregando un archivo .gitattributes eso los marca como “documentación” en lugar de código. Ver un ejemplo aquí.",
    "crumbs": [
      "Flujos de trabajo diarios",
      "<span class='chapter-number'>34</span>  <span class='chapter-title'>Hacer que un repositorio de GitHub sea navegable</span>"
    ]
  },
  {
    "objectID": "workflows-make-github-repo-browsable.html#código-fuente",
    "href": "workflows-make-github-repo-browsable.html#código-fuente",
    "title": "34  Hacer que un repositorio de GitHub sea navegable",
    "section": "\n34.8 Código fuente",
    "text": "34.8 Código fuente\nNotarás que GitHub resalta automáticamente la sintaxis del código fuente. Por ejemplo, observe el color de este script R. La extensión del archivo es el principal determinante de si y cómo se aplicará el resaltado de sintaxis. Puede ver información sobre idiomas reconocidos, las extensiones predeterminadas y más en github/linguist. Debería hacerlo de todos modos, pero deje que esta sea otra razón para seguir las convenciones en el uso de extensiones de archivos.\nTenga en cuenta que también puede hacer clic en “Sin formato” en este contexto para obtener solo el texto sin formato y nada más que el texto sin formato.",
    "crumbs": [
      "Flujos de trabajo diarios",
      "<span class='chapter-number'>34</span>  <span class='chapter-title'>Hacer que un repositorio de GitHub sea navegable</span>"
    ]
  },
  {
    "objectID": "workflows-make-github-repo-browsable.html#archivos-delimitados",
    "href": "workflows-make-github-repo-browsable.html#archivos-delimitados",
    "title": "34  Hacer que un repositorio de GitHub sea navegable",
    "section": "\n34.9 Archivos delimitados",
    "text": "34.9 Archivos delimitados\nGitHub representará muy bien datos tabulares en forma de archivos .csv (separados por comas) y .tsv (separados por tabulación). Puedes leer más en la publicación del blog anunciando esta característica en agosto de 2013 o en esta página de ayuda de GitHub.\nConsejo: ¡aprovecha esto! Si algo en su repositorio se puede almacenar de forma natural como datos delimitados, hágalo por todos los medios. Haga de la coma o la tabulación su delimitador predeterminado y use los sufijos de archivo que GitHub espera. He notado que GitHub se confunde más fácilmente que R en cosas como las citas, así que siempre inspeccione el archivo .csv o .tsv renderizado por GitHub en el navegador. Es posible que tengas que realizar una limpieza ligera para que el renderizado automático funcione correctamente. Piense en ello como otra forma más de conocer las imperfecciones de sus datos.\nAquí hay un ejemplo de un archivo delimitado por tabulaciones en GitHub: lotr_clean.tsv, encontrado originalmente aquí (no, IBM cerró manyeyes en julio de 2015).\nTenga en cuenta que también puede hacer clic en “Sin formato” en este contexto para obtener solo el texto sin formato y nada más que el texto sin formato.",
    "crumbs": [
      "Flujos de trabajo diarios",
      "<span class='chapter-number'>34</span>  <span class='chapter-title'>Hacer que un repositorio de GitHub sea navegable</span>"
    ]
  },
  {
    "objectID": "workflows-make-github-repo-browsable.html#pngs",
    "href": "workflows-make-github-repo-browsable.html#pngs",
    "title": "34  Hacer que un repositorio de GitHub sea navegable",
    "section": "\n34.10 PNGs",
    "text": "34.10 PNGs\nPNG es el formato “obvio” para almacenar cifras para la web. Pero a muchos de nosotros nos gusta un formato basado en vectores, como PDF, para figuras de uso general. En pocas palabras: los archivos PNG te volverán menos loco que los archivos PDF en GitHub. Para reducir la molestia de ver figuras en el navegador, asegúrese de tener una versión PNG en el repositorio.\nEjemplos:\n\n\nEsta figura PNG simplemente aparece en el navegador\nUna cifra diferente almacenada como PDF produce el temido y molesto aumento de velocidad “Ver Raw”. Tendrás que hacer clic y, en mi navegador OS +, esperar a que el PDF aparezca en un visor de PDF externo. 2015-06-19 update: Desde que escribí esto por primera vez, GitHub ha [elevado su tratamiento de archivos PDF] (https://github.com/blog/1974-pdf-viewing), así que YAY. Es lento pero funciona.\n\n\nEsperemos que estemos avanzando hacia un mundo en el que se pueda tener “web amigable” y “vectorial” al mismo tiempo, sin dolores de cabeza innecesarios. A partir de octubre de 2014, GitHub proporciona visualización y diferenciación mejoradas de SVG. Así que no leas este consejo como algo que desalienta a los SVG. ¡Hazlos! Pero considere mantener un PNG como respaldo de emergencia por ahora.",
    "crumbs": [
      "Flujos de trabajo diarios",
      "<span class='chapter-number'>34</span>  <span class='chapter-title'>Hacer que un repositorio de GitHub sea navegable</span>"
    ]
  },
  {
    "objectID": "workflows-make-github-repo-browsable.html#otros-formatos-de-documentos",
    "href": "workflows-make-github-repo-browsable.html#otros-formatos-de-documentos",
    "title": "34  Hacer que un repositorio de GitHub sea navegable",
    "section": "\n34.11 Otros formatos de documentos",
    "text": "34.11 Otros formatos de documentos\nEs posible que también tenga un documento que desea que otros puedan explorar e interactuar, pero no está en formato Markdown. Afortunadamente, el programa Pandoc de código abierto, escrito por John MacFarlane, le permite convertir una variedad de formatos a Markdown, incluido el formato ampliamente utilizado .docx.\nCuando hace clic en el botón Knit en RStudio, en realidad es Pandoc el que realiza la conversión final a formatos HTML o Microsoft Word (.docx). Si está dispuesto a utilizar la línea de comandos, puede realizar la conversión opuesta (por ejemplo, .docx a .md), normalmente conservando características como encabezados, tablas, ecuaciones e incluso figuras.\nComo algunos repetitivos, ejecutándose en Windows PowerShell pandoc --extract-media .\\media  -f docx .\\example.docx -t markdown_github -o example_image.md convierte un documento de Word llamado example.docx para marcar y extrae las imágenes en un directorio que corresponde a una ruta de archivo en el documento example.md recién creado. Una lista completa de formatos admitidos y códigos de ejemplo para conversiones están disponibles en https://pandoc.org/.\nTambién puede realizar conversiones simples a rebajas con sabor a GitHub desde diferentes tipos de rebajas (Pandoc admite markdown_mmd, markdown_php_extra y markdown_strict) desde dentro de RStudio. Para hacerlo, debe cambiar el nombre del archivo cambiando la extensión (por ejemplo, de foo.md a foo.Rmd), luego abra el archivo renombrado en RStudio y agregue el siguiente texto en la parte superior del documento.\n---\noutput: github_document\n---\nLuego puede hacer clic en “Knit” y luego en “Knit to github document” para realizar la conversión. Consulte Formato de salida para obtener más detalles sobre cómo controlar los formatos de salida con el frontmatter YAML.",
    "crumbs": [
      "Flujos de trabajo diarios",
      "<span class='chapter-number'>34</span>  <span class='chapter-title'>Hacer que un repositorio de GitHub sea navegable</span>"
    ]
  },
  {
    "objectID": "workflows-make-github-repo-browsable.html#vincular-a-un-archivo-zip-de-su-repositorio",
    "href": "workflows-make-github-repo-browsable.html#vincular-a-un-archivo-zip-de-su-repositorio",
    "title": "34  Hacer que un repositorio de GitHub sea navegable",
    "section": "\n34.12 Vincular a un archivo ZIP de su repositorio",
    "text": "34.12 Vincular a un archivo ZIP de su repositorio\nLa navegabilidad de GitHub hace que su trabajo sea accesible para las personas que se preocupan por su contenido pero que (todavía) no usan Git. ¿Qué pasa si esa persona quiere todos los archivos? Sí, GitHub ofrece un botón “Descargar ZIP” en el que se puede hacer clic. Pero, ¿qué sucede si desea incluir un enlace en un correo electrónico u otro documento? Si agrega /archive/master.zip al final de la URL de su repositorio, creará un enlace que descargará un archivo ZIP de su repositorio. Haga clic aquí para probar esto en un repositorio muy pequeño:\nhttps://github.com/jennybc/lotr/archive/master.zip\n¡Ve a buscar en tu carpeta de descargas!",
    "crumbs": [
      "Flujos de trabajo diarios",
      "<span class='chapter-number'>34</span>  <span class='chapter-title'>Hacer que un repositorio de GitHub sea navegable</span>"
    ]
  },
  {
    "objectID": "workflows-make-github-repo-browsable.html#enlaces-y-figuras-incrustadas.",
    "href": "workflows-make-github-repo-browsable.html#enlaces-y-figuras-incrustadas.",
    "title": "34  Hacer que un repositorio de GitHub sea navegable",
    "section": "\n34.13 Enlaces y figuras incrustadas.",
    "text": "34.13 Enlaces y figuras incrustadas.\n\nPara vincular a otra página en su repositorio, simplemente use un enlace relativo: [admin](courseAdmin/) se vinculará al directorio courseAdmin/ directorio dentro del directorio actual. [admin](/courseAdmin/) se vinculará al nivel superior courseAdmin/ directorio desde cualquier lugar del repositorio\nLa misma idea también funciona para las imágenes. ![](image.png) incluirá image.png ubicado en el directorio actual",
    "crumbs": [
      "Flujos de trabajo diarios",
      "<span class='chapter-number'>34</span>  <span class='chapter-title'>Hacer que un repositorio de GitHub sea navegable</span>"
    ]
  },
  {
    "objectID": "workflows-make-github-repo-browsable.html#deja-que-la-gente-te-corrija-en-internet",
    "href": "workflows-make-github-repo-browsable.html#deja-que-la-gente-te-corrija-en-internet",
    "title": "34  Hacer que un repositorio de GitHub sea navegable",
    "section": "\n34.14 Deja que la gente te corrija en Internet",
    "text": "34.14 Deja que la gente te corrija en Internet\n¡Les encanta eso!\nPuede crear un enlace que lleve a las personas directamente a una interfaz de edición en el navegador. Detrás de escena, suponiendo que la persona que hizo clic haya iniciado sesión en GitHub pero no sea usted, esto creará una bifurcación en su cuenta y le enviará una solicitud de cambio. Cuando hago clic en el enlace a continuación, puedo enviarme directamente al master para este repositorio.\n¡HAGA CLIC AQUÍ para sugerir una edición de esta página!\nAsí es como se ve ese enlace en la fuente de Markdown:\n[¡HAGA CLIC AQUÍ para sugerir una edición de esta página!](https://github.com/jennybc/happy-git-with-r/edit/master/workflows-make-github-repo-browsable.Rmd)\ny aquí está con marcadores de posición:\n[INVITACIÓN A EDITAR](&lt;URL to your repo&gt;/edit/master/&lt;ruta al archivo fuente de destino&gt;)\nHasta donde se, para hacer eso de una manera hábil y automática en todo un repositorio/sitio, debe usar Jekyll o algún otro sistema automatizado. Pero podrías codificar fácilmente dichos enlaces a pequeña escala.",
    "crumbs": [
      "Flujos de trabajo diarios",
      "<span class='chapter-number'>34</span>  <span class='chapter-title'>Hacer que un repositorio de GitHub sea navegable</span>"
    ]
  },
  {
    "objectID": "prompt-clone.html",
    "href": "prompt-clone.html",
    "title": "35  Clonar un repositorio",
    "section": "",
    "text": "Clona el repositorio de otra persona en GitHub donde solo quieres una copia. Pero también quieres seguir su evolución. Eso es lo que diferencia un clon de GitHub de, digamos, simplemente descargar el archivo ZIP en un momento específico.\nElija un repositorio de GitHub que le interese. Inspiración:\n\nun paquete R que te interesa\nun proyecto de análisis de datos que le parezca interesante\n\nEjemplo: el repositorio de GitHub que sustenta la publicación del blog de Polygraphing que analiza 2000 guiones está aquí: https://github.com/brandles/scripts\nEjemplo: FiveThirtyEight compartió los datos y el código detrás de su proyecto Gun Deaths in America en GitHub: https://github.com/fivethirtyeight/guns-data. Eche un vistazo también a sus otros repositorios.\n\n\nCree un nuevo proyecto RStudio desde este repositorio de GitHub. Refresque su memoria sobre cómo hacerlo volviendo a visitar nuestro flujo de trabajo “GitHub primero” en Capítulo 15.\nUna vez que tenga el código localmente, intente ejecutar parte del mismo. Intenta entender cómo funciona.\n¿Quieres hacer un cambio? ¡Bien, haz eso!\n¿Quieres enviar los cambios al autor original? Ahora sabes de primera mano cuándo debes bifurcar en lugar de clonar. Ver Capítulo 31.",
    "crumbs": [
      "Indicaciones de actividad",
      "<span class='chapter-number'>35</span>  <span class='chapter-title'>Clonar un repositorio</span>"
    ]
  },
  {
    "objectID": "prompt-fork-pr-bingo.html",
    "href": "prompt-fork-pr-bingo.html",
    "title": "36  Crear un cartón de bingo",
    "section": "",
    "text": "Aquí hay una sugerencia específica para practicar “bifurcar e importar”.\nEl flujo de trabajo general se establece en Capítulo 31.\nJenny y Dean tienen un repositorio que fabrica cartones de bingo con R:\n\nhttps://github.com/jennybc/bingo\n¡Lea el archivo README para obtener más información al respecto!\n\nTu misión:\n\n¿Quizás encontrar un socio? ¿O un par de socios?\nBifurcar el repositorio bingo.\nClonarlo en la máquina local de alguien.\nCrear un nuevo cartón de bingo haciendo un archivo de posibles casillas.\n\nSiga las instrucciones en https://github.com/jennybc/bingo/blob/master/CONTRIBUTING.md para ver cómo contribuir con una nueva tarjeta.\nConsejo profesional: es fácil ser muy divertido, pero crea un cartón de bingo muy difícil. Recuerde incluir algunas cosas fáciles para que la gente tenga la oportunidad de jugar al bingo.\n\nSi se siente virtuoso, ejecute las pruebas y revise el paquete. ¡Pídenos ayuda! O vivir peligrosamente y evitar esto.\n¡Confirme!\nVuelva a enviar sus cambios a su copia del repositorio en GitHub.\nRealizar una solicitud de cambio al repositorio principal de “bingo”.\nSi su tarjeta es apropiada, fusionaremos su solicitud y pasará a formar parte del paquete y estará disponible a través de la aplicación Shiny.\n\nInspiración especial para su uso:\n\nHaga bingo de conferencias específico para useR.\n¡Consulte este hilo temático para conocer muchas ideas cuadradas!\n\nhttps://github.com/jennybc/bingo/issues/4",
    "crumbs": [
      "Indicaciones de actividad",
      "<span class='chapter-number'>36</span>  <span class='chapter-title'>Crear un cartón de bingo</span>"
    ]
  },
  {
    "objectID": "prompt-burn-it-all-down.html",
    "href": "prompt-burn-it-all-down.html",
    "title": "37  Quemalo todo",
    "section": "",
    "text": "Esta es una técnica muy poco elegante pero eficaz para la recuperación ante desastres.\nHa sido inmortalizado en un cómic de xkcd, así que debe estar bien:\n\nhttps://xkcd.com/1597/\nhttp://explainxkcd.com/wiki/index.php/1597:_Git\n\nIdea básica:\n\nConfirme temprano y con frecuencia.\nEnvie a un control remoto, como GitHub, con frecuencia.\nEl estado de las cosas en GitHub es su nuevo “peor de los casos”.\nSi realmente arruinas las cosas localmente, copia todos los archivos (o los que hayan cambiado) a un lugar seguro.\n\nPor lo general, sus archivos están BIEN. Pero es fácil estropear la infraestructura de Git cuando eres nuevo en esto. Y puede ser difícil solucionarlo por su cuenta.\n\nCambie el nombre del repositorio local existente como medida temporal, es decir, antes de hacer algo radical, como eliminarlo.\nClona el repositorio de GitHub a tu máquina local. Has vuelto a un estado feliz.\nCopie todos los archivos relevantes desde su espacio seguro. Aquellos cuyo estado actualizado necesita confirmar.\nPrepare cambios y confirme. Enviar.\nSigue con tu vida.\n\nPractica esto antes de que lo necesites, así verás cómo funciona.",
    "crumbs": [
      "Indicaciones de actividad",
      "<span class='chapter-number'>37</span>  <span class='chapter-title'>Quemalo todo</span>"
    ]
  },
  {
    "objectID": "prompt-practice-resets.html",
    "href": "prompt-practice-resets.html",
    "title": "38  Restablecer",
    "section": "",
    "text": "Practica recuperarte de los errores.\nUtilice un repositorio que haya creado anteriormente en el tutorial para esto. Solo necesita ser local, es decir, esto no involucra a GitHub.\nSi no es su confirmación más reciente, considere seriamente dejarlo pasar. Justo. Dejar. Él. Ir.\n¿Entonces quieres deshacer la última confirmación?\nSi “SÍ, DESHAGALO COMPLETAMENTE”: git reset --hard HEAD^. ¡Perderá cualquier cambio que no se haya reflejado en la última confirmación!\nSi “SÍ, deshaga la confirmación, pero deje los archivos en ese estado (pero sin preparar)”: git reset HEAD^. Sus archivos seguirán siendo los mismos, pero la confirmación se deshará y no se preparará nada.\nSi “SÍ, regrese al momento anterior a mi confirmación”: git reset --soft HEAD^. Sus archivos permanecerán igual pero la confirmación se deshará. Incluso se restaurarán los cambios realizados.\nSi solo desea modificar la confirmación más reciente o su mensaje, puede modificarlo. ¡Puedes hacer esto desde RStudio!\n\nRealice el cambio que desee y modifique la confirmación.\n¿Quieres cambiar sólo el mensaje de confirmación?\n\nHaz otro pequeño cambio. ¿Seguramente tienes un error tipográfico en alguna parte? Modifique la confirmación, lo que le brinda la oportunidad de editar el mensaje.\n\n\nPara modificar desde la línea de comando, usando un editor para crear el mensaje:\ngit commit --amend\nPara modificar desde la línea de comando, proporcionando el nuevo mensaje:\ngit commit --amend -m \"New commit message\"\nRestablecimiento de Git desmitificado:\nhttps://git-scm.com/book/en/v2/Git-Tools-Reset-Demystified",
    "crumbs": [
      "Indicaciones de actividad",
      "<span class='chapter-number'>38</span>  <span class='chapter-title'>Restablecer</span>"
    ]
  },
  {
    "objectID": "prompt-search-github.html",
    "href": "prompt-search-github.html",
    "title": "39  Buscar en GitHub",
    "section": "",
    "text": "39.1 Recursos básicos\nBúsqueda en GitHub\nEspejo de solo lectura de la fuente R de Winston Chang:\nEspejo de solo lectura de todos los paquetes en CRAN por Gábor Csárdi:",
    "crumbs": [
      "Indicaciones de actividad",
      "<span class='chapter-number'>39</span>  <span class='chapter-title'>Buscar en GitHub</span>"
    ]
  },
  {
    "objectID": "prompt-search-github.html#recursos-básicos",
    "href": "prompt-search-github.html#recursos-básicos",
    "title": "39  Buscar en GitHub",
    "section": "",
    "text": "https://github.com/search/advanced\nhttps://help.github.com/articles/searching-code/\nhttps://help.github.com/articles/search-syntax/\n\n\n\nhttps://github.com/wch/r-source\n\n\n\nhttps://github.com/cran\nhttp://cran.github.io\nMETACRAN",
    "crumbs": [
      "Indicaciones de actividad",
      "<span class='chapter-number'>39</span>  <span class='chapter-title'>Buscar en GitHub</span>"
    ]
  },
  {
    "objectID": "prompt-search-github.html#caso-de-uso",
    "href": "prompt-search-github.html#caso-de-uso",
    "title": "39  Buscar en GitHub",
    "section": "39.2 Caso de uso",
    "text": "39.2 Caso de uso\n¿Qué pasa si una función en un paquete no tiene ejemplos? ¿O está mal ejemplificado? ¿No sería bueno encontrar ejemplos funcionales de esto “en la naturaleza”?\nVia Twitter, Noam Ross me enseñó una forma inteligente de realizar este tipo de búsquedas en GitHub. Coloque esto en el cuadro de búsqueda de GitHub para ver cómo los paquetes en CRAN usan la función llply() de plyr:\n\"llply\" user:cran language:R\nO simplemente haga clic aquí.\nOtro ejemplo que apareció recientemente en r-package-devel:\n¿Cómo ver muchos ejemplos de plantillas de roxygen?\nEsta búsqueda encuentra &gt;1400 ejemplos de plantillas de roxygen en la naturaleza:\nhttps://github.com/search?q=man-roxygen+in%3Apath&type=Code&ref=searchresults",
    "crumbs": [
      "Indicaciones de actividad",
      "<span class='chapter-number'>39</span>  <span class='chapter-title'>Buscar en GitHub</span>"
    ]
  },
  {
    "objectID": "notes-intro.html",
    "href": "notes-intro.html",
    "title": "Notas",
    "section": "",
    "text": "Esta parte contiene contenido obsoleto/obsoleto, que aún no existe o que se relaciona con la mecánica de libros.",
    "crumbs": [
      "Notas",
      "Notas"
    ]
  },
  {
    "objectID": "notes-classroom-overview.html",
    "href": "notes-classroom-overview.html",
    "title": "40  Realiza un curso con GitHub",
    "section": "",
    "text": "40.1 Beneficios\nEste contenido es bastante obsoleto y es poco probable que se desarrolle más.\nGitHub es una plataforma maravillosa para impartir un curso. He estado haciendo esto en github.com desde 2014 en STAT 545, un curso de posgrado de 80 estudiantes en análisis de datos con R, y en un segundo gran curso de posgrado con uso intensivo de código en genómica estadística. Estamos ejecutando todos los cursos para el programa de Maestría en Ciencia de Datos de la UBC desde una instancia privada de GitHub Enterprise alojado en Canadá.\nPara el instructor\nPara los estudiantes",
    "crumbs": [
      "Notas",
      "<span class='chapter-number'>40</span>  <span class='chapter-title'>Realiza un curso con GitHub</span>"
    ]
  },
  {
    "objectID": "notes-classroom-overview.html#beneficios",
    "href": "notes-classroom-overview.html#beneficios",
    "title": "40  Realiza un curso con GitHub",
    "section": "",
    "text": "Si ya usa Git/GitHub, es extremadamente eficiente usar los mismos flujos de trabajo para administrar los materiales del curso, el trabajo de los estudiantes y la comunicación con los estudiantes y los asistentes técnicos.\n\nCuando cambié a Git/GitHub y R Markdown, ¿abandoné mi antiguo “sistema” de aceptar todo tipo de cosas como archivos adjuntos de correo electrónico? Fue la primera vez que ejecuté el código en los proyectos finales de mis alumnos, porque fue muy fácil tenerlo en mi computadora de manera organizada. ¡Incluso hice algunas correcciones como solicitudes de cambio!\n\nSi todavía estás en tus inicios con Git/GitHub, el gran volumen de operaciones y los plazos pequeños y regulares aumentarán tu dominio muy rápidamente. ¡La práctica hace la perfección! Sin embargo, no recomendaría realizar un curso en GitHub como su primer proyecto sustancial de control de versiones.\n\n\n\nHe descubierto que los estudiantes se adaptan a Git/GitHub con bastante rapidez y realmente les gusta. Les resulta gratificante ver sus hermosos y ricos informes R Markdown en Internet. Como es fácil exponer su trabajo dentro de la clase, hacemos mucha revisión por pares. Encuentro que la experiencia se propaga por la clase como un virus. Esto se aplica tanto al contenido del plato principal como al flujo de trabajo.\nMuchos estudiantes están específicamente interesados en aprender Git y GitHub, como complemento a las habilidades analíticas y de codificación que enseñamos en estos cursos. El hecho de que lo utilicemos para mecánica de curso mata dos pájaros de un tiro. Enseñar el uso del control de versiones distribuidas es un objetivo pedagógico válido en sí mismo.",
    "crumbs": [
      "Notas",
      "<span class='chapter-number'>40</span>  <span class='chapter-title'>Realiza un curso con GitHub</span>"
    ]
  },
  {
    "objectID": "notes-classroom-overview.html#la-configuración-del-estudiante-stat-545",
    "href": "notes-classroom-overview.html#la-configuración-del-estudiante-stat-545",
    "title": "40  Realiza un curso con GitHub",
    "section": "40.2 La configuración del estudiante STAT 545",
    "text": "40.2 La configuración del estudiante STAT 545\nLas organizaciones/equipos y la API de GitHub han cambiado a lo largo de los más de 3 años que llevamos haciendo esto, por lo que mi enfoque ha evolucionado con el tiempo y también está moldeado por una dura experiencia.\nPuntos principales:\n\nCrear una organización para el curso.\n\nSolicite inmediatamente un descuento educativo para la Organización, de modo que pueda obtener repositorios privados ilimitados.\n\nHaga que sus estudiantes se registren de forma gratuita y personal cuentas GitHub.\n\nAnímelos a solicitar un descuento educativo en su propio nombre (también conocido como “paquete de desarrollador para estudiantes”). Pero tenga la seguridad de que nada de lo que necesita para la maquinaria de su curso dependerá de esto.\n\nObtenga los nombres de usuario de GitHub de sus estudiantes: utilizamos una aplicación Shiny! - además de algo de información que le permite vincularlos a su lista oficial de cursos.\nCree un equipo de estudiantes y un equipo de asistencia técnica. Hago estos equipos para cada ejecución del curso, p.e. 2016_estudiantes y 2016_ap.\nInvite a los estudiantes a unirse a la organización de su curso y al equipo de estudiantes. Lo mismo ocurre con los TA y el equipo de TA.\nCree un nombre canónico para cada estudiante, basado en la lista oficial de cursos, es decir, apellido_nombre.\nCree un repositorio para cada estudiante, utilizando el nombre canónico del estudiante.\n\nEste es un repositorio privado dentro de la organización del curso.\nApago los wikis y dejo que GitHub se inicialice automáticamente o inserte inmediatamente archivos, incluido un archivo README, en los repositorios.\nDar al equipo de estudiantes acceso de lectura o extracción al repositorio de cada estudiante. Sí, esto les permite verse trabajar unos a otros. Hablo de esto en otro lugar.\nProporcionar al equipo de asistencia técnica acceso por escritura o inserción al repositorio de cada estudiante.\nAgregar al alumno como colaborador con acceso de escritura o push.\n¡Deja de mirar estos repositorios personalmente! Vaya que notificación.\n\n\n¡Esa es la configuración! Utilizo los paquetes gh y purrr para programar todo esto API de GitHub funciona. En una segunda ola, publicaré fragmentos de código para las operaciones anteriores.\nLo que NO debes hacer (voz de la experiencia, aquí):\nNO permita que los estudiantes creen sus propios repositorios.\n\nTendrás una convención de nomenclatura y ellos nunca, jamás, la seguirán.\nDebes tener derechos de administrador sobre el repositorio de cursos, para poder manipularlo a voluntad a través de la API de GitHub. Les pedirás que te agreguen a ti y a los TA como colaboradores, pero no todos lograrán ejecutar esta tarea.\nQuerrá realizar varias operaciones masivas en los repositorios y su trabajo de API será más simple si los repositorios pertenecen a la misma organización en lugar de recorrer repositorios con nombres aleatorios propiedad de personas aleatorias, sujeto a sus caprichos.",
    "crumbs": [
      "Notas",
      "<span class='chapter-number'>40</span>  <span class='chapter-title'>Realiza un curso con GitHub</span>"
    ]
  },
  {
    "objectID": "notes-classroom-overview.html#el-flujo-de-tareas",
    "href": "notes-classroom-overview.html#el-flujo-de-tareas",
    "title": "40  Realiza un curso con GitHub",
    "section": "40.3 El flujo de tareas",
    "text": "40.3 El flujo de tareas\nEn clase, los estudiantes toman posesión de sus repositorios, desde RStudio vía File &gt; New Project. Hacen la mayor parte de su trabajo de curso aquí: es un directorio en su computadora, un repositorio de Git asociado con el control remoto de GitHub y un proyecto RStudio.\nNormalmente, la tarea se realiza en R Markdown, utilizando el formato de salida github_document. Confirman y envían .Rmd, .md y cualquier archivo necesario, como cifras.\nLa tarea se envía abriendo una edición:\n\nEl nombre del problema es “Marcar tarea x de apellido_primer nombre”. Bueno, en realidad no, pero puedo soñar.\nEl cuerpo debe contener el SHA de su última confirmación, etiquetas para el TA de marcado o el equipo de TA y, idealmente, enlaces a los archivos que se van a marcar.\n\nLos asistentes técnicos dejan comentarios aquí. Las marcas reales se almacenan en otro lugar y se distribuyen por correo electrónico. Como marcan las AT, cierran los temas.\nDespués de enviar la tarea, asignamos aleatoriamente a cada estudiante para que revise el trabajo de dos compañeros. Cada tarea de revisión por pares toma la forma de un problema, asignado al revisor. Los estudiantes dejan comentarios unos a otros aquí. Como marcan los AT, leen y evalúan estas revisiones por pares (¡también puntuadas!) y cierran los temas.",
    "crumbs": [
      "Notas",
      "<span class='chapter-number'>40</span>  <span class='chapter-title'>Realiza un curso con GitHub</span>"
    ]
  },
  {
    "objectID": "notes-classroom-overview.html#github-como-sistema-de-gestión-de-cursos",
    "href": "notes-classroom-overview.html#github-como-sistema-de-gestión-de-cursos",
    "title": "40  Realiza un curso con GitHub",
    "section": "40.4 GitHub como sistema de gestión de cursos",
    "text": "40.4 GitHub como sistema de gestión de cursos\n2017-05-29 Esta sección fue eliminada de un artículo que estoy escribiendo. Es parcialmente redundante con lo anterior y los dos se fusionarán.\nSTAT 545 es un curso de análisis y discusión de datos en la Universidad de Columbia Británica. Fui el instructor a cargo durante varios años, lo que coincidió con mi propia adopción de Git/GitHub. GitHub se utiliza para gestionar el desarrollo del material del curso, servir al sitio web del curso, crear un foro de discusión y alojar todo el trabajo enviado por los estudiantes.\nDado que los estudiantes deben enviar su trabajo y proporcionar una revisión por pares del trabajo de otros a través de GitHub, el uso del control de versiones alojado es una parte explícita, aunque modesta, del curso. El sitio web Happy Git y GitHub para el usuario contiene nuestras instrucciones probadas en batalla para la configuración y el uso inicial. Los estudiantes alcanzan las competencias básicas con bastante rapidez y les resulta gratificante ver sus informes R Markdown formateados y ricos en cifras en Internet. Dado que es fácil exponer su trabajo dentro de la clase, llevamos a cabo una revisión por pares, lo que ayuda a que la experiencia se difunda rápidamente en todo el grupo.\n\n40.4.1 Utilice una organización GitHub\nOrganizaciones de GitHub son “cuentas compartidas donde grupos de personas pueden colaborar en muchos proyectos a la vez”. Esta es la estructura más adecuada para administrar los recursos del curso, ya que puedo otorgar a los asistentes técnicos y a los estudiantes diferentes niveles de acceso a varios repositorios. El acceso se puede controlar a nivel de usuario individual o, más convenientemente, para equipos completos. El equipo de asistencia técnica comparte conmigo acceso de escritura en un repositorio privado para asuntos internos. Proporciono a cada estudiante su propio repositorio privado para el trabajo del curso y otorgo acceso de lectura a otros miembros del equipo de estudiantes, para facilitar la revisión por pares. Existe un repositorio público que sustenta el sitio web del curso (ver más abajo). Tenemos otro repositorio público que existe únicamente para que los Problemas puedan usarse como foro de discusión.\nGitHub fomenta activamente el uso de su plataforma en la enseñanza. Como instructor, puede solicitar una cuenta de organización gratuita que proporciona funciones que normalmente solo están disponibles en planes pagos, como repositorios privados. De hecho, GitHub proporciona herramientas para flujos de trabajo de enseñanza específicos a través de GitHub Classroom, aunque yo no las uso. Esto no es un golpe intencional a sus herramientas. Comencé a enseñar con GitHub varios años antes de que esto existiera y desarrollé una forma diferente de usar la plataforma. También encuentro que los recursos de GitHub Education están más orientados a la informática que a la ciencia de datos.\n\n\n40.4.2 Páginas de GitHub para el sitio web del curso\nTodo el contenido del curso se proporciona en el sitio web de STAT 545. Cada página se genera a partir de un documento R Markdown que se representa en HTML localmente utilizando el paquete rmarkdown, conservando el Markdown intermedio. Estas páginas son una mezcla de prosa y código R renderizado, lo que refleja la codificación en vivo realizada en clase. Todos estos archivos y su historial se pueden explorar en el repositorio de origen. El equipo de asistencia técnica tiene permiso para escribir en este repositorio, lo que significa que pueden (¡y lo hacen!) ayudarme a mantener el sitio web. Me alegro de no ser más el webmaster. También recibimos correcciones de errores tipográficos y otras aportaciones del mundo en general, ya que esto es completamente público.\nSi hoy comenzara desde cero, continuaría usando R Markdown, RStudio y GitHub Pages (ver más abajo), pero actualizaría a un enfoque más moderno y automatizado para representar las páginas. Ahora recomiendo sitios web de R Markdown, bookdown o blogdown para gestionar el proceso de creación de un sitio web estático a partir de un conjunto grande e interrelacionado de archivos .Rmd.\nGitHub ofrece varias formas de alojar un sitio web directamente desde un repositorio, conocido colectivamente como Páginas de GitHub. El sitio web STAT 545 es una Página de organización muy simple que utiliza un dominio personalizado, stat545.com, en lugar del valor predeterminado orgname.github.io.\nEste sistema para gestionar el contenido del curso es un gran ejemplo de cómo integrar la realización del trabajo y su intercambio. Analizamos datos en vivo en clase, usando R, basándonos en los scripts del sitio web. Vuelvo a renderizar el .R o .Rmd asociado, confirmo los archivos modificados, los envío y lo veo reflejado de inmediato en http://stat545.com. No existe separación entre tener una idea, implementarla y publicarla en el sitio web.\n\n\n40.4.3 Repositorios privados específicos para estudiantes\nAl principio del curso, obtengo nombres de usuario de GitHub para los estudiantes registrados, a través de una aplicación Shiny, y los invito a unirse a la organización del curso. Luego creo un repositorio privado por estudiante, en la Organización STAT 545. El estudiante objetivo tiene acceso de escritura y los demás estudiantes tienen acceso de lectura. Esto es algo controvertido, debido a la posibilidad de hacer trampa, pero he visto más ventajas que desventajas en esta configuración, en el contexto de STAT 545. En otras configuraciones, también he usado un repositorio por estudiante por tarea, lo que le permite mantener los repositorios completamente privados hasta la entrega de la tarea y luego aumentar su visibilidad durante la calificación y la revisión por pares. Algunos cursos funcionarán mejor con un modelo u otro.\nCada estudiante hace su trabajo en este repositorio y envía una tarea importante aproximadamente una vez por semana. La primera tarea es simplemente reclamar el repositorio y crear un archivo README, lo que demuestra que tienen toda la configuración de software relevante y que pueden escribir un poco de Markdown. Cada semana abordamos algún nuevo análisis de datos o una tarea de discusión, con un margen cada vez mayor para la independencia. La tarea se implementa en documentos de R Markdown, se representa en Markdown y se envía a GitHub. Los estudiantes envían su trabajo abriendo una incidencia en su repositorio, nombrando la tarea en el título, proporcionando el SHA de la confirmación final asociada y vinculándolo al archivo principal .md. Dejamos comentarios en el hilo del problema o, ocasionalmente, proponemos cambios en el código mediante “solicitudes de cambio”. Se seleccionan dos pares al azar para revisar cada tarea, un proceso que también implementamos a través de GitHub Issues.\nAl final del trimestre, el estudiante (¡y su instructor!) pueden visitar el repositorio para encontrar una secuencia organizada y navegable de ~10 tareas. Cada estudiante se marcha con documentación escrita por él mismo de todo lo que ha hecho, lista para consultar en futuros proyectos. Las últimas asignaciones requieren escribir un paquete R o una aplicación Shiny, lo que generalmente hacen en repositorios públicos bajo sus propias cuentas. Terminan STAT 545 con varios meses de experiencia en Git/GitHub y el inicio de una cartera de ciencia de datos.",
    "crumbs": [
      "Notas",
      "<span class='chapter-number'>40</span>  <span class='chapter-title'>Realiza un curso con GitHub</span>"
    ]
  },
  {
    "objectID": "notes-ideas.html",
    "href": "notes-ideas.html",
    "title": "41  Ideas para contenido",
    "section": "",
    "text": "41.1 Preguntas comunes sobre el flujo de trabajo",
    "crumbs": [
      "Notas",
      "<span class='chapter-number'>41</span>  <span class='chapter-title'>Ideas para contenido</span>"
    ]
  },
  {
    "objectID": "notes-ideas.html#preguntas-comunes-sobre-el-flujo-de-trabajo",
    "href": "notes-ideas.html#preguntas-comunes-sobre-el-flujo-de-trabajo",
    "title": "41  Ideas para contenido",
    "section": "",
    "text": "41.1.1 Situaciones comunes y cómo recuperarlas/evitarlas\nhttps://twitter.com/JennyBryan/status/743457387730735104\n\n\n41.1.2 Mantener algo fuera de Git\nListarlo en .gitignore.\n\n\n41.1.3 No quise cometer eso\nCometer cosas que no era tu intención (demasiado grandes, secretas). Cómo deshacer.",
    "crumbs": [
      "Notas",
      "<span class='chapter-number'>41</span>  <span class='chapter-title'>Ideas para contenido</span>"
    ]
  },
  {
    "objectID": "notes-ideas.html#git-stuff",
    "href": "notes-ideas.html#git-stuff",
    "title": "41  Ideas para contenido",
    "section": "41.2 git stuff",
    "text": "41.2 git stuff\nGit explicadores, pesados en los diagramas\nhttps://twitter.com/JennyBryan/status/743548245645791232\nUna referencia visual de Git\nhttp://marklodato.github.io/visual-git-guide/index-en.html\nUn modelo de ramificación de Git exitoso\nhttp://nvie.com/posts/a-successful-git-branching-model/\nUn modelo exitoso de ramificación de Git se considera dañino\nhttps://barro.github.io/2016/02/a-succesful-git-branching-model-considered-harmful/\nTutoriales de Git de Atlassian https://www.atlassian.com/git/tutorials/\nLección para principiantes de software de carpintería Git\nhttp://swcarpentry.github.io/git-novice/\nMichael Freeman se desliza sobre la colaboración con Git\nhttp://slides.com/michaelfreeman/git-collaboration#/\nMateriales de formación de GitHub\nhttps://services.github.com/kit/\nGit para mayores de 4 años\nhttps://www.youtube.com/watch?v=3m7BgIvC-uQ\nAprenda la ramificación de Git\nhttp://learngitbranching.js.org\nUna serie de tutoriales sobre el flujo de trabajo de Git http://vallandingham.me/git-workflow.html\n\nParte 1: Ramas de funciones\nParte 2: Revisión de solicitudes de cambio\nParte 3: Revisión de solicitudes de cambio localmente\nParte 4: Fusionar solicitudes de cambio\n\nGit desde adentro hacia afuera\nhttps://codewords.recurse.com/issues/two/git-from-the-inside-out",
    "crumbs": [
      "Notas",
      "<span class='chapter-number'>41</span>  <span class='chapter-title'>Ideas para contenido</span>"
    ]
  },
  {
    "objectID": "notes-ideas.html#recuperación-ante-desastres",
    "href": "notes-ideas.html#recuperación-ante-desastres",
    "title": "41  Ideas para contenido",
    "section": "41.3 Recuperación ante desastres",
    "text": "41.3 Recuperación ante desastres\nhttp://stackoverflow.com/questions?sort=votes\nDesglosarlo:\n\n¿Hay algún problema con mi sistema de archivos/archivos?\n¿Mi repositorio de git está en mal estado?\n¿Cómo puedo evitar que esto vuelva a suceder?\n\nTécnicas para evitar rebases.\nEstado sin cabeza. Infierno rebase.\nQué hacer cuando no puedes, por ejemplo, cambiar de rama. Confirmaciones de Trabajo en Proceso.",
    "crumbs": [
      "Notas",
      "<span class='chapter-number'>41</span>  <span class='chapter-title'>Ideas para contenido</span>"
    ]
  },
  {
    "objectID": "notes-ideas.html#interactúe-con-el-código-fuente-de-r-en-github",
    "href": "notes-ideas.html#interactúe-con-el-código-fuente-de-r-en-github",
    "title": "41  Ideas para contenido",
    "section": "41.4 Interactúe con el código fuente de R en GitHub",
    "text": "41.4 Interactúe con el código fuente de R en GitHub\nInteractúe con la fuente R en GitHub\nHojeada\nBúsqueda\n\nMi esencia, re: el usuario de cran: https://gist.github.com/jennybc/4a1bf4e9e1bb3a0a9b56\n\nSer un usuario útil\n\nmanténgase informado sobre: desarrollo\nuse problemas para informes de errores, solicitudes de funciones\nhacer solicitudes de cambio",
    "crumbs": [
      "Notas",
      "<span class='chapter-number'>41</span>  <span class='chapter-title'>Ideas para contenido</span>"
    ]
  },
  {
    "objectID": "notes-ideas.html#flujo-de-trabajo-y-psicología",
    "href": "notes-ideas.html#flujo-de-trabajo-y-psicología",
    "title": "41  Ideas para contenido",
    "section": "41.5 Flujo de trabajo y psicología",
    "text": "41.5 Flujo de trabajo y psicología\nEstrés de trabajar al aire libre\nFlujos de trabajo para grupo de 1, 2, 5, 10\n\nBifurcación e importar vs repositorio compartido\n\nhttps://help.github.com/articles/about-collaborative-development-models/\nhttps://help.github.com/articles/using-pull-requests/",
    "crumbs": [
      "Notas",
      "<span class='chapter-number'>41</span>  <span class='chapter-title'>Ideas para contenido</span>"
    ]
  },
  {
    "objectID": "shell.html",
    "href": "shell.html",
    "title": "Apéndice A — El shell",
    "section": "",
    "text": "A.1 ¿Qué es el shell?\nIncluso si realiza la mayoría de sus operaciones de Git a través de un cliente, como RStudio o GitKraken, a veces debe trabajar en el shell. A medida que te sientas más cómodo con Git, es posible que prefieras hacer más y más a través de la línea de comandos. Es posible que también necesites utilizar Git o operaciones del sistema de archivos en un servidor que carece de tu cliente Git habitual. Por todas estas razones, es una buena idea aprender a manejar el caparazón.\nEste es un aspecto típico de un caparazón. Verá un cursor parpadeante simple, esperando entrada:\nEl shell es un programa de su computadora cuyo trabajo es ejecutar otros programas. Los pseudosinónimos son “terminal”, “línea de comando” y “consola”. Hay un hilo completo de StackExchange sobre las diferencias (¿Cuál es la diferencia entre Terminal, Consola, Shell y Línea de comandos?), pero no lo encuentro muy esclarecedor. Su kilometraje puede variar.\nMuchos programadores pasan mucho tiempo en un shell, a diferencia de las GUI, porque es muy rápido, conciso y ubicuo en sus entornos informáticos relevantes. Así es como se hacía todo el trabajo antes de que tuviéramos el mouse y las GUI.\nEl shell más común es bash y a veces se utiliza como sustituto de “shell”, al igual que “Coke” y “Kleenex” son sustitutos de cola y pañuelos de papel.\nEn Happy Git, a veces hacemos una demostración del uso de un shell para ciertas tareas, como navegar por el sistema de archivos y realizar operaciones de Git, cuando no queremos o no podemos usar RStudio. Proporcionar comandos de shell también es menos ambiguo y menos perecedero que describir las interacciones humanas con una GUI.",
    "crumbs": [
      "Apéndices",
      "<span class='chapter-number'>A</span>  <span class='chapter-title'>El shell</span>"
    ]
  },
  {
    "objectID": "shell.html#comenzando-el-caparazón",
    "href": "shell.html#comenzando-el-caparazón",
    "title": "Apéndice A — El shell",
    "section": "A.2 Comenzando el caparazón",
    "text": "A.2 Comenzando el caparazón\n\nA.2.1 Desde dentro de RStudio\nPuede iniciar un shell desde RStudio. Esto suele ser útil, porque RStudio hace todo lo posible para ubicarlo en un directorio de trabajo sano, es decir, en el proyecto actual.\nHay dos maneras:\n\nTools &gt; Terminal lanza un shell dentro de RStudio, gráficamente y en términos de proceso. Creo que esto suele ser lo que quieres.\nTools &gt; Shell … lanza un shell externo a RStudio.\n\n\n\nA.2.2 Fuera de RStudio\n\nA.2.2.1 macOS\nEl shell a menudo se denomina “terminal” en macOS, con lo que la gente se refiere a Terminal.app. Una forma de iniciarlo es a través de Spotlight Search. Escribe Comando + espacio y comienza a escribir “terminal”. Este proceso será algo así:\n\nTerminal.app normalmente se encuentra en /Applications/Utilities/Terminal.app.\nAl abrir Terminal.app, accederá a un shell bash abierto en su directorio de inicio ~/, que es una abreviatura de /Users/SUNOMBREDEUSUARIO. Deberías ver algo como esto:\n\nSi tiene derechos administrativos en su computadora, anteponer cualquier comando con sudo le permitirá ejecutar el comando como administrador. Espere que le cuestionen su contraseña. Si necesita cambiar los privilegios administrativos o su contraseña, consulte este artículo de Apple.\n\n\nA.2.2.2 Windows\nAplazamos esto hasta la siguiente sección, debido a la situación más compleja del shell en Windows.",
    "crumbs": [
      "Apéndices",
      "<span class='chapter-number'>A</span>  <span class='chapter-title'>El shell</span>"
    ]
  },
  {
    "objectID": "shell.html#sec-windows-shell-hell",
    "href": "shell.html#sec-windows-shell-hell",
    "title": "Apéndice A — El shell",
    "section": "A.3 Windows es especial… y no en el buen sentido",
    "text": "A.3 Windows es especial… y no en el buen sentido\nWindows no es la plataforma ideal para el desarrollo de software y computación científica. Gran parte de la funcionalidad se sentirá rara y limitada. Porque lo es.\nHay no menos de 4 posibles shells en los que puedes terminar. A menos que lo sepas mejor, es casi seguro que querrás estar en un shell de Git Bash, especialmente aquí en Happy Git.\nLos usuarios de Windows querrán comprender los diferentes tipos de shell, cómo iniciarlos y cómo saber en cuál se encuentra.\n\nA.3.1 Git bash\nTL;DR ¿cómo saber si estás en un shell de Git Bash? Haz esto:\n$ echo $SHELL\n/usr/bin/bash\nGit Bash es un shell bash que se incluye con Git para Windows, que es la forma Happy Git de instalar Git en Windows. Por lo tanto, no tendrá Git Bash en su sistema hasta que instale Git para Windows.\nGit Bash es siempre el shell de Windows al que nos dirigimos en las instrucciones de Happy Git.\nRStudio debería detectar automáticamente la presencia de Git Bash. Puede inspeccionar e influir en esto directamente a través de Tools &gt; Global Options &gt; Terminal. A menos que tenga una buena razón para hacer lo contrario, querrá ver “Git Bash” en el menú desplegable “Nuevas terminales abiertas con…”.\n\nConsejos para solucionar problemas:\n\nReinicie RStudio. Debe reiniciar todas las instancias de RStudio después de instalar Git para Windows (+ Git Bash), para que RStudio detecte automáticamente Git Bash.\nActualizar RStudio. El manejo del shell en RStudio ha mejorado dramáticamente con el tiempo, por lo que es posible que las versiones anteriores no se comporten como se describe aquí.\n\n\nA.3.1.1 Accediendo a Git Bash fuera de RStudio\nA veces quieres ejecutar Git Bash fuera de RStudio. Esta es la forma más sencilla: haga clic en el menú “Git” en el menú de Windows y seleccione “Git Bash”.\n\nUn shell de Git Bash que se ejecuta fuera de RStudio se parece a esto:\n\nObserve “MSYS” en la barra de título. Es posible que también vea “MINGW64”.\nA veces es necesario ejecutar Git Bash como administrador, p. para ejecutar con mayores privilegios. La forma más fácil: haga clic en el menú “Git” en el menú de Windows y haga clic derecho en “Git Bash”. Esto revela un submenú. Seleccione “más” y luego “Ejecutar como administrador”.\n\n\n\n\nA.3.2 Consola de comandos del sistema\nTL;DR ¿cómo saber si estás en la consola de comandos del sistema? Haz esto:\nC:\\Users\\jenny&gt;echo %COMSPEC%\nC:\\WINDOWS\\system32\\cmd.exe\nEste es el intérprete de línea de comandos nativo de Windows. Rara vez es lo que desea, especialmente para el trabajo descrito en Happy Git.\nUna sesión de símbolo del sistema que se ejecuta fuera de RStudio se parece a esto:\n\nObserve el cmd.exe en la barra de título, aunque no siempre está presente. También es posible que vea “Símbolo del sistema”.\nSi recibe un mensaje de error como 'pwd' no se reconoce como un comando interno o externo, programa ejecutable o archivo por lotes. de un comando de shell, eso sugiere que de alguna manera ha iniciado cmd.exe cuando no lo hizo quiero decir.\n\n\nA.3.3 PowerShell\nTL;DR ¿cómo saber si estás en PowerShell? Haz esto:\nPS C:\\Users\\jenny&gt; Get-ChildItem Env:ComSpec\n\nName                           Value\n----                           -----\nComSpec                        C:\\WINDOWS\\system32\\cmd.exe\nPowerShell es otro shell de Windows, un sucesor más moderno del símbolo del sistema. Además, rara vez es lo que desea, especialmente para el trabajo descrito en Happy Git.\nUna sesión de PowerShell que se ejecuta fuera de RStudio se parece a esto:\n\nObserve el powershell.exe en la barra de título.\n\n\nA.3.4 Bash a través de servicios de Windows para Linux\nTL;DR ¿cómo saber si estás en Bash a través de WSL? Haz esto:\n$ echo $SHELL\n/bin/bash\nEn 2016, Microsoft lanzó el Subsistema de Windows para Linux (WSL), “una nueva característica de Windows 10 que le permite ejecutar herramientas nativas de línea de comandos de Linux directamente en Windows”. En general, este es un desarrollo fantástico. Sin embargo, al momento de escribir este artículo (enero de 2019), solo tendrá esto si ejecuta Windows 10 de 64 bits y ha elegido instalar el componente del sistema WSL opcional. Por lo tanto, espero que sólo los entusiastas tengan esto y, en ese caso, probablemente no necesites este capítulo.\nUn shell bash WSL que se ejecuta fuera de RStudio se parece a esto:\n\nPara su información, Microsoft también se refiere a WSL como Bash en Ubuntu en Windows.\n\nA.3.4.1 Conclusión de Windows\nEn caso de duda, probablemente quieras estar en un shell de Git Bash.",
    "crumbs": [
      "Apéndices",
      "<span class='chapter-number'>A</span>  <span class='chapter-title'>El shell</span>"
    ]
  },
  {
    "objectID": "shell.html#comandos-básicos-de-shell",
    "href": "shell.html#comandos-básicos-de-shell",
    "title": "Apéndice A — El shell",
    "section": "A.4 Comandos básicos de shell",
    "text": "A.4 Comandos básicos de shell\nLos comandos más básicos se enumeran a continuación:\n\npwd (print working directory). Muestra el directorio o “carpeta” en el que está operando actualmente. Este no es necesariamente el mismo que el directorio de trabajo R que obtiene getwd().\nls (list files). SCómo se muestran los archivos en el directorio de trabajo actual. Esto equivale a mirar los archivos en su Finder/Explorer/Administrador de archivos. Utilice ls -a para enumerar también archivos ocultos, como .Rhistory y .git.\ncd (change directory). Le permite navegar a través de sus directorios cambiando el directorio de trabajo del shell. Puedes navegar así.:\n\ngo al subdirectorio foo del directorio de trabajo actual: cd foo\nir al directorio principal del directorio de trabajo actual: cd ..\nvaya a su directorio “inicial”: cd ~ o simplemente cd\nvaya al directorio usando la ruta absoluta, funciona independientemente de su directorio de trabajo actual: cd /home/my_username/Desktop. Windows usa una sintaxis ligeramente diferente con las barras entre los nombres de las carpetas invertidas., \\, por ejemplo cd C:\\Users\\MY_USERNAME\\Desktop.\n\nConsejo profesional 1: arrastrar y soltar un archivo o carpeta en la ventana del terminal pegará la ruta absoluta en la ventana.\nConsejo profesional 2: utilice la tecla tab para autocompletar nombres de archivos y directorios inequívocos. Presione tab dos veces para ver todas las opciones ambiguas.\n\n\nUtilice las flechas hacia arriba y hacia abajo para repetir los comandos anteriores. O buscar comandos anteriores con CTRL + r.\n\nAlgunos comandos de Git:\n\ngit status es el comando de git más utilizado y le informa sobre su rama actual, cualquier cambio o archivo sin seguimiento y si está sincronizado con sus controles remotos.\ngit remote -v enumera todos los controles remotos. Muy útil para asegurarse de que git conozca su control remoto y que la dirección remota sea correcta.\ngit remote add origin GITHUB_URL agrega el control remoto GITHUB_URL con apodo origin.\ngit remote set-url origin GITHUB_URL cambia la URL remota de “origen” a GITHUB_URL. De esta manera puedes corregir errores tipográficos en la URL remota.\nNo dudes en sugerir otros comandos que merezcan incluirse en un problema de GitHub.",
    "crumbs": [
      "Apéndices",
      "<span class='chapter-number'>A</span>  <span class='chapter-title'>El shell</span>"
    ]
  },
  {
    "objectID": "comic-relief.html",
    "href": "comic-relief.html",
    "title": "Apéndice B — Alivio cómico",
    "section": "",
    "text": "¡No eres tú, es Git!\nSi aún no estás llorando, estas páginas de manual de Git ficticias pero realistas deberían ser la solución:\n\ngit-man-page-generator\nY, por supuesto, la fuente subyacente también está disponible en GitHub:\n\nhttps://github.com/Lokaltog/git-man-page-generator\n\n\nSi puedes tolerar el lenguaje adulto y a menudo ofensivo, es posible que disfrutes de:\n\nhttp://www.commitlogsfromlastnight.com\nhttp://ohshitgit.com/\n\nTus confirmaciones se verán más gloriosas al desplazarte al estilo de Star Wars:\n\nhttp://starlogs.net\nhttp://starlogs.net/#jennybc/googlesheets\nHaga esto para cualquier repositorio: http://starlogs.net/#USER/REPO",
    "crumbs": [
      "Apéndices",
      "<span class='chapter-number'>B</span>  <span class='chapter-title'>Alivio cómico</span>"
    ]
  },
  {
    "objectID": "resources.html",
    "href": "resources.html",
    "title": "Apéndice C — Recursos",
    "section": "",
    "text": "¡Practicamos lo que predicamos! Este sitio está creado con Git y R Markdown, utilizando el paquete bookdown. Continúe y eche un vistazo detrás de escena.\nA largo plazo, debería comprender más lo que está haciendo. Hacer clic de memoria en RStudio puede ser un método de supervivencia a corto plazo, pero no funcionará por mucho tiempo.\n\nGit for Humans es un gran conjunto de diapositivas de Alice Bartlett, presentadas originalmente en 2016 en UX Brighton.\nGit in Practice de Mike McQuaid es un libro más accesible, probablemente mejor que Pro Git (a continuación) para la mayoría de las personas que comienzan. Materiales auxiliares en GitHub.\nEl libro Pro Git es fantástico y completo.\nOh My Git! es un juego interactivo gratuito y de código abierto para aprender Git. Es muy amigable para principiantes y utiliza un gráfico para visualizar el árbol de trabajo. Las lecciones se pueden completar usando una interfaz de naipes además de la línea de comando incorporada, que está ahí para cuando los usuarios se sientan más cómodos..\nLos propios materiales de capacitación de GitHub pueden resultar útiles. También señalan muchos otros recursos\nBusque un cliente Git potente (Capítulo 8) si desea minimizar el uso de Git desde la línea de comandos.\nDiez reglas simples para aprovechar Git y GitHub http://journals.plos.org/ploscompbiol/article?id=10.1371/journal.pcbi.1004947\nGuía de RStudio Control de versiones con Git y SVN\nEl libro Team Geek tiene consejos interesantes para los aspectos humanos y colaborativos del control de versiones. Propone estrategias de Git adaptadas a diferentes características de los equipos.",
    "crumbs": [
      "Apéndices",
      "<span class='chapter-number'>C</span>  <span class='chapter-title'>Recursos</span>"
    ]
  },
  {
    "objectID": "references.html",
    "href": "references.html",
    "title": "Apéndice D — Referencias",
    "section": "",
    "text": "Bartlett, Alice. 2016. “Git for Humans.” Financial Times,\nLondon; Talk at UX Brighton. https://speakerdeck.com/alicebartlett/git-for-humans.\n\n\nPerez-Riverol, Yasset, Laurent Gatto, Rui Wang, Timo Sachsenberg, Julian\nUszkoreit, Felipe da Veiga Leprevost, Christian Fufezan, et al. 2016.\n“Ten Simple Rules for Taking Advantage of Git and GitHub.”\nPLOS Computational Biology 12 (7): 1–11. https://doi.org/10.1371/journal.pcbi.1004947.\n\n\nRam, Karthik. 2013. “Git Can Facilitate Greater Reproducibility\nand Increased Transparency in Science.” Source Code for\nBiology and Medicine 8 (1): 7. https://doi.org/10.1186/1751-0473-8-7.\n\n\nWickham, Hadley. 2015. R Packages. 1st ed. O’Reilly Media, Inc.",
    "crumbs": [
      "Apéndices",
      "<span class='chapter-number'>D</span>  <span class='chapter-title'>Referencias</span>"
    ]
  }
]